// Bison grammar file (arithmetic_parser.y)
%{
#include <stdio.h>
extern int yyerror(char *);
%}
%code {
    // This is actual code that will be added to the output
    #ifndef YYSTYPE
        typedef double YYSTYPE;
    #endif /* !YYSTYPE */
    extern void yyparse();              // Function generated by bison.
    int yylex(void);                  // Function provided from flex.
}
%union {
    char ch_val;
    double num_val;   // Add YYSTYPE here only if it's not in prologue code block above (if %code{} syntax is used) or at all when using "%glr-parser" option with bison.
}
%token NUMBER
%%
expr: term
       { $$ = $1;                    }
     | expr '+' term                // +term OR + and * have same precedence, so left associative wins here (no need for %left).
        { $$ = $1 + $3;             }
     | expr '-' term                { $$ = $1 - $3;    }
term: factor          { $$ = $1;           }
   | term '*' factor       // '+' and '*' have same precedence, so left associative wins here (no need for %left).
        { $$ = $1 * $3;             }
     | term '/' factor         { $$ = $1 / $3;    }
factor: NUMBER     { $$ = $1;                  }
      | '(' expr ')'   { $$ = $2;               }
%%
// Main Program for Parser.
int main() {
        yyparse();            // Initialize and call YYParse().
}