#!/usr/bin/env ruby\n\nrequire 'rubygems'\nrequire 'net/ssh'\nrequire 'highline/import'\n\nfile = ARGV[ARGV.index('-i') + 1] if ARGV.include?('-i')\nputs 'No input file specified' unless file\n\nhost = "10.0.0.10"\nuser = "user"\nprod = "new-#{file}"               # product filename (call it <file>-new)\nrpath = "/home/#{user}/.rffmpeg"   # remote computer operating directory\nrfile = "#{rpath}/#{file}"         # remote filename\nrprod = "#{rpath}/#{prod}"         # remote product\ncmd = "ffmpeg -i #{rfile} #{rprod}"# remote command, constructed\n\npass = ask("Password: ") { |q| q.echo = false }  # password from stdin\n\nNet::SSH.start(host, user) do |ssh|\n        ssh.sftp.connect do |sftp|\n\n                # upload local 'file' to remote 'rfile'\n                sftp.upload!(file, rfile)\n\n                # run remote command 'cmd' to produce 'rprod'\n                ssh.open_channel do |channel|\n                    channel.exec cmd do |ch, success|\n                        abort "FAIL: couldn't execute command (#{ch[:exit_status]})" unless success\n                        # STDOUT for the program's regular output\n                        ch.on_data do |_, data|\n                            print data \n                        end\n\n                        # STDERR for error messages\n                        ch.on_extended_data do |_, type, data|\n                            puts "STDERR: #{data}"\n                        end\n\n                        channel.on_request("exit-status") do |ch, data|\n                             exit_code = data.read_long\n                             if exit_code != 0 then warn "#{cmd} exited with non-zero status (#{exit_code})" end\n\n                             # download remote 'rprod' to local 'prod'\n                             sftp.download!(rprod, prod)\n                        end\n                    end\n                end\n\n                ssh.loop\n        end\nend