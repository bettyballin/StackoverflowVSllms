# spec/support/matchers/have_access_control.rb\n\nRSpec::Matchers.define :have_access_control do |options|\n  match do |block_of_code|\n    @allowed = options.fetch(:allowed, [])\n    @disallowed = options.fetch(:disallowed, [])\n\n    @allowed.each do |role|\n      user_for_role(role)\n      expect(&block_of_code).not_to raise_error\n    end\n\n    @disallowed.each do |role|\n      user_for_role(role)\n      expect { block_of_code.call }.to raise_error(ActionController::RoutingError) ||\n        expect { block_of_code.call }.to raise_error(ActiveRecord::RecordNotFound) ||\n        expect(block_of_code).not_to have_http_status(:success)\n    end\n  end\n\n  failure_message do |block_of_code|\n    "expected the action #{block_of_code} to be accessible only by roles #{@allowed}" +\n    " but was accessible by #{@disallowed}"\n  end\n\n  failure_message_when_negated do |block_of_code|\n    "expected the action #{block_of_code} not to be accessible by roles #{@allowed}" +\n    " or to be accessible by #{@disallowed}"\n  end\n\n  description do\n    "have access control allowed for #{@allowed} and disallowed for #{@disallowed}"\n  end\n\n  # Helper method to sign in as a specific role\n  def user_for_role(role)\n    case role\n    when :super_admin\n      @user = SuperAdmin.create(email: 'superadmin@example.com', password: 'password')\n    when :admin\n      @user = Admin.create(email: 'admin@example.com', password: 'password')\n    when :editor\n      @user = Editor.create(email: 'editor@example.com', password: 'password')\n    when :user\n      @user = User.create(email: 'user@example.com', password: 'password')\n    end\n\n    sign_in(@user)\n  end\nend