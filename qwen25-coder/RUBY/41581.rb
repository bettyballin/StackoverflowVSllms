require 'socket'\nrequire 'digest'\nrequire 'timeout'\n\nclass ICMPPing\n  ICMP_ECHO_REQUEST = 8\n\n  def initialize(host)\n    @host = host\n    @sock = Socket.new(Socket::AF_INET, Socket::SOCK_RAW, Socket::IPPROTO_ICMP)\n    @seq_number = 0\n    @pid = Process.pid & 0xffff\n  end\n\n  def ping(payload)\n    timeout(5) do\n      send_packet(payload)\n      received_payload = receive_response\n      received_payload == payload ? "Match" : "Mismatch"\n    end\n  rescue Timeout::Error\n    "Timeout"\n  ensure\n    @seq_number += 1\n  end\n\n  private\n\n  def send_packet(payload)\n    checksum = compute_checksum([ICMP_ECHO_REQUEST, 0, @seq_number].pack('CCS') + payload)\n\n    packet = [\n      ICMP_ECHO_REQUEST,\n      0,\n      checksum,\n      @pid,\n      @seq_number\n    ].pack('CCnNN') + payload\n\n    @sock.send(packet, 0, Socket.pack_sockaddr_in(0, @host))\n  end\n\n  def receive_response\n    data = ''\n    loop do\n      partial_data, _ = @sock.recvfrom(1500)\n      data += partial_data\n      break if data.size >= 28 # Minimum size of ICMP packet\n    end\n\n    data[28..-1] if valid_icmp_response?(data)\n  end\n\n  def compute_checksum(msg)\n    message = msg.each_byte.inject(0) { |sum, b| sum + b } & 0xffff\n    ~message & 0xffff\n  end\n\n  def valid_icmp_response?(data)\n    return false if data.size < 28\n\n    ip_header_length = ((data[0].ord & 15) * 32) / 8 # Get the IP header length\n\n    icmp_header = data.slice(ip_header_length, 8)\n    type, code, received_checksum, _, seq_number = icmp_header.unpack('CCnNN')\n\n    return false unless type == ICMP_ECHO_REQUEST + 8 && seq_number == @seq_number\n\n    computed_checksum = compute_checksum(data.slice(ip_header_length, -ip_header_length))\n    received_checksum == computed_checksum\n  end\nend\n\n# Usage:\nping_tool = ICMPPing.new('127.0.0.1')\npayload = "This is a test payload."\nputs ping_tool.ping(payload)