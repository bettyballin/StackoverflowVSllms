require 'openssl'\nrequire 'base64'\n\n# Generate a random cipher key and iv (Initialization Vector)\n# This should be done once and stored securely if reused.\ncipher_key = OpenSSL::Random.random_bytes(32) # AES-256 requires 256 bit key\niv = OpenSSL::Random.random_bytes(16)         # AES block size is 128 bits\n\n# Assuming the original_key is what you want to encrypt and use as your shared secret\noriginal_key = "super_secret_key"\n\n# Encrypt the original key\ncipher = OpenSSL::Cipher.new("aes-256-cbc")\ncipher.encrypt\ncipher.key = cipher_key\ncipher.iv = iv\n\nencrypted_key = cipher.update(original_key) + cipher.final\n\n# Combine the IV and encrypted key for storage (since you need both to decrypt)\nstorage_secure_key = Base64.encode64(iv + encrypted_key)\n\n# Store `storage_secure_key` as an environment variable in your application's configuration\n# ENV['SECURE_KEY'] = storage_secure_key  # set this externally, not shown here\n\n# To retrieve and use the key:\ndef get_shared_key(cipher_key)\n  combined = Base64.decode64(ENV['SECURE_KEY'])\n  iv = combined[0...16]\n  encrypted_key = combined[16..-1]\n\n  decipher = OpenSSL::Cipher.new("aes-256-cbc")\n  decipher.decrypt\n  decipher.key = cipher_key\n  decipher.iv = iv\n\n  # Important: Ensure to clear sensitive data from memory after use, if possible.\n  original_key = decipher.update(encrypted_key) + decipher.final\n\n  return original_key\nend\n\nshared_key = get_shared_key(cipher_key)\nputs "Shared Key: #{shared_key}"