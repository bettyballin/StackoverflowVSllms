// Function to generate a unique ID\nfunction generateUniqueId() {\n    return '_' + Math.random().toString(36).substr(2, 9);\n}\n\nclass DomainObject {\n    constructor(id = null) {\n        // Assign a unique client-side ID if none is provided\n        this.clientId = id || generateUniqueId();\n        this.serverId = id; // This will be updated post-save\n    }\n\n    bind(eventType, callback) {\n        if (eventType === 'saved') {\n            this.onSavedCallback = callback;\n        }\n    }\n\n    save() {\n        // Simulate saving and receiving an ID from the server\n        this.serverId = Math.random().toString(36).substr(2, 9);\n        \n        // Execute saved callback with new server ID\n        if (this.onSavedCallback) {\n            this.onSavedCallback(this.serverId);\n        }\n    }\n}\n\nconst identityMap = {};\n\n// Create a new object\nconst domainObj = new DomainObject();\n\n// Add it to the identity map using clientId (since serverId is not available yet)\nidentityMap[domainObj.clientId] = 'foo';\n\nconsole.log("Before save:", domainObj, identityMap);\n\n// Bind the saved event to update the key in the identity map\ndomainObj.bind('saved', function(newServerId) {\n    if (domainObj.clientId !== newServerId) {\n        // Update the key from clientId to serverId once known\n        identityMap[newServerId] = identityMap[domainObj.clientId];\n        delete identityMap[domainObj.clientId];\n    }\n    domainObj.serverId = newServerId;\n});\n\n// Save the object (simulated)\ndomainObj.save();\n\nconsole.log("After save:", domainObj, identityMap);