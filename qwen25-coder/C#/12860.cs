using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing Org.BouncyCastle.Asn1.Cms;\nusing Org.BouncyCastle.Crypto.Digests;\nusing Org.BouncyCastle.Crypto.Modes.Gcm;\nusing Org.BouncyCastle.Crypto.Parameters;\nusing Org.BouncyCastle.Security;\n\npublic void TestMethod1()\n{\n    byte[] data = new byte[1024]; // plaintext: a list of zeroes\n\n    // Encrypt data\n    var keyGen = GeneratorUtilities.GetKeyGenerator("AES");\n    keyGen.Init(256);\n    KeyParameter keyParam = (KeyParameter)keyGen.GenerateKey();\n    byte[] iv = SecureRandom.GetSeed(16); // IV should be 16 bytes for AES-GCM\n\n    AeadParameters parameters = new AeadParameters(keyParam, 128, iv);\n\n    var cipher = CipherUtilities.GetCipher("AES/GCM/NoPadding");\n    cipher.Init(true, parameters);\n\n    byte[] encryptedData = new byte[cipher.GetOutputSize(data.Length)];\n    int outputLen1 = cipher.ProcessBytes(data, 0, data.Length, encryptedData, 0);\n    int outputLen2 = cipher.DoFinal(encryptedData, outputLen1);\n    var encryptedWithIv = Concatenate(iv, encryptedData, 0, outputLen1 + outputLen2); // Add IV at the beginning\n\n    // Compute HMAC\n    HMac hmac = new HMac(new Sha256Digest());\n    byte[] hmacKey = SecureRandom.GetSeed(32);\n    hmac.Init(new KeyParameter(hmacKey));\n    hmac.BlockUpdate(encryptedWithIv, 0, encryptedWithIv.Length);\n    byte[] macBytes = CalcMac(hmac);\n\n    // Encode HMAC and encrypted data\n    var cmsGenerator = new CmsEnvelopedDataGenerator();\n    var encryptionKey = new Pkcs5Scheme2PbeKey("foo", new byte[] { 1, 2, 3 }, 2048);\n    cmsGenerator.AddPasswordRecipient(encryptionKey, CmsEnvelopedDataGenerator.Aes256Cbc);\n    var macWithEncrypted = Concatenate(macBytes, encryptedWithIv); // Prepend HMAC\n    var cmsByteArray = new CmsProcessableByteArray(macWithEncrypted);\n\n    CmsEnvelopedData envelopeData = cmsGenerator.Generate(cmsByteArray, CmsEnvelopedDataGenerator.Aes256Cbc);\n    byte[] encodedData = envelopeData.GetEncoded();\n\n    // Tampering can be done here\n    // encodedData[500] = 10;\n\n    // Decrypt and verify MAC\n    var recipientID = new RecipientID();\n    var decodedEnvelopeData = new CmsEnvelopedData(encodedData);\n    var decryptRecipient = decodedEnvelopeData.GetRecipientInfos().GetFirstRecipient(recipientID);\n    var decryptedDataWithHmacAndIv = decryptRecipient.GetContent(encryptionKey);\n\n    byte[] receivedMacBytes = new byte[32];\n    Array.Copy(decryptedDataWithHmacAndIv, 0, receivedMacBytes, 0, receivedMacBytes.Length);\n    byte[] receivedEncrypted = new byte[decryptedDataWithHmacAndIv.Length - 32];\n    Array.Copy(decryptedDataWithHmacAndIv, 32, receivedEncrypted, 0, receivedEncrypted.Length);\n\n    // Extract IV and encrypted data\n    iv = new byte[16]; // AES-GCM IV size\n    Array.Copy(receivedEncrypted, 0, iv, 0, 16);\n    byte[] encryptedOnly = new byte[receivedEncrypted.Length - 16];\n    Array.Copy(receivedEncrypted, 16, encryptedOnly, 0, encryptedOnly.Length);\n\n    // Verify MAC\n    hmac.Init(new KeyParameter(hmacKey));\n    hmac.BlockUpdate(receivedEncrypted, 0, receivedEncrypted.Length);\n    byte[] checkMacBytes = CalcMac(hmac);\n\n    if (!AreEqual(macBytes, checkMacBytes))\n    {\n        Console.WriteLine("MAC verification failed!");\n        return;\n    }\n\n    // Decrypt data\n    parameters = new AeadParameters(keyParam, 128, iv);\n    cipher.Init(false, parameters);\n\n    byte[] decryptedData = new byte[cipher.GetOutputSize(encryptedOnly.Length)];\n    outputLen1 = cipher.ProcessBytes(encryptedOnly, 0, encryptedOnly.Length, decryptedData, 0);\n    outputLen2 = cipher.DoFinal(decryptedData, outputLen1);\n    var finalDecrypted = new ArraySegment<byte>(decryptedData, 0, outputLen1 + outputLen2);\n\n    Console.WriteLine("Decryption successful. Data integrity verified.");\n}\n\nprivate byte[] Concatenate(byte[] first, byte[] second)\n{\n    byte[] result = new byte[first.Length + second.Length];\n    Buffer.BlockCopy(first, 0, result, 0, first.Length);\n    Buffer.BlockCopy(second, 0, result, first.Length, second.Length);\n    return result;\n}\n\nprivate byte[] Concatenate(params byte[][] arrays)\n{\n    var concatenated = new List<byte>();\n    foreach (var array in arrays)\n        concatenated.AddRange(array);\n\n    return concatenated.ToArray();\n}\n\nprivate static bool AreEqual(byte[] a, byte[] b)\n{\n    uint diff = 0;\n    for (int i = 0; i < Math.Min(a.Length, b.Length); ++i)\n        diff |= (uint)(a[i] ^ b[i]);\n    \n    diff |= (uint)(a.Length - b.Length);\n    return 0 == diff;\n}\n\nprivate static byte[] CalcMac(HMac hmac)\n{\n    byte[] output = new byte[hmac.GetMacSize()];\n    hmac.DoFinal(output, 0);\n    \n    return output;\n}