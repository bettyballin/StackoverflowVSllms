using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string dllPath = @"C:\path\to\your\dll.dll"; // Change this to your DLL path\n        Console.WriteLine(DetermineDllArchitecture(dllPath));\n    }\n\n    public static string DetermineDllArchitecture(string filePath)\n    {\n        using (Stream stream = File.OpenRead(filePath))\n        {\n            IMAGE_DOS_HEADER dosHeader;\n            byte[] buffer = new byte[Marshal.SizeOf(typeof(IMAGE_DOS_HEADER))];\n            stream.Read(buffer, 0, Marshal.SizeOf(typeof(IMAGE_DOS_HEADER)));\n            dosHeader = FromByteArray<IMAGE_DOS_HEADER>(buffer);\n\n            if (dosHeader.e_magic == IMAGE_DOS_HEADER.IMAGE_DOS_SIGNATURE)\n            {\n                // PE header starts at offset e_lfanew\n                stream.Seek(dosHeader.e_lfanew, SeekOrigin.Begin);\n                buffer = new byte[Marshal.SizeOf(typeof(IMAGE_FILE_HEADER))];\n                stream.Read(buffer, 0, Marshal.SizeOf(typeof(IMAGE_FILE_HEADER)));\n                var fileHeader = FromByteArray<IMAGE_FILE_HEADER>(buffer);\n\n                if (fileHeader.Magic == IMAGE_FILE_HEADER.IMAGE_NT_SIGNATURE)\n                {\n                    // Read the optional header\n                    buffer = new byte[Marshal.SizeOf(typeof(uint))]; // Magic is the first entry of IMAGE_OPTIONAL_HEADER\n                    stream.Read(buffer, 0, Marshal.SizeOf(typeof(uint)));\n                    uint optionalHeaderMagic = BitConverter.ToUInt32(buffer, 0);\n\n                    switch (optionalHeaderMagic)\n                    {\n                        case 0x10b: // Optional Header Standard Fields magic number for PE32\n                            return "32-bit";\n                        case 0x20b: // Optional Header Standard Fields magic number for PE32+\n                            return "64-bit";\n                        default:\n                            return "Unknown";\n                    }\n                }\n            }\n\n            throw new ArgumentException("The file is not a valid Portable Executable.");\n        }\n    }\n\n    static T FromByteArray<T>(byte[] bytes) where T : struct\n    {\n        GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);\n        try\n        {\n            return Marshal.PtrToStructure<T>(handle.AddrOfPinnedObject());\n        }\n        finally\n        {\n            handle.Free();\n        }\n    }\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct IMAGE_DOS_HEADER\n{\n    public const int IMAGE_DOS_SIGNATURE = 0x5A4D; // "MZ"\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort e_magic;  // Magic number (must be IMAGE_DOS_SIGNATURE)\n\n    // Other fields can be added as needed\n}\n\n[StructLayout(LayoutKind.Sequential, Pack = 1)]\npublic struct IMAGE_FILE_HEADER\n{\n    public const int IMAGE_NT_SIGNATURE = 0x4550; // "PE\0\0"\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort Machine;\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort NumberOfSections;\n\n    [MarshalAs(UnmanagedType.U4)]\n    public uint TimeDateStamp;\n\n    [MarshalAs(UnmanagedType.U4)]\n    public uint PointerToSymbolTable;\n\n    [MarshalAs(UnmanagedType.U4)]\n    public uint NumberOfSymbols;\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort SizeOfOptionalHeader;\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort Characteristics;\n\n    [MarshalAs(UnmanagedType.U2)]\n    public ushort Magic; // Magic number (must be IMAGE_NT_SIGNATURE)\n}