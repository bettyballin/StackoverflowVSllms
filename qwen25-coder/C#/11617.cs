using System;\nusing System.Collections.Generic;\n\npublic class Range<T>\n{\n    public T Start { get; set; }\n    public T End { get; set; }\n\n    public Range(T start, T end)\n    {\n        Start = start;\n        End = end;\n    }\n}\n\npublic static class RangeExtensions\n{\n    public static IEnumerable<Range<T>> Collapse<T>(this IEnumerable<Range<T>> ranges, IComparer<T> comparer = null) where T : IComparable<T>\n    {\n        comparer ??= Comparer<T>.Default;\n\n        var sortedRanges = new List<Range<T>>(ranges);\n        sortedRanges.Sort((x, y) =>\n        {\n            int startComparison = comparer.Compare(x.Start, y.Start);\n            return startComparison != 0 ? startComparison : comparer.Compare(y.End, x.End);\n        });\n\n        foreach (var range in sortedRanges)\n        {\n            if (comparer.Compare(range.Start, range.End) > 0)\n                throw new ArgumentException("Invalid range: Start is greater than End.");\n\n            yield return range;\n        }\n\n        using var enumerator = sortedRanges.GetEnumerator();\n        if (!enumerator.MoveNext())\n            yield break;\n\n        Range<T> currentRange = enumerator.Current;\n        while (enumerator.MoveNext())\n        {\n            var nextRange = enumerator.Current;\n\n            int startComparison = comparer.Compare(nextRange.Start, currentRange.End);\n            if (startComparison <= 0 || (startComparison == 1 && comparer.Compare(nextRange.Start, currentRange.End) == 1))\n            {\n                // Overlapping or adjacent ranges\n                currentRange.End = comparer.Compare(currentRange.End, nextRange.End) > 0 ? currentRange.End : nextRange.End;\n            }\n            else\n            {\n                yield return currentRange;\n                currentRange = nextRange;\n            }\n        }\n\n        yield return currentRange;\n    }\n}