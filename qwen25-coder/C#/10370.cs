using System;\nusing System.Linq;\nusing System.Net;\n\npublic class IPAddressManipulation\n{\n    public static void Main()\n    {\n        string ipAddress = "10.171.24.69";\n        string subnetMask = "255.255.255.128"; // or you can use "25" for /25\n\n        var ipBytes = IPAddress.Parse(ipAddress).GetAddressBytes();\n        var maskBytes = ParseSubnetMask(subnetMask);\n\n        byte[] networkBytes = new byte[4];\n        byte[] broadcastBytes = new byte[4];\n\n        for (int i = 0; i < ipBytes.Length; i++)\n        {\n            networkBytes[i] = (byte)(ipBytes[i] & maskBytes[i]);\n            broadcastBytes[i] = (byte)(networkBytes[i] | ~maskBytes[i]);\n        }\n\n        IPAddress networkAddress = new IPAddress(networkBytes);\n        IPAddress broadcastAddress = new IPAddress(broadcastBytes);\n\n        Console.WriteLine($"Network Address: {networkAddress}");\n        Console.WriteLine($"Broadcast Address: {broadcastAddress}");\n    }\n\n    private static byte[] ParseSubnetMask(string subnetMask)\n    {\n        byte[] maskBytes;\n        if (subnetMask.Contains('.'))\n        {\n            // If the subnet mask is expressed in dotted-decimal notation\n            maskBytes = IPAddress.Parse(subnetMask).GetAddressBytes();\n        }\n        else\n        {\n            // If the subnet mask is expressed as a number of bits (e.g., "24")\n            int numBits = Convert.ToInt32(subnetMask);\n            int fullOctets = numBits / 8;\n            byte[] bytes = Enumerable.Repeat(byte.MaxValue, fullOctets).ToArray();\n            byte partialOctet = (byte)(0xFF << (8 - (numBits % 8)));\n            if (bytes.Length < 4)\n                Array.Resize(ref bytes, 4);\n            bytes[^1] = partialOctet;\n            maskBytes = bytes;\n        }\n        return maskBytes;\n    }\n}