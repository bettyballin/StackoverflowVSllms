ServicePointManager.ServerCertificateValidationCallback += (sender, cert, chain, sslPolicyErrors) =>\n{\n    // Check if there are no errors or the only error is RemoteCertificateNameMismatch\n    if (sslPolicyErrors == SslPolicyErrors.None ||\n        sslPolicyErrors == SslPolicyErrors.RemoteCertificateNameMismatch)\n    {\n        // Extract the subject alternative names from the certificate.\n        var sanExtensions = cert.Extensions.OfType<X509SubjectAlternativeNameExtension>().FirstOrDefault();\n        if (sanExtensions != null && sanExtensions.Critical)\n        {\n            foreach (var san in sanExtensions.SubjectAlternativeNames)\n            {\n                if (IsWildcardMatch(san, "v1.api.serviceprovider.com"))\n                {\n                    return true; // Match found\n                }\n            }\n        }\n\n        // Fallback to checking the common name if SANs did not match or were not present.\n        var commonName = cert.GetNameInfo(X509NameType.SimpleName, false);\n        return IsWildcardMatch(commonName, "v1.api.serviceprovider.com");\n    }\n\n    return false; // No other mismatches should be ignored\n};\n\nbool IsWildcardMatch(string pattern, string host)\n{\n    if (!pattern.StartsWith("*.")) return string.Equals(pattern, host, StringComparison.OrdinalIgnoreCase);\n    \n    var domain = pattern.Substring(2); // Remove the "*." prefix\n    return host.Length > domain.Length + 1 &&\n           host.EndsWith(domain, StringComparison.OrdinalIgnoreCase) &&\n           host[host.Length - domain.Length - 1] == '.';\n}