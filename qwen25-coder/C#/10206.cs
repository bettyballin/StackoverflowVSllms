using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Windows.Forms;\n\nclass Program : Form {\n    private const int WH_MOUSE_LL = 14; // Low-level mouse hook constant\n    private const uint WM_MOUSEWHEEL = 0x020A; // Mouse wheel message\n    private static LowLevelMouseProc _proc = HookCallback;\n    private static IntPtr _hookID = IntPtr.Zero;\n\n    [STAThread]\n    static void Main() {\n        using (Process curProcess = Process.GetCurrentProcess())\n        using (ProcessModule curModule = curProcess.MainModule) {\n            _hookID = SetHook(_proc, WH_MOUSE_LL, curModule.ModuleHandle);\n        }\n        \n        Application.Run();\n    }\n\n    private static IntPtr SetHook(LowLevelMouseProc proc, int hookType, IntPtr hMod) {\n        return SetWindowsHookEx(hookType, proc, hMod, 0);\n    }\n\n    delegate IntPtr LowLevelMouseProc(int nCode, IntPtr wParam, IntPtr lParam);\n\n    private static IntPtr HookCallback(int nCode, IntPtr wParam, IntPtr lParam) {\n        if (nCode >= 0 && wParam == (IntPtr)WM_MOUSEWHEEL) { // Check if it is a mouse wheel event\n            bool winKey = GetAsyncKeyState(0x5B) != 0 || GetAsyncKeyState(0x5C) != 0; // Check if Win key is pressed\n\n            if (winKey) {\n                MSLLHOOKSTRUCT hookStruct = Marshal.PtrToStructure<MSLLHOOKSTRUCT>(lParam);\n                short deltaVerticalScroll = hookStruct.mouseData >> 16;\n\n                if (deltaVerticalScroll > 0) { // Scroll up\n                    SendShortcutKeys(Keys.LWin, Keys.Oemplus); // Simulate Win + +\n                } else { // Scroll down\n                    SendShortcutKeys(Keys.LWin, Keys.OemMinus); // Simulate Win + -\n                }\n            }\n        }\n        return CallNextHookEx(_hookID, nCode, wParam, lParam);\n    }\n\n    private static void SendShortcutKeys(Keys primary, Keys secondary) {\n        keybd_event((byte)primary, 0x45, KEYEVENTF_EXTENDEDKEY | 0, UIntPtr.Zero); // Down\n        keybd_event((byte)secondary, 0x46, 0, UIntPtr.Zero); // Down\n        keybd_event((byte)secondary, 0x46, KEYEVENTF_KEYUP, UIntPtr.Zero); // Up\n        keybd_event((byte)primary, 0x45, KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP, UIntPtr.Zero); // Up\n    }\n\n    private const int KEYEVENTF_EXTENDEDKEY = 0x1;\n    private const int KEYEVENTF_KEYUP = 0x2;\n\n    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n    private static extern IntPtr SetWindowsHookEx(int idHook, LowLevelMouseProc lpfn, IntPtr hMod, uint dwThreadId);\n\n    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    public static extern bool UnhookWindowsHookEx(IntPtr hhk);\n\n    [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n    private static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);\n\n    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]\n    private static extern IntPtr GetModuleHandle(string lpModuleName);\n\n    [DllImport("user32.dll", SetLastError = true)]\n    public static extern short GetAsyncKeyState(int vKey);\n\n    [DllImport("user32.dll")]\n    public static extern void keybd_event(byte bVk, byte bScan, uint dwFlags, UIntPtr dwExtraInfo);\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct POINT {\n    public int x;\n    public int y;\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct MSLLHOOKSTRUCT {\n    public POINT pt;\n    public uint mouseData;\n    public uint flags;\n    public uint time;\n    public UIntPtr dwExtraInfo;\n}