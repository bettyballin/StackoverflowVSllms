using System;\nusing Castle.DynamicProxy;\n\npublic class ParameterLoggerInterceptor : IInterceptor {\n    public void Intercept(IInvocation invocation) {\n        Console.WriteLine("Method: " + invocation.Method.Name);\n        Console.WriteLine("Parameters:");\n        for (int i = 0; i < invocation.Arguments.Length; i++) {\n            Console.WriteLine($"Parameter {i}: {invocation.Arguments[i]}");\n        }\n        \n        invocation.Proceed(); // Call the actual method\n        \n        // Optionally log return value or any other post-invoke logic\n        Console.WriteLine("Return Value: " + invocation.ReturnValue);\n    }\n}\n\npublic class MyClass {\n    public void MyMethod(string param1, int param2) {\n        Console.WriteLine($"MyMethod executed with parameters {param1} and {param2}");\n    }\n}\n\nclass Program {\n    static void Main() {\n        var proxyGenerator = new ProxyGenerator();\n        var loggerInterceptor = new ParameterLoggerInterceptor();\n        \n        MyClass myClassProxy = proxyGenerator.CreateInterfaceProxyWithTarget(new MyClass(), loggerInterceptor);\n        \n        // Call method via proxy\n        myClassProxy.MyMethod("test", 123);\n    }\n}