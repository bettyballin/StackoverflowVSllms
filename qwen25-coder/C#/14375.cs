using System;\nusing System.Xml.Schema;\nusing System.Collections.Generic;\n\npublic class SchemaXPathValidator\n{\n    private XmlSchemaSet schemas = new XmlSchemaSet();\n\n    public void LoadSchema(string xsdFilePath)\n    {\n        schemas.Add("", xsdFilePath);\n    }\n\n    public bool ValidateXPath(string xpathExpression)\n    {\n        XmlSchema schema = schemas.GlobalElements.Values.OfType<XmlSchemaElement>().FirstOrDefault(e => e.Name == GetNextElement(xpathExpression)?.Trim('/'));\n        if (schema == null) return false;\n\n        string remainingXPath = RemoveHead(xpathExpression);\n\n        while (!string.IsNullOrEmpty(remainingXPath))\n        {\n            var nextElement = GetNextElement(remainingXPath);\n            schema = FindChildSchema(schema, nextElement.Trim('/'));\n\n            if (schema == null) return false;\n            remainingXPath = RemoveHead(remainingXPath);\n        }\n\n        return true;\n    }\n\n    private XmlSchema FindChildSchema(XmlSchema schema, string childName)\n    {\n        // Simplified logic. Actual implementation should handle complex types and sequences.\n        if (schema is XmlSchemaElement element && element.ElementSchemaType is XmlSchemaComplexType ctype)\n        {\n            foreach (XmlSchemaElement item in ctype.Particle.Items)\n            {\n                if (item.Name == childName) return item;\n            }\n        }\n        return null;\n    }\n\n    private static string GetNextElement(string xpathExpression)\n    {\n        var headEnd = xpathExpression.IndexOf('/');\n        if (headEnd == -1) return xpathExpression;\n\n        return xpathExpression.Substring(0, headEnd);\n    }\n\n    private static string RemoveHead(string xpathExpression)\n    {\n        var headEnd = xpathExpression.IndexOf('/');\n        if (headEnd == -1) return "";\n\n        return xpathExpression.Length > headEnd + 1 ? xpathExpression.Substring(headEnd + 1) : "";\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        SchemaXPathValidator validator = new SchemaXPathValidator();\n        validator.LoadSchema("your-schema.xsd");\n\n        bool isValid = validator.ValidateXPath("/RootData/FirstChild/FirstGrandChild");\n        Console.WriteLine($"Is the XPath expression potentially valid? {isValid}");\n    }\n}