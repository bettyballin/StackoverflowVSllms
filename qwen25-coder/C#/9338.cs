using System;\nusing System.Collections.Generic;\n\nstruct Interval\n{\n    public DateTime Date;\n    public long Duration; \n    public int State; \n}\n\nstruct StateSummary\n{\n    public int State;\n    public long TotalSeconds; \n}\n\npublic class RandomIntervalGenerator\n{\n    private static Random rng = new Random();\n\n    public Interval[] GetRandomIntervals(DateTime start, DateTime end, StateSummary[] sums, int totalEvents)\n    {\n        // Check if the range is big enough for all intervals\n        var totalDuration = TimeSpan.FromSeconds(sums.Sum(x => x.TotalSeconds));\n        if (end - start < totalDuration)\n            throw new ArgumentException("Time frame too short to accommodate required duration");\n\n        // Sort states by total seconds in descending order to simplify placement logic\n        Array.Sort(sums, (a, b) => b.TotalSeconds.CompareTo(a.TotalSeconds));\n\n        var intervals = new List<Interval>();\n        var currentStateIndex = 0;\n\n        while (totalEvents > 0)\n        {\n            var currentSummary = sums[currentStateIndex];\n            // Generate a random start time within allowed range\n            DateTime eventStart;\n            do\n            {\n                // Random start between existing intervals or at start\n                if (intervals.Count > 0 && rng.NextDouble() < 0.5 &&\n                    end - intervals[intervals.Count - 1].Date.AddSeconds(intervals[intervals.Count - 1].Duration) >= TimeSpan.FromSeconds(currentSummary.TotalSeconds))\n                {\n                    eventStart = intervals[intervals.Count - 1].Date.AddSeconds(intervals[intervals.Count - 1].Duration);\n                }\n                else if (intervals.Count > 0 && rng.NextDouble() < 0.5 &&\n                         intervals[0].Date - start >= TimeSpan.FromSeconds(currentSummary.TotalSeconds))\n                {\n                    eventStart = start;\n                }\n                else\n                {\n                    var minValidTime = intervals.Count > 0 ? intervals[intervals.Count - 1].Date.AddSeconds(intervals[intervals.Count - 1].Duration) : start;\n                    var maxValidTime = end.AddTicks(-1); // To account for any rounding errors\n                    TimeSpan offset = TimeSpan.FromSeconds(rng.NextDouble() * (maxValidTime - minValidTime).TotalSeconds);\n                    eventStart = minValidTime + offset;\n                }\n            } while (!DoesFit(intervals, eventStart));\n\n            // Fit the state-specific remaining duration from currentSummary to this slot as an interval\n            double remainingStateDuration = currentSummary.TotalSeconds - intervals.FindAll(i => i.State == currentSummary.State).Sum(i => i.Duration);\n            long durationInSec = (long)Math.Min(rng.NextDouble() * remainingStateDuration, end.Subtract(eventStart).TotalSeconds);\n\n            // Add interval\n            intervals.Add(new Interval { Date = eventStart, Duration = durationInSec, State = currentSummary.State });\n\n            if (intervals.Sum(i => i.Duration) >= currentSummary.TotalSeconds)\n                currentStateIndex++; // Move to the next state\n\n            totalEvents--;\n        }\n\n        // Sort intervals by date for consistency\n        intervals.Sort((a, b) => a.Date.CompareTo(b.Date));\n        return intervals.ToArray();\n    }\n\n    private static bool DoesFit(List<Interval> existingIntervals, DateTime potentialDate)\n    {\n        foreach (var interval in existingIntervals)\n        {\n            if (potentialDate < interval.Date.AddSeconds(interval.Duration) && // Start is before end\n                potentialDate AddSeconds(1) > interval.Date) // End is after start\n                return false;\n        }\n        return true;\n    }\n}