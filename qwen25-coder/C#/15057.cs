using System;\n   using NAudio.Wave;\n\n   class Program\n   {\n       static void Main(string[] args)\n       {\n           string inputFilePath = "input.mp3";\n           string outputFilePath = "output.mp3";\n           TimeSpan startTime = TimeSpan.FromSeconds(5); // start cut from 5 seconds\n           TimeSpan duration = TimeSpan.FromSeconds(10); // length of the cut (10 seconds from start time)\n           double fadeDurationInSeconds = 2; // duration of fade in/out\n\n           FadeMp3(inputFilePath, outputFilePath, startTime, duration, fadeDurationInSeconds);\n       }\n\n       static void FadeMp3(string inputFilePath, string outputFilePath, TimeSpan startTime, TimeSpan duration, double fadeDurationInSeconds)\n       {\n           using (var reader = new Mp3FileReader(inputFilePath))\n           {\n               // Skip to the start time\n               WaveStream blockAlignedStream = BlockAlignments.WaveFormatTo44k16bit(new StreamRegionSegment(reader, startTime, duration));\n\n               // Create a blank output file\n               using (var writer =  new NAudio.Wave.WaveFileWriter(outputFilePath, blockAlignedStream.WaveFormat))\n               {\n                   var buffer = new byte[blockAlignedStream.WaveFormat.SampleRate * blockAlignedStream.WaveFormat.Channels];\n                   int samplesRead;\n                   long fadeLength = Math.Round(fadeDurationInSeconds * blockAlignedStream.WaveFormat.SampleRate);\n                   int read;\n\n                   // Fade in\n                   long position = 0;\n                   while (position < fadeLength && ((samplesRead = blockAlignedStream.Read(buffer, 0, buffer.Length)) > 0))\n                   {\n                       ApplyFadeIn(blockAlignedStream.WaveFormat.BitsPerSample, buffer, samplesRead, position, fadeLength);\n                       writer.WriteData(buffer, 0, samplesRead);\n                       position += samplesRead / (blockAlignedStream.WaveFormat.Channels * blockAlignedStream.WaveFormat.BlockAlign);\n                   }\n\n                   // Read the middle part without applying fade\n                   while ((samplesRead = blockAlignedStream.Read(buffer, 0, buffer.Length)) > 0)\n                   {\n                       writer.WriteData(buffer, 0, samplesRead);\n                   }\n\n                   // Fade out\n                   position -= samplesRead / (blockAlignedStream.WaveFormat.Channels * blockAlignedStream.WaveFormat.BlockAlign) + 1;\n                   while (position >= fadeLength && ((samplesRead = blockAlignedStream.Read(buffer, 0, buffer.Length)) > 0))\n                   {\n                       ApplyFadeOut(blockAlignedStream.WaveFormat.BitsPerSample, buffer, samplesRead, position - fadeLength, fadeLength);\n                       writer.WriteData(buffer, 0, samplesRead);\n                       position -= samplesRead / (blockAlignedStream.WaveFormat.Channels * blockAlignedStream.WaveFormat.BlockAlign);\n                   }\n               }\n           }\n       }\n\n       static void ApplyFadeIn(int bitsPerSample, byte[] buffer, int samplesRead, long pos, long fadeLength)\n       {\n           double scale;\n           if (bitsPerSample == 16)\n               for (int n = 0; n < samplesRead / 2; n++)\n               {\n                   short s = BitConverter.ToInt16(buffer, n * 2);\n                   scale = Math.Min(1.0f, ((double)pos + n) / fadeLength);\n                   s = (short)(s * scale);\n                   BitConverter.GetBytes(s).CopyTo(buffer, n * 2);\n               }\n       }\n\n       static void ApplyFadeOut(int bitsPerSample, byte[] buffer, int samplesRead, long pos, long fadeLength)\n       {\n           double scale;\n           if (bitsPerSample == 16)\n               for (int n = 0; n < samplesRead / 2; n++)\n               {\n                   short s = BitConverter.ToInt16(buffer, n * 2);\n                   scale = Math.Min(1.0f, 1 - ((double)pos + n) / fadeLength);\n                   s = (short)(s * scale);\n                   BitConverter.GetBytes(s).CopyTo(buffer, n * 2);\n               }\n       }\n   }\n\n   public static class BlockAlignments\n   {\n       /// <summary>\n       /// Converts the specified wave format to one with 48kHz sample rate and 16 bit PCM\n       /// </summary>\n       public static WaveStream WaveFormatTo44k16bit(WaveStream source)\n       {\n           if (source.WaveFormat.Encoding != NAudio.Wave.WaveFormatEncoding.Pcm &&\n               source.WaveFormat.Encoding != NAudio.Wave.WaveFormatEncoding.IeeeFloat)\n           {\n               source = new MediaFoundationResampler(source, WaveFormat.CreateI16(48000, source.WaveFormat.Channels));\n           }\n           else if (source.WaveFormat.BitsPerSample != 16 || source.WaveFormat.SampleRate != 44100)\n           {\n               source = new MediaFoundationResampler(source, WaveFormat.CreateI16(48000, source.WaveFormat.Channels));\n           }\n           return source;\n       }\n   }\n\n   public class StreamRegionSegment :_waveStream\n   {\n       private readonly long _startOffsetBytes;\n       private readonly long _regionLengthBytes;\n\n       private bool disposedValue = false; // To detect redundant calls\n\n       public StreamRegionSegment(WaveStream source, TimeSpan start, TimeSpan duration)\n           : this(source,\n                  (long)source.WaveFormat.SampleRate * start.TotalSeconds * source.WaveFormat.Channels *\n                  (source.WaveFormat.BitsPerSample / 8),\n                  (long)Math.Round(duration.TotalMilliseconds *\n                                      source.WaveFormat.SamplesPerSecond * source.WaveFormat.BlockAlign))\n       {\n       }\n\n       public StreamRegionSegment(WaveStream source, long startOffsetSamples, int sampleCount) // duration in bytes\n           : base(source)\n       {\n           if (_parent.Length < WaveFormat.BlockAlign * (startOffsetSamples + sampleCount))\n               throw new ArgumentOutOfRangeException(nameof(sampleCount));\n\n           this._startOffsetBytes = startOffsetSamples * WaveFormat.BlockAlign;\n           this._regionLengthBytes = sampleCount * WaveFormat.BlockAlign;\n\n           // Skip to the correct position in the parent Stream\n           Position = 0;\n       }\n\n       public override long Length => _regionLengthBytes;\n\n       public override long Position\n       {\n           get => _parent.Position - _startOffsetBytes;\n           set {\n               value += _startOffsetBytes; // convert this region's relative offset to a position in the parent stream\n\n               if (value < _startOffsetBytes)\n                   throw new ArgumentOutOfRangeException(nameof(Position));\n               else if (_regionLengthBytes > 0 && value >= _startOffsetBytes + _regionLengthBytes)\n                   throw new ArgumentOutOfRangeException(nameof(Position));\n\n               _parent.Position = value;\n           }\n       }\n\n       public override int Read(byte[] array, int offset, int count) {\n           count = (int)Math.Min(count, _regionLengthBytes - Position);\n           return _parent.Read(array, offset, count);\n       }\n\n       protected virtual void Dispose(bool disposing) {\n           if (!disposedValue)\n           {\n               if (disposing)\n               {\n                   // TODO: dispose managed state (managed objects).\n                   _parent.Dispose();\n               }\n               disposedValue = true;\n           }\n       }\n\n       public override void Dispose() {\n           Dispose(true);\n       }\n   }