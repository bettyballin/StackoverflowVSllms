using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class AssemblyInfoCollector\n{\n    [DllImport("psapi.dll", SetLastError = true)]\n    private static extern bool EnumProcessModules(IntPtr hProcess, [Out] IntPtr[] lphModule, uint cb, out uint lpcbNeeded);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern uint GetModuleFileNameEx(IntPtr hProcess, IntPtr hModule, [Out] char[] lpBaseName, [In] [MarshalAs(UnmanagedType.U4)] int nSize);\n\n    public void GetLoadedUnmanagedAssemblies()\n    {\n        Console.WriteLine("\nUnmanaged Assemblies Loaded:");\n        var process = Process.GetCurrentProcess();\n        const int MAX_PATH = 260;\n        IntPtr[] modules = new IntPtr[1024];\n        uint cbNeeded;\n\n        if (EnumProcessModules(process.Handle, modules, (uint)(IntPtr.Size * (modules.Length)), out cbNeeded))\n        {\n            int numModules = (int)cbNeeded / IntPtr.Size;\n            for (int i = 0; i < numModules; i++)\n            {\n                char[] moduleName = new char[MAX_PATH];\n                if (GetModuleFileNameEx(process.Handle, modules[i], moduleName, MAX_PATH) > 0)\n                {\n                    var assemblyPath = new string(moduleName);\n                    Console.WriteLine($"Path: {assemblyPath}");\n                }\n            }\n        }\n    }\n}