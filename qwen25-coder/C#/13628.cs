using System;\nusing System.Runtime.InteropServices;\n\npublic class BarClass\n{\n    public int Value { get; set; }\n\n    public BarClass(int value)\n    {\n        Value = value;\n    }\n}\n\nclass Program\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    static extern bool VirtualFree(IntPtr lpAddress, uint dwSize, uint dwFreeType);\n\n    const uint MEM_COMMIT = 0x00001000;\n    const uint MEM_RELEASE = 0x00008000;\n    const uint PAGE_READWRITE = 4;\n\n    static void Main()\n    {\n        // Allocate a block of unmanaged memory\n        IntPtr memPtr = VirtualAlloc(IntPtr.Zero, (uint)Marshal.SizeOf(typeof(BarClass)), MEM_COMMIT, PAGE_READWRITE);\n        \n        if (memPtr == IntPtr.Zero)\n            throw new Exception("Failed to allocate memory");\n\n        try\n        {\n            BarClass barInstance = new BarClass(42);\n\n            // Copy managed object to unmanaged memory\n            Marshal.StructureToPtr(barInstance, memPtr, false);\n\n            // Read the data back into a managed object\n            BarClass readBackBar = (BarClass)Marshal.PtrToStructure(memPtr, typeof(BarClass));\n\n            Console.WriteLine("Value from unmanaged memory: " + readBackBar.Value);\n        }\n        finally\n        {\n            // Free the allocated memory\n            VirtualFree(memPtr, 0, MEM_RELEASE);\n        }\n\n        Console.ReadLine();\n    }\n}