using System;\nusing System.IO;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\npublic class FileUploader\n{\n    private readonly HttpClient _httpClient = new HttpClient();\n\n    public async Task UploadFileWithProgress(string filePath, string url)\n    {\n        var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read);\n        var content = new StreamContent(fileStream);\n\n        // Subscribe to the ProgressChanged event\n        content.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue("application/octet-stream");\n        content.RegisterForUploadProgress(p =>\n        {\n            Console.WriteLine($"Uploaded {p.BytesRead} of {p.TotalBytes} bytes. ({(int)(p.BytesRead * 100 / p.TotalBytes)}%)");\n            // Update your progress bar here\n        });\n\n        try\n        {\n            var response = await _httpClient.PostAsync(url, content);\n\n            if (response.IsSuccessStatusCode)\n            {\n                Console.WriteLine("Upload successful.");\n            }\n            else\n            {\n                Console.WriteLine($"Upload failed. Status code: {response.StatusCode}");\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Error during upload: {ex.Message}");\n        }\n        finally\n        {\n            content.Dispose();\n            fileStream.Close();\n        }\n    }\n\n    public static async Task Main(string[] args)\n    {\n        var uploader = new FileUploader();\n        await uploader.UploadFileWithProgress("path/to/your/file", "https://example.com/upload");\n    }\n}\n\n// Extension class for registering progress\npublic static class HttpContentExtensions\n{\n    public static void RegisterForUploadProgress(this StreamContent content, Action<HttpProgress> action)\n    {\n        var trackingContent = new ProgressableStreamContent(content, 8192);\n        trackingContent.OnProgress += (progress) => { action(progress); };\n        foreach (var h in content.Headers)\n        {\n            trackingContent.Headers.TryAddWithoutValidation(h.Key, h.Value);\n        }\n        content.Dispose();\n    }\n}\n\npublic class HttpProgress\n{\n    public long BytesRead { get; set; }\n    public long? TotalBytes { get; set; }\n}\n\npublic class ProgressableStreamContent : HttpContent\n{\n    private readonly HttpContent _content;\n    private const int DefaultBufferSize = 8192;\n\n    public ProgressableStreamContent(HttpContent content, int bufferSize = DefaultBufferSize)\n    {\n        if (bufferSize < 1)\n            throw new ArgumentOutOfRangeException(nameof(bufferSize), "Buffer size must be greater than zero.");\n\n        _content = content ?? throw new ArgumentNullException(nameof(content));\n\n        Headers.ContentType = _content.Headers.ContentType;\n        Headers.ContentLength = _content.Headers.ContentLength;\n\n        // Set up the event\n        ContentReadStream = new ProgressStream(_content.ReadAsStreamAsync().Result, bufferSize);\n        var progressStream = (ProgressStream)ContentReadStream;\n        progressStream.OnReportProgress += ReportProgress;\n    }\n\n    public Stream ContentReadStream { get; private set; }\n\n    protected override Task SerializeToStreamAsync(Stream stream, TransportContext context)\n    {\n        return ((ProgressStream)ContentReadStream).CopyToAsync(stream);\n    }\n\n    protected override bool TryComputeLength(out long length)\n    {\n        length = _content.Headers.ContentLength ?? 0;\n        return true;\n    }\n\n    private event Action<HttpProgress> OnProgress;\n\n    public void ReportProgress(long bytesRead, long? totalBytes)\n    {\n        var progress = new HttpProgress()\n        {\n            BytesRead = bytesRead,\n            TotalBytes = totalBytes\n        };\n        InvokeProgress(progress);\n    }\n\n    protected virtual void InvokeProgress(HttpProgress progress) => OnProgress?.Invoke(progress);\n\n    private class ProgressStream : Stream\n    {\n        private readonly Stream _innerStream;\n        private readonly int _bufferSize;\n\n        public ProgressStream(Stream innerStream, int bufferSize)\n        {\n            _innerStream = innerStream ?? throw new ArgumentNullException(nameof(innerStream));\n            _bufferSize = bufferSize > 0 ? bufferSize : DefaultBufferSize;\n            OnReportProgress += ReportProgress;\n        }\n\n        public event Action<long, long?> OnReportProgress;\n\n        private void ReportProgress(long bytesRead) => OnReportProgress?.Invoke(bytesRead, Length);\n\n        public override bool CanRead => true;\n        public override bool CanSeek => false;\n        public override bool CanWrite => false;\n        public override long Length => _innerStream.Length;\n\n        private long _position = 0;\n\n        public override long Position\n        {\n            get { return _position; }\n            set { throw new NotSupportedException(); }\n        }\n\n        public override void Flush() => throw new NotSupportedException();\n\n        public override int Read(byte[] buffer, int offset, int count)\n        {\n            var bytesRead = _innerStream.Read(buffer, offset, count);\n            _position += bytesRead;\n            ReportProgress(_position);\n            return bytesRead;\n        }\n\n        public override Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) =>\n            _innerStream.ReadAsync(buffer, offset, count, cancellationToken).ContinueWith(t =>\n            {\n                _position += t.Result;\n                ReportProgress(_position);\n                return t.Result;\n            }, TaskContinuationOptions.OnlyOnRanToCompletion);\n\n        public override int ReadByte()\n        {\n            var byteRead = _innerStream.ReadByte();\n            if (byteRead != -1)\n            {\n                ++_position;\n                ReportProgress(_position);\n            }\n            return byteRead;\n        }\n\n        public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException();\n\n        public override void SetLength(long value) => throw new NotSupportedException();\n\n        public override void Write(byte[] buffer, int offset, int count) => throw new NotSupportedException();\n    }\n}