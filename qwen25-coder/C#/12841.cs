using System.Collections.Immutable;\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class MethodNamingAnalyzer : DiagnosticAnalyzer\n{\n    public const string DiagnosticId = "MethodNameCheck";\n\n    private static readonly LocalizableString Title = "Methods should be PascalCase";\n    private static readonly LocalizableString MessageFormat = "Method '{0}' is not PascalCased.";\n    private static readonly LocalizableString Description = "Ensure naming conventions are followed for methods.";\n\n    private const string Category = "Naming";\n\n    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);\n\n    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);\n\n    public override void Initialize(AnalysisContext context)\n    {\n        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n        context.EnableConcurrentExecution();\n        \n        context.RegisterSyntaxNodeAction(AnalyzeNode, SyntaxKind.MethodDeclaration);\n    }\n\n    private static void AnalyzeNode(SyntaxNodeAnalysisContext context)\n    {\n        var methodDecl = (MethodDeclarationSyntax)context.Node;\n        if (!string.IsNullOrEmpty(methodDecl.Identifier.Text) && !char.IsUpper(methodDecl.Identifier.Text[0]))\n        {\n            var diag = Diagnostic.Create(Rule, methodDecl.GetLocation(), methodDecl.Identifier.Text);\n            context.ReportDiagnostic(diag);\n        }\n    }\n}