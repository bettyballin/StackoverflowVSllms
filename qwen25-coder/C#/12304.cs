using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);\n\n    const uint PROCESS_QUERY_INFORMATION = 0x0400;\n    const uint PROCESS_VM_READ = 0x0010;\n\n    public static Process GetProcessFromHandle(IntPtr handle)\n    {\n        int processId = 0;\n        IntPtr ptrToName = IntPtr.Zero;\n\n        try\n        {\n            // Query the process ID from the handle\n            if (!QueryFullProcessImageName(handle, 0, null, out uint size))\n                throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n\n            ptrToName = Marshal.AllocHGlobal((int)size);\n            try\n            {\n                if (!QueryFullProcessImageName(handle, 0, ptrToName, out size))\n                    throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n\n                string processName = Marshal.PtrToStringUni(ptrToName);\n\n                foreach (Process process in Process.GetProcesses())\n                {\n                    using (process)\n                    {\n                        if (process.Handle == handle)\n                            return process;\n                    }\n                }\n\n                // If the direct match doesn't work, try to find by name and check handles\n                string fileName = Path.GetFileName(processName);\n                return GetProcessByNameAndHandle(fileName, handle);\n            }\n            finally\n            {\n                Marshal.FreeHGlobal(ptrToName);\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Failed to get process from handle: {ex.Message}");\n            return null;\n        }\n    }\n\n    [DllImport("psapi.dll", SetLastError = true)]\n    private static extern bool QueryFullProcessImageName(\n        IntPtr hProcess,\n        uint dwFlags,\n        [Out] StringBuilder lpExeName,\n        ref uint lpdwSize);\n\n    [DllImport("psapi.dll", SetLastError = true)]\n    private static extern bool QueryFullProcessImageName(\n        IntPtr hProcess,\n        uint dwFlags,\n        [Out, MarshalAs(UnmanagedType.LPTStr)] string lpExeName,\n        ref uint lpdwSize);\n\n    private static Process GetProcessByNameAndHandle(string processName, IntPtr handle)\n    {\n        foreach (Process process in Process.GetProcessesByName(processName))\n        {\n            using (process)\n            {\n                if (process.Handle == handle)\n                    return process;\n            }\n        }\n\n        throw new InvalidOperationException("No matching process found.");\n    }\n\n    static void Main()\n    {\n        // Example usage: Assuming you have a valid process handle\n        IntPtr processHandle = ...; // Replace with your actual process handle\n\n        Process proc = GetProcessFromHandle(processHandle);\n        if (proc != null)\n            Console.WriteLine($"Found process: {proc.ProcessName}");\n        else\n            Console.WriteLine("Process not found.");\n    }\n}