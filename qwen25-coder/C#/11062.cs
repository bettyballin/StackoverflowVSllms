public static bool IsChanged<T>(T current, T previous)\n{\n    return CheckChanged(current, previous);\n}\n\nprivate static bool CheckChanged<T>(T current, T previous)\n{\n    // Base case: if both are null, they are equal.\n    if (current == null && previous == null) return false;\n    \n    // If one is null and the other is not, they are different.\n    if (current == null || previous == null) return true;\n    \n    // Assuming T is a class with properties that need to be checked.\n    // Replace with specific property checks or reflection as needed.\n    var currentProperties = typeof(T).GetProperties();\n    foreach (var prop in currentProperties)\n    {\n        var currentValue = prop.GetValue(current, null);\n        var previousValue = prop.GetValue(previous, null);\n\n        if (currentValue == null && previousValue == null) continue;\n        \n        // If one value is null and the other is not, they are different.\n        if (currentValue == null || previousValue == null) return true;\n\n        // Recursively check nested objects.\n        if (typeof(T).IsClass && !typeof(IEnumerable).IsAssignableFrom(prop.PropertyType))\n        {\n            if (CheckChanged(currentValue, previousValue)) return true;\n        }\n        else\n        {\n            // Compare properties directly.\n            if (!currentValue.Equals(previousValue)) return true;\n        }\n    }\n\n    return false; // No differences found.\n}