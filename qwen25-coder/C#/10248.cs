using System;\nusing System.Collections.Generic;\n\npublic class MinHeap<T> where T : IComparable<T>\n{\n    private List<T> _items = new List<T>();\n\n    public int Count => _items.Count;\n\n    public void Insert(T item)\n    {\n        _items.Add(item);\n        SiftUp(_items.Count - 1);\n    }\n\n    public T ExtractMin()\n    {\n        if (_items.Count == 0) throw new InvalidOperationException("The heap is empty.");\n        T root = _items[0];\n        int lastIndex = _items.Count - 1;\n        _items[0] = _items[lastIndex];\n        _items.RemoveAt(lastIndex);\n\n        if (_items.Count > 0)\n        {\n            SiftDown(0);\n        }\n\n        return root;\n    }\n\n    private void SiftUp(int index)\n    {\n        while (index > 0 && Compare(index, Parent(index)) < 0)\n        {\n            Swap(index, Parent(index));\n            index = Parent(index);\n        }\n    }\n\n    private void SiftDown(int index)\n    {\n        int rightIndex = RightChild(index), leftIndex = LeftChild(index);\n        if ((leftIndex < _items.Count && Compare(index, leftIndex) > 0) ||\n            (rightIndex < _items.Count && Compare(index, rightIndex) > 0))\n        {\n            int smallChildIndex = (rightIndex >= _items.Count || Compare(leftIndex, rightIndex) <= 0)\n                ? leftIndex : rightIndex;\n            Swap(smallChildIndex, index);\n            SiftDown(smallChildIndex);\n        }\n    }\n\n    private void Swap(int i, int j)\n    {\n        T temp = _items[i];\n        _items[i] = _items[j];\n        _items[j] = temp;\n    }\n\n    private int Compare(int childIndex, int parentIndex) => _items[childIndex].CompareTo(_items[parentIndex]);\n\n    private int Parent(int index) => (index - 1) / 2;\n\n    private int LeftChild(int index) => index * 2 + 1;\n\n    private int RightChild(int index) => index * 2 + 2;\n}