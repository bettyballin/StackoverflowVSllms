using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class ProcessUtils\n{\n    [Flags]\n    public enum SnapshotFlags : uint\n    {\n        HeapList = 0x00000001,\n        Process = 0x00000002,\n        Thread = 0x00000004,\n        Module = 0x00000008,\n        Module32 = 0x00000010,\n        Inherit = 0x80000000,\n        All = 0x0000001F\n    }\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    public static extern IntPtr CreateToolhelp32Snapshot(SnapshotFlags dwFlags, uint th32ProcessID);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    public static extern bool Process32First(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    public static extern bool Process32Next(IntPtr hSnapshot, ref PROCESSENTRY32 lppe);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    public static extern bool CloseHandle(IntPtr hObject);\n\n    public static void TerminateChildProcesses(int parentProcessId)\n    {\n        List<int> processesToTerminate = new List<int>();\n        IntPtr hSnapshot = CreateToolhelp32Snapshot(SnapshotFlags.Process, 0);\n        if (hSnapshot == IntPtr.Zero) return;\n\n        try\n        {\n            PROCESSENTRY32 procInfo;\n            procInfo.dwSize = Marshal.SizeOf(typeof(PROCESSENTRY32));\n            if (!Process32First(hSnapshot, ref procInfo)) { return; }\n\n            do\n            {\n                if (procInfo.th32ParentProcessID == parentProcessId)\n                {\n                    processesToTerminate.Add(procInfo.th32ProcessID);\n                    // Recursively find and add child processes of the current process.\n                    TerminateChildProcesses(procInfo.th32ProcessID, ref processesToTerminate);\n                }\n            } while (Process32Next(hSnapshot, ref procInfo));\n        }\n        finally\n        {\n            CloseHandle(hSnapshot);\n        }\n\n        foreach (var processId in processesToTerminate)\n        {\n            try\n            {\n                Process.GetProcessById(processId).Kill();\n            }\n            catch (ArgumentException) // The process does not exist.\n            { }\n            catch (InvalidOperationException) // The process has already exited.\n            { }\n            catch (Exception ex) // Handle other exceptions if any.\n            {\n                Console.WriteLine($"Error terminating process {processId}: {ex.Message}");\n            }\n        }\n    }\n\n    private static void TerminateChildProcesses(int parentProcessId, ref List<int> processesToTerminate)\n    {\n        IntPtr hSnapshot = CreateToolhelp32Snapshot(SnapshotFlags.Process, 0);\n        if (hSnapshot == IntPtr.Zero) return;\n\n        try\n        {\n            PROCESSENTRY32 procInfo;\n            procInfo.dwSize = Marshal.SizeOf(typeof(PROCESSENTRY32));\n            if (!Process32First(hSnapshot, ref procInfo)) { return; }\n\n            do\n            {\n                if (procInfo.th32ParentProcessID == parentProcessId)\n                {\n                    processesToTerminate.Add(procInfo.th32ProcessID);\n                    TerminateChildProcesses(procInfo.th32ProcessID, ref processesToTerminate);\n                }\n            } while (Process32Next(hSnapshot, ref procInfo));\n        }\n        finally\n        {\n            CloseHandle(hSnapshot);\n        }\n    }\n}\n\n[StructLayout(LayoutKind.Sequential)]\npublic struct PROCESSENTRY32\n{\n    public uint dwSize;\n    public uint cntUsage;\n    public uint th32ProcessID;\n    public IntPtr th32DefaultHeapID;\n    public uint moduleID;\n    public uint cntThreads;\n    public uint th32ParentProcessID;\n    public int pcPriClassBase;\n    public uint(dwFlags;\n\n    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]\n    public string szExeFile;\n}