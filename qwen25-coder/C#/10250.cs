using System;\nusing System.Collections.Generic;\n\npublic class FibonacciHeap<T> where T : IComparable<T>\n{\n    private class Node\n    {\n        public Node Prev { get; set; }\n        public Node Next { get; set; }\n        public Node Child { get; set; }\n        public Node Parent { get; set; }\n\n        public int Degree { get; set; }\n        public bool Mark { get; set; } = false;\n        public T Key { get; set; }\n    }\n\n    private Node MinNode;\n    private int Count;\n\n    public void Insert(T key)\n    {\n        var newNode = new Node { Key = key };\n        MinNode = MergeLists(MinNode, newNode);\n        Count++;\n    }\n\n    public T ExtractMin()\n    {\n        if (MinNode == null) throw new InvalidOperationException("Heap is empty");\n\n        var z = MinNode;\n\n        if (z != null)\n        {\n            var childrenList = RemoveNodeFromCycle(z);\n\n            foreach (var child in childrenList)\n            {\n                child.Parent = null;\n            }\n\n            MinNode = MergeLists(MinNode, childrenList);\n\n            if (MinNode == null) return z.Key;\n\n            Consolidate();\n\n            Count--;\n        }\n        return z.Key;\n    }\n\n    // Simplified\n    private Node RemoveNodeFromCycle(Node x)\n    {\n        var nodes = new List<Node>();\n        for (var n = x.Next; n != x; n = n.Next)\n        {\n            nodes.Add(n);\n        }\n        nodes.Add(x);\n\n        if (x.Prev == x && x.Next == x) return nodes;\n\n        x.Prev.Next = x.Next;\n        x.Next.Prev = x.Prev;\n\n        return nodes;\n    }\n\n    private Node MergeLists(Node a, IEnumerable<Node> b)\n    {\n        if (a == null && b == null) return null;\n        var aHead = a;\n        foreach (var node in b)\n        {\n            var tempNextA = a.Next;\n            node.Prev = a;\n            node.Next = tempNextA;\n            tempNextA.Prev = node;\n            a.Next = node;\n            if (node.Key.CompareTo(a.Key) < 0)\n            {\n                aHead = node;\n            }\n        }\n\n        return aHead;\n    }\n\n    private void Consolidate()\n    {\n        var arraySize = Convert.ToInt32(Math.Ceiling(Math.Log(Count, Math.Sqrt(2))));\n        Node[] degreeTable = new Node[arraySize];\n\n        for (var w = RemoveNodeFromCycle(MinNode); w.Count > 0;)\n        {\n            var x = w[0];\n            w.RemoveAt(0);\n\n            int d = x.Degree;\n            while (degreeTable[d] != null)\n            {\n                Node y = degreeTable[d];\n\n                if (x.Key.CompareTo(y.Key) > 0)\n                {\n                    var temp = x;\n                    x = y;\n                    y = temp;\n                }\n\n                LinkTrees(y, x);\n\n                degreeTable[d++] = null;\n            }\n            degreeTable[d] = x;\n        }\n\n        MinNode = null;\n\n        foreach (var root in degreeTable)\n        {\n            if (root == null) continue;\n            if (MinNode == null)\n            {\n                InsertCycle(root);\n                MinNode = root;\n            }\n            else\n            {\n                InsertCycle(root);\n                if (root.Key.CompareTo(MinNode.Key) < 0)\n                    MinNode = root;\n            }\n        }\n    }\n\n    private void LinkTrees(Node y, Node x)\n    {\n        RemoveNodeFromCycle(y);\n\n        if (x.Child == null)\n        {\n            InitializeCycle(y);\n            y.Parent = x;\n            x.Degree++;\n        }\n        else\n        {\n            InsertCycle(y, x.Child);\n            y.Parent = x;\n            x.Degree++;\n        }\n\n        y.Mark = false;\n    }\n\n    private void InitializeCycle(Node node) => node.Prev = node.Next = node;\n\n    private void InsertCycle(Node node) => InsertCycle(node, MinNode);\n\n    private void InsertCycle(Node toInsert, Node cycle)\n    {\n        if (cycle == null)\n        {\n            InitializeCycle(toInsert);\n            return;\n        }\n\n        var last = cycle.Prev;\n\n        last.Next = toInsert;\n        toInsert.Prev = last;\n        cycle.Prev = toInsert;\n        toInsert.Next = cycle;\n    }\n}