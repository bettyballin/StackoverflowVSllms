using System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nclass Program\n{\n    // Import necessary functions and constants\n    [DllImport("Kernel32")]\n    public static extern bool SetConsoleCtrlHandler(ConsoleEventDelegate callback, bool add);\n\n    private delegate bool ConsoleEventDelegate(CtrlTypes ctrlType);\n\n    enum CtrlTypes\n    {\n        CTRL_C_EVENT = 0,\n        CTRL_BREAK_EVENT = 1,\n        CTRL_CLOSE_EVENT = 2,\n        CTRL_LOGOFF_EVENT = 5,\n        CTRL_SHUTDOWN_EVENT = 6\n    }\n\n    static void Main(string[] args)\n    {\n        // Set the handler function\n        SetConsoleCtrlHandler(ConsoleEventHandler, true);\n\n        while (true)\n        {\n            string x = Console.ReadLine();\n            StartLongRunningTaskOnSeparateThread(x);\n        }\n    }\n\n    private static bool ConsoleEventHandler(CtrlTypes ctrlType)\n    {\n        switch (ctrlType)\n        {\n            case CtrlTypes.CTRL_CLOSE_EVENT:\n                // Prompt the user before closing\n                Console.WriteLine("Are you sure you want to close this application? Press Y to close, or any other key to keep running.");\n                var response = Console.ReadKey();\n                if (response.Key == ConsoleKey.Y)\n                {\n                    Environment.Exit(0);\n                }\n                else\n                {\n                    return true; // Return true to prevent the application from closing\n                }\n                break;\n        }\n        return false;\n    }\n\n    private static void StartLongRunningTaskOnSeparateThread(string input)\n    {\n        Thread thread = new Thread(() =>\n        {\n            Console.WriteLine($"Starting long-running task for {input}...");\n            Thread.Sleep(5000); // Simulate long running task\n            Console.WriteLine("Completed long-running task.");\n        });\n        thread.Start();\n    }\n}