using System;\nusing System.Management;\n\nclass Program\n{\n    static void Main()\n    {\n        var host = "your_remote_host";\n        var domainUserName = "your_username";\n        var password = "your_password";\n        var commandLine = "notepad.exe";\n\n        ConnectionOptions connOptions = new ConnectionOptions();\n        connOptions.Impersonation = ImpersonationLevel.Impersonate;\n        connOptions.EnablePrivileges = true;\n        connOptions.Username = domainUserName;\n        connOptions.Password = password;\n\n        ManagementScope manScope = new ManagementScope(String.Format(@"\\{0}\ROOT\CIMV2", host), connOptions);\n        manScope.Connect();\n\n        ObjectGetOptions objectGetOptions = new ObjectGetOptions();\n        ManagementPath managementPath = new ManagementPath("Win32_Process");\n        ManagementClass processClass = new ManagementClass(manScope, managementPath, objectGetOptions);\n\n        ManagementBaseObject inParams = processClass.GetMethodParameters("Create");\n        inParams["CommandLine"] = commandLine;\n\n        ManagementBaseObject outParams = processClass.InvokeMethod("Create", inParams, null);\n        int processId = (int)outParams["processId"];\n        \n        bool isRunning = true;\n        while (isRunning)\n        {\n            string query = "SELECT * FROM Win32_Process WHERE ProcessId = " + processId;\n            using (ManagementObjectSearcher searcher = new ManagementObjectSearcher(manScope, new ObjectQuery(query), objectGetOptions))\n            {\n                isRunning = searcher.Get().Count > 0;\n            }\n            if (isRunning)\n            {\n                System.Threading.Thread.Sleep(1000); // Wait for a second before checking again\n            }\n        }\n\n        Console.WriteLine("Process has exited.");\n    }\n}