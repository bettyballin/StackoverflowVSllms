using System;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    // Import LoadLibrary and GetProcAddress functions\n    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]\n    static extern IntPtr LoadLibrary(string lpFileName);\n\n    [DllImport("kernel32.dll", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]\n    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n\n    // Define a delegate for the function you want to call\n    private delegate void MyFunctionDelegate();\n\n    static void Main(string[] args)\n    {\n        // Path to your DLL\n        string dllPath = @"C:\path\to\your\dll.dll";\n        \n        // Load the DLL\n        IntPtr hModule = LoadLibrary(dllPath);\n        if (hModule != IntPtr.Zero)\n        {\n            Console.WriteLine("DLL loaded successfully.");\n\n            // Get the address of the function from the DLL\n            IntPtr procAddress = GetProcAddress(hModule, "MyFunctionName");\n            if (procAddress != IntPtr.Zero)\n            {\n                // Marshal it to a delegate that can be called\n                MyFunctionDelegate myFunction =\n                    (MyFunctionDelegate)Marshal.GetDelegateForFunctionPointer(procAddress, typeof(MyFunctionDelegate));\n\n                // Call the function\n                myFunction();\n            }\n            else\n            {\n                Console.WriteLine("Function not found in DLL.");\n            }\n\n            // Free the library if no longer needed\n            // UnloadLibrary(hModule); - Typically use this for cleanup but no specific method\n        }\n        else\n        {\n            Console.WriteLine("Failed to load DLL.");\n        }\n    }\n}