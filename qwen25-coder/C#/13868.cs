using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\npublic class SingleInstanceChecker : IDisposable\n{\n    private static Mutex mutex;\n    private IntPtr mainWindowHandle;\n\n    public bool IsAnotherInstanceRunning => !mutex.WaitOne(0, false);\n\n    [DllImport("user32.dll")]\n    private static extern bool ShowWindowAsync(IntPtr hWnd, int nCmdShow);\n    \n    [DllImport("user32.dll")]\n    private static extern bool SetForegroundWindow(IntPtr hWnd);\n\n    private const int SW_RESTORE = 9;\n\n    public SingleInstanceChecker(string mutexName, IntPtr mainWindowHandle)\n    {\n        this.mainWindowHandle = mainWindowHandle;\n        mutex = new Mutex(true, mutexName);\n    }\n\n    public void BringToFront()\n    {\n        ShowWindowAsync(mainWindowHandle, SW_RESTORE);\n        SetForegroundWindow(mainWindowHandle);\n    }\n\n    public void Dispose()\n    {\n        if (mutex != null)\n        {\n            mutex.ReleaseMutex();\n            mutex.Dispose();\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string mutexName = "YourUniqueAppName";\n        SingleInstanceChecker singleInstanceChecker = new SingleInstanceChecker(mutexName, Process.GetCurrentProcess().MainWindowHandle);\n\n        if (singleInstanceChecker.IsAnotherInstanceRunning)\n        {\n            Console.WriteLine("An instance is already running.");\n            singleInstanceChecker.BringToFront();\n            Environment.Exit(0);\n        }\n        else\n        {\n            // Continue with your application logic...\n        }\n    }\n}