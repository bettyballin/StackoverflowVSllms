using System;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Threading.Tasks;\n\npublic class ImageProcessor\n{\n    private Process _process;\n    private TaskCompletionSource<bool> _tcs = new TaskCompletionSource<bool>();\n\n    public async Task<byte[]> RunExternalProcessAsync(string fileName, string arguments)\n    {\n        _process = new Process();\n        _process.StartInfo.FileName = fileName;\n        _process.StartInfo.Arguments = arguments;\n        _process.StartInfo.UseShellExecute = false;\n        _process.StartInfo.RedirectStandardOutput = true;\n        _process.EnableRaisingEvents = true;\n\n        // Handle Exited event\n        _process.Exited += (sender, args) =>\n        {\n            try\n            {\n                if (_process.ExitCode != 0)\n                {\n                    throw new InvalidOperationException($"Process exited with code {_process.ExitCode}");\n                }\n            }\n            catch (Exception ex)\n            {\n                _tcs.TrySetException(ex);\n            }\n            finally\n            {\n                _tcs.TrySetResult(true);\n            }\n        };\n\n        // Start the process\n        _process.Start();\n\n        byte[] imageData = null;\n\n        // Read standard output asynchronously\n        try\n        {\n            imageData = await Task.Run(() => ReadStandardOutput());\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Error reading output: {ex.Message}");\n        }\n\n        // Wait for the process to exit and check if there was an exception\n        try\n        {\n            await _tcs.Task; // This will throw if any exception occurred in Exited handler.\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Process error: {ex.Message}");\n            // Handle the exception, rethrow or log it as needed.\n        }\n\n        return imageData;\n    }\n\n    private byte[] ReadStandardOutput()\n    {\n        using (var memStream = new MemoryStream())\n        {\n            _process.StandardOutput.BaseStream.CopyTo(memStream);\n            return memStream.ToArray();\n        }\n    }\n}