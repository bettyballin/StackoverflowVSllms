public partial class MainWindow : Window\n{\n    private WriteableBitmap _bitmap;\n    private List<Particle> _particles = new List<Particle>();\n    private Random _random = new Random();\n\n    public MainWindow()\n    {\n        InitializeComponent();\n\n        int width = (int)ParticleSystemImage.ActualWidth;\n        int height = (int)ParticleSystemImage.ActualHeight;\n\n        // Initialize the WriteableBitmap\n        _bitmap = new WriteableBitmap(width, height, 96, 96, PixelFormats.Bgr32, null);\n        ParticleSystemImage.Source = _bitmap;\n\n        // Generate particles\n        for (int i = 0; i < 10; i++)\n            SpawnParticle();\n\n        CompositionTarget.Rendering += OnCompositionTargetRendering;\n    }\n\n    private void OnCompositionTargetRendering(object sender, EventArgs e)\n    {\n        UpdateParticles();\n        RenderBitmap();\n    }\n\n    private void UpdateParticles()\n    {\n        // Remove particles that are out of view\n        _particles.RemoveAll(p => p.Position.Y < 0);\n\n        // Update live particle positions\n        foreach (var particle in _particles)\n            particle.Update();\n\n        // Add new particles\n        if (_particles.Count < 25)\n            SpawnParticle();\n    }\n\n    private void RenderBitmap()\n    {\n        int stride = _bitmap.PixelWidth * 4;\n        byte[] pixels = new byte[_bitmap.PixelHeight * stride];\n\n        foreach (var particle in _particles)\n            DrawCircle(pixels, particle);\n\n        _bitmap.WritePixels(new Int32Rect(0, 0, _bitmap.PixelWidth, _bitmap.PixelHeight), pixels, stride, 0);\n    }\n\n    private void DrawCircle(byte[] pixels, Particle p)\n    {\n        int x = (int)p.Position.X;\n        int y = (int)p.Position.Y;\n        int radius = (int)p.Size;\n\n        for (int iy = -radius; iy < radius; iy++)\n            for (int ix = -radius; ix < radius; ix++)\n            {\n                double dx = ix * 1.0 / radius;\n                double dy = iy * 1.0 / radius;\n                if (dx * dx + dy * dy <= 1)\n                {\n                    int pixelIndex = (iy + y) * _bitmap.PixelWidth + (ix + x);\n                    pixels[pixelIndex * 4] = 255;    // Blue\n                    pixels[pixelIndex * 4 + 1] = 255; // Green\n                    pixels[pixelIndex * 4 + 2] = 255; // Red\n                    pixels[pixelIndex * 4 + 3] = (byte)(p.Brush.Opacity * 255); // Alpha\n                }\n            }\n    }\n\n    private void SpawnParticle()\n    {\n        var p = new Particle(_random.NextDouble() * _bitmap.PixelWidth, _bitmap.PixelHeight, 0,\n                             RandomWithVariance(75, 50),\n                             RandomWithVariance(20, 15));\n        p.Brush.Opacity = (float)RandomWithVariance(0.5, 0.5);\n        _particles.Add(p);\n    }\n\n    private double RandomWithVariance(double midvalue, double variance)\n    {\n        double min = Math.Max(midvalue - (variance / 2), 0);\n        double max = midvalue + (variance / 2);\n        return min + ((max - min) * _random.NextDouble());\n    }\n}\n\npublic class Particle\n{\n    public Color FillColor { get; set; }\n    public Point3D Position { get; private set; }\n    public Point3D Velocity { get; private set; }\n    public double Size { get; set; }\n    public Brush Brush { get; set; }\n\n    public Particle(double x, double y, double z, double size, double speed)\n    {\n        Size = size;\n        Position = new Point3D(x, y, z);\n        Velocity = new Point3D(\n            (1.0 - (_random.NextDouble() * 2.0)) * speed,\n            -Math.Abs((1.0 - (_random.NextDouble() * 2.0)) * speed),\n            0);\n\n        Brush = Brushes.White;\n    }\n\n    public void Update()\n    {\n        Position.X += Velocity.X;\n        Position.Y += Velocity.Y;\n        Position.Z += Velocity.Z;\n    }\n}