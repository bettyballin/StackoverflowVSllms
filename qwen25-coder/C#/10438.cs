using System;\nusing System.ComponentModel;\n\npublic static class EnumExtensions\n{\n    public static bool IsFlagsDefined<T>(T value) where T : struct, IComparable, IFormattable, IConvertible\n    {\n        var underlyingValue = Convert.ToInt64(value);\n        long definedValues = 0L;\n\n        foreach (var item in (T[])Enum.GetValues(typeof(T)))\n            if (!item.Equals(default(T)) && Convert.ToInt64(item) > 0)\n                definedValues |= Convert.ToInt64(item);\n\n        return (underlyingValue & (~definedValues)) == 0;\n    }\n}\n\npublic class NotifyingEnum<T> : INotifyPropertyChanged\n    where T : struct, IComparable, IFormattable, IConvertible\n{\n    private T value;\n\n    public event PropertyChangedEventHandler PropertyChanged;\n\n    public NotifyingEnum()\n    {\n        if (!typeof(T).IsEnum)\n            throw new ArgumentException("Type T must be an Enum");\n    }\n\n    public T Value\n    {\n        get { return value; }\n        set\n        {\n            if (!EnumExtensions.IsFlagsDefined(value))\n                throw new ArgumentOutOfRangeException(nameof(value), value, $"Value not defined in enum, {typeof(T).Name}");\n\n            if (!this.value.Equals(value))\n            {\n                this.value = value;\n\n                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Value)));\n            }\n        }\n    }\n}