using System;\nusing System.Diagnostics;\nusing System.IO;\n\nprivate void Execute(string sPath)\n{\n    using (var proc = new Process())\n    {\n        try\n        {\n            proc.StartInfo.WorkingDirectory = ConfigurationManager.AppSettings["WORKINGDIRECTORY"].ToString();\n            proc.StartInfo.RedirectStandardOutput = true;\n            proc.StartInfo.RedirectStandardError = true;\n            proc.StartInfo.UseShellExecute = false;\n            proc.StartInfo.FileName = sPath;\n\n            // No need to specify UserName and Password if AppPool identity is correctly set up\n            // proc.StartInfo.UserName = "administrador"; \n            // SetPassword method is not used for security reasons, prefer configuration adjustments.\n\n            proc.Start();\n            string output = proc.StandardOutput.ReadToEnd();\n            string error = proc.StandardError.ReadToEnd();\n            proc.WaitForExit();\n\n            if (proc.ExitCode != 0)\n            {\n                LogError("Execution failed with exit code: " + proc.ExitCode + ", Error Output: " + error);\n            }\n            else\n            {\n                // Handle successful output\n                LogOutput(output);  // Implement logging method appropriately\n            }\n        }\n        catch (Exception ex)\n        {\n            LogError("An exception occurred: " + ex.Message);\n        }\n    }\n}\n\nprivate void LogError(string message)\n{\n    // Implement logging method to write error messages securely\n    File.AppendAllText(Server.MapPath("~/Logs/Errors.log"), DateTime.Now.ToString() + ": ERROR - " + message+ Environment.NewLine);\n}\n\nprivate void LogOutput(string message)\n{\n    // Implement logging method to write output messages\n    File.AppendAllText(Server.MapPath("~/Logs/Outputs.log"), DateTime.Now.ToString() + ": OUTPUT - " + message + Environment.NewLine);\n}