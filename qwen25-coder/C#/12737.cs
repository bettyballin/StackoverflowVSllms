// Main Entry Point\nusing System;\n\nnamespace ConsoleAppOO\n{\n    class Program\n    {\n        private static readonly string Prompt = "> ";\n        private static readonly ICalculatorService calculatorService;\n        \n        static Program()\n        {\n            // Dependency Injection initialization\n            var commandFactory = new CommandFactory(new AddCommand(), \n                                                  new SubtractCommand(),\n                                                  new MultiplyCommand(),\n                                                  new DivideCommand());\n            \n            calculatorService = new CalculatorService(commandFactory);\n        }\n        \n        static void Main(string[] args)\n        {\n            Console.WriteLine("Simple console-driven calculator. Type 'exit' to close.");\n            while (true)\n            {\n                Console.Write(Prompt);\n                var input = Console.ReadLine();\n                \n                if (!string.IsNullOrEmpty(input) && input.ToLower() == "exit")\n                    break;\n                \n                try\n                {\n                    var result = calculatorService.Calculate(input);\n                    Console.WriteLine($"= {result}");\n                }\n                catch (Exception ex)\n                {\n                    Console.WriteLine($"Error: {ex.Message}");\n                }\n            }\n        }\n    }\n}\n\n// Command Pattern Interface\npublic interface ICommand\n{\n    string Name { get; }\n    int Execute(int operandA, int operandB);\n}\n\n// Concrete Commands\npublic class AddCommand : ICommand\n{\n    public string Name => "+";\n    public int Execute(int operandA, int operandB) => operandA + operandB;\n}\n\npublic class SubtractCommand : ICommand\n{\n    public string Name => "-";\n    public int Execute(int operandA, int operandB) => operandA - operandB;\n}\n\npublic class MultiplyCommand : ICommand\n{\n    public string Name => "*";\n    public int Execute(int operandA, int operandB) => operandA * operandB;\n}\n\npublic class DivideCommand : ICommand\n{\n    public string Name => "/";\n    public int Execute(int operandA, int operandB)\n    {\n        if (operandB == 0)\n            throw new ArgumentException("Cannot divide by zero.");\n        \n        return operandA / operandB;\n    }\n}\n\n// Command Factory for mapping input to commands via dependency injection\npublic class CommandFactory\n{\n    private readonly ICommand addCommand;\n    private readonly ICommand subtractCommand;\n    private readonly ICommand multiplyCommand;\n    private readonly ICommand divideCommand;\n\n    public CommandFactory(ICommand addCommand, \n                          ICommand subtractCommand,\n                          ICommand multiplyCommand,\n                          ICommand divideCommand)\n    {\n        this.addCommand = addCommand;\n        this.subtractCommand = subtractCommand;\n        this.multiplyCommand = multiplyCommand;\n        this.divideCommand = divideCommand;\n    }\n\n    public ICommand GetCommand(string name) => name switch\n    {\n        "+" => addCommand,\n        "-" => subtractCommand,\n        "*" => multiplyCommand,\n        "/" => divideCommand,\n        _ => null\n    };\n}\n\n// Service that performs the actual calculation using commands\npublic class CalculatorService : ICalculatorService\n{\n    private readonly CommandFactory commandFactory;\n\n    public CalculatorService(CommandFactory commandFactory)\n    {\n        this.commandFactory = commandFactory;\n    }\n\n    public int Calculate(string input)\n    {\n        // Simple parsing logic for demonstration purposes\n        var parts = input.Split(new[] { ' ', '\t' }, StringSplitOptions.RemoveEmptyEntries);\n\n        if (parts.Length != 3)\n            throw new ArgumentException("Input is invalid.");\n\n        if (!int.TryParse(parts[0], out int operandA))\n            throw new ArgumentException($"'{parts[0]}' is not a valid integer.");\n        \n        var command = commandFactory.GetCommand(parts[1]);\n        if (command == null)\n            throw new ArgumentException($"Unknown operation '{parts[1]}'.");\n        \n        if (!int.TryParse(parts[2], out int operandB))\n            throw new ArgumentException($"'{parts[2]}' is not a valid integer.");\n        \n        return command.Execute(operandA, operandB);\n    }\n}\n\n// Service interface declaration\npublic interface ICalculatorService\n{\n    int Calculate(string input);\n}