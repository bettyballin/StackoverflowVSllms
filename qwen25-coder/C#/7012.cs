using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\nusing System.Text;\n\nclass Program\n{\n    [DllImport("advapi32.dll", SetLastError = true)]\n    static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);\n\n    [DllImport("userenv.dll")]\n    public static extern bool GetUserNameEx(uint nameFormat, StringBuilder userName, ref int userNameSize);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool CloseHandle(IntPtr hObject);\n\n    const int TOKEN_QUERY = 0x0008;\n\n    private enum EXTENDED_NAME_FORMAT { NameDisplay, NameUserPrincipal, NameUniqueUser, NameCanonical, NameSamCompatible };\n\n    public static string GetProcessOwner(int processId)\n    {\n        IntPtr htok = IntPtr.Zero;\n        bool retval = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, out htok);\n        if (!retval) return null;\n\n        try\n        {\n            var si = new WindowsIdentity(htok);\n            SecurityIdentifier psid;\n\n            if (processId == -1)\n                psid = si.User;\n            else\n            {\n                using (var proc = Process.GetProcessById(processId))\n                    psid = sidForProc(proc);\n\n                if (psid == null) return Environment.MachineName + @"\" + Environment.UserName;\n            }\n\n            var sidstr = psid.Translate(typeof(NTAccount));\n            return sidstr.Value;\n        }\n        catch { return "?"; }\n        finally\n        {\n            CloseHandle(htok);\n        }\n    }\n\n    private static SecurityIdentifier? sidForProc(Process proc)\n    {\n        IntPtr htok = IntPtr.Zero;\n        try\n        {\n            if (!OpenProcessToken(proc.Handle, TOKEN_QUERY, out htok)) \n                throw new UnauthorizedAccessException();\n\n            using (var winId = new WindowsIdentity(htok))\n                return winId.User;\n\n        }\n        finally { CloseHandle(htok); } // Ensure the handle is closed even on failure\n\n    }\n\n    static void Main(string[] args)\n    {\n        string currentUserName = Environment.UserName;\n        foreach (Process p in Process.GetProcesses())\n        {\n            try\n            {\n                string processOwner = GetProcessOwner(p.Id);\n                if (processOwner != null && processOwner.Contains(currentUserName))\n                {\n                    Console.WriteLine("Process: {0}, Owner: {1}", p.ProcessName, processOwner);\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine("Error with process " + p.ProcessName + ": " + ex.Message);\n            }\n        }\n    }\n\n}