// Define an analyzer that flags usage of any method marked with [Obsolete]\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.CSharp;\nusing Microsoft.CodeAnalysis.CSharp.Syntax;\nusing Microsoft.CodeAnalysis.Diagnostics;\n\n[DiagnosticAnalyzer(LanguageNames.CSharp)]\npublic class DeprecatedMethodUsageAnalyzer : DiagnosticAnalyzer\n{\n    public const string DiagnosticId = "DEPRECATED_USAGE";\n    private static readonly LocalizableString Title = "Deprecated method usage";\n    private static readonly LocalizableString MessageFormat = "{0} is deprecated.";\n    private static readonly LocalizableString Description = "This method is deprecated and should not be used.";\n    private const string Category = "Usage";\n\n    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);\n\n    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(Rule);\n\n    public override void Initialize(AnalysisContext context)\n    {\n        context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n        context.EnableConcurrentExecution();\n        context.RegisterSyntaxNodeAction(AnalyzeMethodInvocation, SyntaxKind.InvocationExpression);\n    }\n\n    private void AnalyzeMethodInvocation(SyntaxNodeAnalysisContext context)\n    {\n        var invocation = (InvocationExpressionSyntax)context.Node;\n        if (!(invocation.Expression is MemberAccessExpressionSyntax memberAccess))\n            return;\n\n        var symbolInfo = context.SemanticModel.GetSymbolInfo(memberAccess.Name);\n        if (!symbolInfo.Symbol.IsDeprecated(context.Compilation, out var deprecationDiagnosticArguments))\n            return;\n\n        var diagnostic = Diagnostic.Create(Rule, invocation.GetLocation(), deprecationDiagnosticArguments[0]);\n        context.ReportDiagnostic(diagnostic);\n    }\n\n    private static bool IsDeprecated(this ISymbol symbol, Compilation compilation, out object[] diagnosticArguments)\n    {\n        foreach (var attributeData in symbol.GetAttributes())\n        {\n            if (!attributeData.AttributeClass.Name.Equals("ObsoleteAttribute", StringComparison.Ordinal))\n                continue;\n\n            var arguments = attributeData.ConstructorArguments;\n            diagnosticArguments =\n                new[]\n                {\n                    arguments.Length > 0 && !arguments[0].Value.IsNull ?\n                        $"Method '{symbol.Name}' is deprecated: {arguments[0].Value}" :\n                        $"Method '{symbol.Name}' is deprecated."\n                };\n            return true;\n        }\n\n        diagnosticArguments = null;\n        return false;\n    }\n}