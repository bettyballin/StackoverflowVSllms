using System;\nusing System.Threading;\n\npublic class Slot\n{\n    private int free; // 0 or 1\n\n    public bool TryAcquire()\n    {\n        return Interlocked.CompareExchange(ref free, 0, 1) == 1;\n    }\n\n    public void Release()\n    {\n        free = 1;\n    }\n\n    public Data GetData() { /* implementation here */ }\n}\n\npublic class RingBuffer\n{\n    private Slot[] slots;\n    private int readIndex;\n    private int writeIndex;\n\n    public RingBuffer(int size)\n    {\n        slots = new Slot[size];\n        for (int i = 0; i < size; i++)\n        {\n            slots[i] = new Slot { free = 1 }; // Initialize all slots as free\n        }\n        readIndex = 0;\n        writeIndex = 0;\n    }\n\n    public void Produce(Data data)\n    {\n        while (!slots[writeIndex].TryAcquire())\n        {\n            Thread.Yield(); // Be nice to other threads if the slot is not available\n        }\n\n        slots[writeIndex].WriteData(data);\n        writeIndex = (writeIndex + 1) % slots.Length; // Circular buffer logic\n\n        Monitor.PulseAll(slots); // Notify consumer threads that data is available\n    }\n\n    public Data Consume()\n    {\n        while (slots[readIndex].free == 1)\n        {\n            using (var mre = new ManualResetEvent(false))\n            {\n                lock (slots)\n                {\n                    if (slots[readIndex].free == 1)\n                    {\n                        Monitor.Wait(slots);\n                        continue;\n                    }\n                }\n            }\n        }\n\n        Data data = slots[readIndex].GetData();\n        slots[readIndex].Release();\n\n        readIndex = (readIndex + 1) % slots.Length; // Circular buffer logic\n\n        return data;\n    }\n}