using System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\npublic static class WaitHandleExtensions\n{\n    private const uint INFINITE = 0xFFFFFFFF;\n    private const uint WAIT_FAILED = 0xFFFFFFFF;\n    private const uint WAIT_TIMEOUT = 0x102;\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern uint WaitForSingleObjectEx(IntPtr hHandle, uint dwMilliseconds, bool bAlertable);\n\n    public static bool WaitFor(this WaitHandle waitHandle, TimeSpan timeout)\n    {\n        // Convert the TimeSpan to milliseconds\n        uint millisecondsTimeout = (timeout == Timeout.InfiniteTimeSpan) ? INFINITE : checked((uint)timeout.TotalMilliseconds);\n        \n        // Call WaitForSingleObjectEx with alertable set to false to avoid message pumping\n        uint result = WaitForSingleObjectEx(waitHandle.SafeWaitHandle.DangerousGetHandle(), millisecondsTimeout, false);\n\n        switch (result)\n        {\n            case WAIT_FAILED:\n                throw new InvalidOperationException("WaitForSingleObjectEx failed", new System.ComponentModel.Win32Exception());\n            case WAIT_TIMEOUT:\n                return false;\n            default:\n                return true; // The wait handle was signaled\n        }\n    }\n}