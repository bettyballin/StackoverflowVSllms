using System;\nusing System.Net.Security;\nusing System.Net.Sockets;\nusing System.Security.Authentication;\nusing System.Text;\nusing System.Threading.Tasks;\n\npublic class TcpSslServer {\n    private const string CertificatePath = "path_to_your_certificate.pfx";\n    private const int PortNumber = 8080;\n\n    public static async Task RunServer() {\n        using (TcpListener tcpListener = new TcpListener(PortNumber)) {\n            tcpListener.Start();\n            Console.WriteLine("TCP listener started");\n\n            while (true) {\n                TcpClient client = await tcpListener.AcceptTcpClientAsync();\n                ProcessClient(client);\n            }\n        }\n    }\n\n    private static async Task ProcessClient(TcpClient client) {\n        var sslStream = new SslStream(client.GetStream(), false);\n\n        try {\n            sslStream.AuthenticateAsServer(\n                X509Certificate2.CreateFromCertFile(CertificatePath),\n                false,\n                SslProtocols.Tls, true);\n\n            byte[] messageBuffer = new byte[1024];\n            int bytesRead;\n\n            while ((bytesRead = await sslStream.ReadAsync(messageBuffer, 0, messageBuffer.Length)) != 0) {\n                Console.WriteLine("Received: {0}", Encoding.UTF8.GetString(messageBuffer, 0, bytesRead));\n                // Echo the data back to the client.\n                byte[] responseBytes = Encoding.UTF8.GetBytes("Echo: " + Encoding.UTF8.GetString(messageBuffer, 0, bytesRead));\n                await sslStream.WriteAsync(responseBytes, 0, responseBytes.Length);\n            }\n        } catch (AuthenticationException e) {\n            Console.WriteLine("Exception: {0}", e.Message);\n            if (e.InnerException != null) {\n                Console.WriteLine("\nInner exception: {0}", e.InnerException.Message);\n            }\n        } finally {\n            client.Close();\n        }\n    }\n\n    public static void Main() {\n        RunServer().GetAwaiter().GetResult();\n    }\n}