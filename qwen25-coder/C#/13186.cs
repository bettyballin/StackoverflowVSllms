public class BackgroundProcessor\n{\n    public event EventHandler<ProcessCompletedEventArgs> Completed;\n\n    protected virtual void OnCompleted(ProcessCompletedEventArgs e)\n    {\n        // Make a temporary copy of the delegates to call, to avoid \n        // problems if any handlers are detached while iterating.\n        EventHandler<ProcessCompletedEventArgs> temp = Volatile.Read(ref Completed);\n\n        if (temp != null)\n        {\n            foreach (EventHandler<ProcessCompletedEventArgs> handler in temp.GetInvocationList())\n            {\n                try\n                {\n                    // Fire event asynchronously without waiting for it to complete\n                    // This way the background task is not blocked by the handler.\n                    Task.Run(() => handler.Invoke(this, e));\n                }\n                catch (Exception ex)\n                {\n                    // Handle or log exception if necessary\n                    Console.WriteLine($"Error in event handler: {ex}");\n                }\n            }\n        }\n    }\n\n    public void ProcessFile()\n    {\n        // Simulate file processing\n        Task.Delay(1000).Wait();\n\n        OnCompleted(new ProcessCompletedEventArgs("file.txt"));\n    }\n}\n\npublic class ProcessCompletedEventArgs : EventArgs\n{\n    public string FileName { get; }\n\n    public ProcessCompletedEventArgs(string fileName)\n    {\n        FileName = fileName;\n    }\n}