using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\npublic class LdapToClassMapper<T>\n{\n    private readonly Dictionary<string, PropertyInfo> _ldapFieldMapping = new Dictionary<string, PropertyInfo>();\n\n    public LdapToClassMapper()\n    {\n        BuildAttributeMapping(typeof(T));\n    }\n\n    private void BuildAttributeMapping(Type type)\n    {\n        foreach (var property in type.GetProperties())\n        {\n            var directoryAttribute = property.GetCustomAttributes(typeof(DirectoryAttributeAttribute), false).FirstOrDefault() as DirectoryAttributeAttribute;\n            if (directoryAttribute != null && directoryAttribute.Type == DirectoryAttributeType.Ldap)\n            {\n                _ldapFieldMapping[directoryAttribute.Attribute] = property;\n            }\n        }\n    }\n\n    public T MapFromLdapResult(IDictionary<string, object> ldapEntry)\n    {\n        var instance = Activator.CreateInstance<T>();\n        foreach (var entry in ldapEntry)\n        {\n            if (_ldapFieldMapping.TryGetValue(entry.Key, out PropertyInfo property))\n            {\n                // You might want to add checking for compatible types and conversion here\n                property.SetValue(instance, Convert.ChangeType(entry.Value, property.PropertyType));\n            }\n        }\n\n        return instance;\n    }\n}\n\n// Usage Example:\nvar mapper = new LdapToClassMapper<User>();\nvar ldapResult = new Dictionary<string, object>\n{\n    { "cn", "johndoe" },\n    { "userpassword", "secret" },\n    { "C4-Parent", "someparent" }\n};\n\nUser user = mapper.MapFromLdapResult(ldapResult);