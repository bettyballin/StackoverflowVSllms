public class ChartAxisCalculator\n{\n    public static (double min, double max, double interval) CalculateAxis(double minValue, double maxValue, int numTicks, double? fixedValue)\n    {\n        if (numTicks < 2) throw new ArgumentException("Number of ticks must be at least 2.");\n\n        // Determine the range and initial interval\n        double dataRange = Math.Abs(maxValue - minValue);\n        double initialInterval = RoundToNearestNiceNumber(dataRange / numTicks);\n\n        // Adjust min and max to ensure they align with intervals if a fixed value is required\n        double adjustedMin;\n        double adjustedMax;\n\n        if (fixedValue.HasValue)\n        {\n            double lowerLimit = Math.Min(minValue, fixedValue.Value);\n            double upperLimit = Math.Max(maxValue, fixedValue.Value);\n\n            // Calculate min and max based on intervals from the fixed value\n            adjustedMin = Math.Floor(lowerLimit / initialInterval) * initialInterval;\n            adjustedMax = Math.Ceiling(upperLimit / initialInterval) * initialInterval;\n\n            // Ensure that we have at least the required number of ticks including the fixed value\n            while ((adjustedMax - adjustedMin) / initialInterval < numTicks - 1)\n            {\n                initialInterval /= 2;\n                adjustedMin = Math.Floor(lowerLimit / initialInterval) * initialInterval;\n                adjustedMax = Math.Ceiling(upperLimit / initialInterval) * initialInterval;\n            }\n        }\n        else\n        {\n            // No fixed value, simply calculate min and max based on intervals\n            adjustedMin = Math.Floor(minValue / initialInterval) * initialInterval;\n            adjustedMax = Math.Ceiling(maxValue / initialInterval) * initialInterval;\n            \n            // Ensure at least numTicks ticks exist between min and max\n            while ((adjustedMax - adjustedMin) / initialInterval < numTicks - 1)\n            {\n                initialInterval /= 2;\n                adjustedMin = Math.Floor(minValue / initialInterval) * initialInterval;\n                adjustedMax = Math.Ceiling(maxValue / initialInterval) * initialInterval;\n            }\n        }\n\n        return (adjustedMin, adjustedMax, initialInterval);\n    }\n\n    private static double RoundToNearestNiceNumber(double x)\n    {\n        int expv = (int)Math.Floor(Math.Log10(x));\n        x /= Math.Pow(10.0, expv);\n\n        if (x < 1.5) { x = 1; }\n        else if (x < 3) { x = 2; }\n        else if (x < 7) { x = 5; }\n        else { x = 10; }\n\n        return x * Math.Pow(10.0, expv);\n    }\n}