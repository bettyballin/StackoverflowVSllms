using System;\nusing System.IO;\nusing System.Text;\n\npublic class EfficientReader {\n    private static byte[] NewLine = new byte[] { 13, 10 }; // \r\n\n    private static byte NewLineCharCR = 13; // \r\n    private static byte NewLineCharLF = 10; // \n\n\n    public static string ReadLine(BinaryReader reader) {\n        StringBuilder sb = new StringBuilder();\n        byte[] buffer = new byte[1024];\n        int readBytes;\n\n        while ((readBytes = reader.Read(buffer, 0, buffer.Length)) > 0) {\n            for (int i = 0; i < readBytes; i++) {\n                if (buffer[i] == NewLineCharCR || buffer[i] == NewLineCharLF) {\n                    // Check for \r\n sequence\n                    if (i + 1 < readBytes && \n                        ((buffer[i] == NewLineCharCR && buffer[i + 1] == NewLineCharLF) ||\n                         (buffer[i] == NewLineCharLF && buffer[i + 1] == NewLineCharCR))) {\n                        i++; // Skip the next character as it's part of \r\n or \n\r\n                    }\n                    return sb.ToString();\n                }\n                sb.Append((char)buffer[i]);\n            }\n        }\n\n        // Return whatever is left in the buffer if EOF reached without finding a full newline\n        return readBytes > 0 ? sb.ToString() : null;\n    }\n}