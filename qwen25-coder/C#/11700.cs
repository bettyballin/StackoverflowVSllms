using System;\nusing System.Threading;\n\npublic class Foo\n{\n    public event EventHandler MyEvent;\n\n    public void RaiseEvent()\n    {\n        // Raise the event.\n        MyEvent?.Invoke(this, EventArgs.Empty);\n    }\n}\n\npublic class Bar\n{\n    private SynchronizationContext synchronizationContext;\n    \n    public Bar()\n    {\n        // Capture the current synchronization context in Bar's constructor.\n        synchronizationContext = SynchronizationContext.Current ?? new SynchronizationContext();\n    }\n\n    public void HandleFooEvent(object sender, EventArgs e)\n    {\n        // Use Post or Send to run on Bar's thread.\n        synchronizationContext.Post(_ =>\n        {\n            Console.WriteLine("Handling event on " + Thread.CurrentThread.ManagedThreadId);\n            // Do something meaningful here in the context of Bar\n        }, null);\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Foo foo = new Foo();\n        Bar bar = new Bar();\n\n        // Subscribe to Foo's event with Bar's handler.\n        foo.MyEvent += bar.HandleFooEvent;\n\n        // Raise the event from a different thread.\n        Thread t = new Thread(() =>\n        {\n            Console.WriteLine("Raising event on " + Thread.CurrentThread.ManagedThreadId);\n            foo.RaiseEvent();\n        });\n\n        t.Start();\n\n        Console.ReadLine(); // Wait for user input to keep the console window open\n    }\n}