using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Reflection;\n\npublic interface ICommand\n{\n    void Execute();\n}\n\npublic class CommandLoader\n{\n    public static List<ICommand> LoadCommandsFromDlls(string directory)\n    {\n        var commands = new List<ICommand>();\n\n        // Get all DLL files in the specified directory\n        foreach (var dllPath in Directory.GetFiles(directory, "*.dll"))\n        {\n            try\n            {\n                // Load the assembly from the file\n                var assembly = Assembly.LoadFrom(dllPath);\n\n                // Get types that implement ICommand interface\n                var commandTypes = assembly.GetExportedTypes()\n                    .Where(t => typeof(ICommand).IsAssignableFrom(t) && !t.IsInterface && !t.IsAbstract)\n                    .ToList();\n\n                // Create instances of these types and add them to the list\n                commands.AddRange(commandTypes.Select(Activator.CreateInstance).Cast<ICommand>());\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($"Error loading {dllPath}: {ex.Message}");\n            }\n        }\n\n        return commands;\n    }\n}\n\n// Example usage:\npublic class SampleCommand : ICommand\n{\n    public void Execute() => Console.WriteLine("Sample command executed.");\n}\n\nclass Program\n{\n    static void Main()\n    {\n        string directory = @"path\to\dlls";\n        var commands = CommandLoader.LoadCommandsFromDlls(directory);\n\n        foreach (var command in commands)\n        {\n            // You can now execute the commands or list them in your UI\n            command.Execute();\n        }\n    }\n}