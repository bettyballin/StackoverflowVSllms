using System;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    [DllImport("shell32.dll", CharSet = CharSet.Auto)]\n    public static extern bool ShellExecuteEx(ref SHELLEXECUTEINFO lpExecInfo);\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n    public struct SHELLEXECUTEINFO\n    {\n        public int cbSize;\n        public uint fMask;\n        public IntPtr hwnd;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpVerb;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpFile;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpParameters;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpDirectory;\n        public int nShow;\n        public IntPtr hInstApp;\n        public IntPtr lpIDList;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpClass;\n        public IntPtr hkeyClass;\n        public uint dwHotKey;\n        public IntPtr hIcon;\n        public IntPtr hProcess;\n    }\n\n    static void Main()\n    {\n        SHELLEXECUTEINFO sei = new SHELLEXECUTEINFO();\n        sei.cbSize = Marshal.SizeOf(sei);\n        sei.lpVerb = "open";\n        sei.lpFile = "Sample.xls";\n        sei.nShow = 1; // SW_SHOWNORMAL\n        sei.lpParameters = "/r"; // Command line arguments here\n\n        if (!ShellExecuteEx(ref sei))\n        {\n            int error = Marshal.GetLastWin32Error();\n            Console.WriteLine("Failed to execute with error: " + error);\n        }\n    }\n}