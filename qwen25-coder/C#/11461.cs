using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\n\npublic class CredentialHelper\n{\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]\n    public static extern bool CredEnumerate(string Filter, int Flag, out int Count, out IntPtr pCredentials);\n\n    [DllImport("advapi32.dll", SetLastError = true)]\n    private static extern void CredFree(IntPtr cred);\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n    struct NATIVE_CREDENTIAL\n    {\n        public uint Flags;\n        public uint Type;\n        public string TargetName;\n        public string Comment;\n        public System.Runtime.InteropServices.ComTypes.FILETIME LastWritten;\n        public uint CredentialBlobSize;\n        public IntPtr CredentialBlob;\n        public uint Persist;\n        public uint AttributeCount;\n        public IntPtr Attributes;\n        public string TargetAlias;\n        public string UserName;\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n    struct Credential\n    {\n        public uint Flags;\n        public CredentialType Type;\n        public string TargetName;\n        public string Comment;\n        public DateTime LastWritten;\n        public byte[] CredentialBlob;\n        public Persistance Persist;\n        public CredentialAttribute[] Attributes;\n        public string TargetAlias;\n        public string UserName;\n\n        // Custom constructor to convert NATIVE_CREDENTIAL to Credential\n        public Credential(NATIVE_CREDENTIAL nc)\n        {\n            Flags = nc.Flags;\n            Type = (CredentialType)nc.Type;\n            TargetName = nc.TargetName;\n            Comment = nc.Comment;\n            LastWritten = DateTime.FromFileTimeUtc(((long)nc.LastWritten.dwHighDateTime << 32) + nc.LastWritten.dwLowDateTime);\n            CredentialBlobSize = nc.CredentialBlobSize;\n            CredentialBlob = new byte[CredentialBlobSize];\n            if (CredentialBlobSize > 0)\n                Marshal.Copy(nc.CredentialBlob, CredentialBlob, 0, (int)CredentialBlobSize);\n            Persist = (Persistance)nc.Persist;\n            AttributeCount = nc.AttributeCount;\n            Attributes = null; // Assuming attributes are not used here.\n            TargetAlias = nc.TargetAlias;\n            UserName = nc.UserName;\n        }\n    }\n\n    public enum CredentialType : uint\n    {\n        Generic = 1,\n        DomainPassword = 2,\n        DomainCertificate = 3,\n        DomainVisiblePassword = 4,\n        GenericCertifiate = 5,\n        DomainExtended = 6\n    }\n\n    public enum Persistance : uint\n    {\n        Session = 0x1,\n        LocalMachine = 0x2,\n        Enterprise = 0x4\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n    struct CredentialAttribute\n    {\n        public string Keyword;\n        public uint Flags;\n        public uint ValueSize;\n        public IntPtr Value;\n    }\n\n    public static List<Credential> EnumerateCredentials()\n    {\n        int count = 0;\n        IntPtr pCredentials = IntPtr.Zero;\n        bool ret = CredEnumerate(null, 0, out count, out pCredentials);\n\n        try\n        {\n            List<Credential> creds = new List<Credential>();\n            \n            if (ret)\n            {\n                for (int i = 0; i < count; i++)\n                {\n                    IntPtr credentialPtr = Marshal.ReadIntPtr(pCredentials, i * IntPtr.Size);\n                    NATIVE_CREDENTIAL nativeCredential = (NATIVE_CREDENTIAL)Marshal.PtrToStructure(credentialPtr, typeof(NATIVE_CREDENTIAL));\n                    Credential cred = new Credential(nativeCredential);\n                    creds.Add(cred);\n                }\n            }\n\n            return creds;\n        }\n        finally\n        {\n            if (pCredentials != IntPtr.Zero)\n                CredFree(pCredentials);\n        }\n    }\n}