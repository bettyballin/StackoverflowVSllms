private Thread staThread;\nprivate BlockingCollection<object> requestQueue = new BlockingCollection<object>();\nprivate AutoResetEvent workAvailableSignal = new AutoResetEvent(false);\nprivate bool isProcessingComplete = false;\n\npublic void Initialize()\n{\n    staThread = new Thread(STAThreadMethod)\n    {\n        ApartmentState = ApartmentState.STA\n    };\n    staThread.Start();\n}\n\nprivate void STAThreadMethod(object state)\n{\n    foreach (var argument in requestQueue.GetConsumingEnumerable())\n    {\n        try\n        {\n            STAProcessSelection(argument);\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine($"Error processing selection: {ex.Message}");\n        }\n\n        if (requestQueue.IsAddingCompleted && !requestQueue.Any())\n        {\n            isProcessingComplete = true;\n            workAvailableSignal.Set();\n            break;\n        }\n\n        workAvailableSignal.Set();\n    }\n}\n\nprivate void STAProcessSelection(object argument)\n{\n    ISelection selection = argument as ISelection;\n    if (selection != null)\n    {\n        processingResult = controller.ProcessSelection(selection);\n    }\n}\n\nprivate void StartProcessing(ISelection selection)\n{\n    requestQueue.Add(selection);\n    workAvailableSignal.WaitOne();\n}\n\nprivate void bckgrndWrkrController_DoWork(object sender, DoWorkEventArgs e)\n{\n    BackgroundWorker worker = sender as BackgroundWorker;\n    if (worker != null)\n    {\n        controller.BackgroundWorker = worker;\n\n        // Enqueue the work and wait for completion\n        StartProcessing(e.Argument);\n\n        while (!isProcessingComplete && !worker.CancellationPending)\n        {\n            Thread.Sleep(100); // Sleep to prevent busy-waiting\n        }\n\n        if (worker.CancellationPending)\n        {\n            e.Cancel = true;\n        }\n        else\n        {\n            e.Result = processingResult;\n        }\n    }\n}\n\nprivate void bckgrndWrkrController_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)\n{\n    // Handle completion logic here\n}