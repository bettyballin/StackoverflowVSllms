using System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\n\npublic static Bitmap CropWhitespace(Bitmap bitmap)\n{\n    var rect = new Rectangle(0, 0, bitmap.Width, bitmap.Height);\n    \n    // Lock bits and get the pointer to the data\n    BitmapData data = bitmap.LockBits(rect, ImageLockMode.ReadWrite, PixelFormat.Format32bppArgb);\n    IntPtr ptr = data.Scan0;\n\n    int bytes = Math.Abs(data.Stride) * bitmap.Height;\n    byte[] rgbValues = new byte[bytes];\n\n    // Copy the RGB values into the array\n    System.Runtime.InteropServices.Marshal.Copy(ptr, rgbValues, 0, bytes);\n\n    int top = bitmap.Height - 1;\n    int left = bitmap.Width - 1;\n    int right = 0;\n    int bottom = 0;\n\n    unsafe\n    {\n        byte* pStart = (byte*)ptr.ToPointer();\n        for (int y = 0; y < bitmap.Height; y++)\n        {\n            for (int x = 0; x < bitmap.Width; x++)\n            {\n                byte* qPixel = pStart + (y * data.Stride) + (x * 4);\n                var alpha = qPixel[3];\n                var red = qPixel[2];\n                var green = qPixel[1];\n                var blue = qPixel[0];\n\n                if ((alpha > 0) || (red != 255 && green != 255 && blue != 255))\n                {\n                    if (y < top) top = y;\n                    if (y > bottom) bottom = y;\n                    if (x < left) left = x;\n                    if (x > right) right = x;\n                }\n            }\n        }\n    }\n\n    // Crop the image\n    int cropWidth = right - left + 1;\n    int cropHeight = bottom - top + 1;\n\n    if ((cropWidth <= 0) || (cropHeight <= 0))\n        return new Bitmap(1, 1); // Return a dummy empty image\n\n    var resultBitmap = new Bitmap(cropWidth, cropHeight);\n    using (var g = Graphics.FromImage(resultBitmap))\n    {\n        g.DrawImage(bitmap, 0, 0, new Rectangle(left, top, cropWidth, cropHeight), GraphicsUnit.Pixel);\n    }\n\n    bitmap.UnlockBits(data);\n\n    return resultBitmap;\n}