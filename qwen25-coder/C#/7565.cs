using System;\nusing System.IO;\nusing System.Security.Principal;\nusing System.Runtime.InteropServices;\n\n// Define necessary interop declarations for Windows API functions and structures used for impersonation.\npublic class ImpersonateUserHelper\n{\n    public const int LOGON32_LOGON_INTERACTIVE = 2;\n    public const int LOGON32_PROVIDER_DEFAULT = 0;\n\n    [DllImport("advapi32.dll")]\n    public static extern bool LogonUser(String pszUsername, String pszDomain, String pszPassword, int dwLogonType,\n        int dwLogonProvider, out IntPtr phToken);\n\n    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]\n    public extern static bool CloseHandle(IntPtr handle);\n\n    private WindowsImpersonationContext _impersonatedUser;\n    private IntPtr _existingToken;\n\n    public void ImpersonateUser(string domain, string username, string password)\n    {\n        // Call LogonUser to get a token for the user.\n        if (!LogonUser(username, domain, password, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, out _existingToken))\n            throw new System.ComponentModel.Win32Exception(Marshal.GetLastWin32Error());\n\n        // Use that token to create a Windows identity object.\n        using (WindowsIdentity identity = new WindowsIdentity(_existingToken))\n        {\n            _impersonatedUser = identity.Impersonate();\n        }\n    }\n\n    public void UndoImpersonation()\n    {\n        // If an impersonation context was created, dispose it.\n        if (_impersonatedUser != null)\n        {\n            _impersonatedUser.Undo();\n            _impersonatedUser.Dispose();\n            CloseHandle(_existingToken);\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        ImpersonateUserHelper helper = new ImpersonateUserHelper();\n\n        try\n        {\n            // Replace 'domain', 'username', and 'password' with values appropriate for your environment.\n            helper.ImpersonateUser("your-domain", "your-username", "your-password");\n\n            // Check security with impersonated credentials.\n            DirectoryInfo[] directoriesToCheck = new DirectoryInfo[]\n            {\n                new DirectoryInfo("\\\\server\\path")\n            };\n\n            new SecurityChecker().CheckSecurity(directoriesToCheck);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"An error occurred: {ex.Message}");\n        }\n        finally\n        {\n            // Make sure to undo impersonation.\n            helper.UndoImpersonation();\n        }\n    }\n}\n\n// Your existing code for checking security, adjusted for the new context if necessary.\nclass SecurityChecker\n{\n    public void CheckSecurity(DirectoryInfo[] DIArray)\n    {\n        foreach (DirectoryInfo di in DIArray)\n        {\n            try\n            {\n                DirectorySecurity DirSec = di.GetAccessControl(AccessControlSections.All);\n                string sAccessInfo = string.Empty;\n\n                foreach (FileSystemAccessRule FSAR in DirSec.GetAccessRules(true, true, typeof(System.Security.Principal.NTAccount)))\n                {\n                    sAccessInfo += GetAceInformation(FSAR);\n                }\n\n                if (sAccessInfo != string.Empty)\n                {\n                    // Write info to text file\n                    Console.WriteLine(sAccessInfo);\n                }\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($"Failed to get ACL for {di.FullName}. Error: {ex.Message}");\n            }\n        }\n    }\n\n    private string GetAceInformation(FileSystemAccessRule ace)\n    {\n        StringBuilder info = new StringBuilder();\n        string line = string.Format("Account: {0}", ace.IdentityReference.Value);\n        info.AppendLine(line);\n        line = string.Format("Type: {0}", ace.AccessControlType);\n        info.AppendLine(line);\n        line = string.Format("Rights: {0}", ace.FileSystemRights);\n        info.AppendLine(line);\n        line = string.Format("Inherited ACE: {0}", ace.IsInherited);\n        info.AppendLine(line);\n        return info.ToString();\n    }\n}