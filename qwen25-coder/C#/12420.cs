using System;\nusing System.Collections.Concurrent;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class SocketEventProcessor\n{\n    private readonly ConcurrentQueue<byte[]> _eventQueue = new ConcurrentQueue<byte[]>();\n    private bool _isProcessing;\n    private readonly object _processingLock = new object();\n    private CancellationTokenSource _cancellationTokenSource;\n\n    public void StartProcessing()\n    {\n        _cancellationTokenSource = new CancellationTokenSource();\n        Task.Run(async () => await ProcessEventsAsync(_cancellationTokenSource.Token), _cancellationTokenSource.Token);\n    }\n\n    public void StopProcessing()\n    {\n        if (_cancellationTokenSource != null)\n        {\n            _cancellationTokenSource.Cancel();\n            _cancellationTokenSource.Dispose();\n        }\n    }\n\n    private async Task ProcessEventsAsync(CancellationToken cancellationToken)\n    {\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            lock (_processingLock)\n            {\n                if (_isProcessing) continue;\n                _isProcessing = true;\n            }\n\n            try\n            {\n                var batch = new List<byte[]>();\n                byte[] message;\n\n                // Collect messages until the queue is empty or a maximum batch size is reached.\n                while (!_eventQueue.IsEmpty && batch.Count < 100)\n                {\n                    if (_eventQueue.TryDequeue(out message))\n                    {\n                        batch.Add(message);\n                    }\n                }\n\n                if (batch.Count > 0)\n                {\n                    await Task.Run(() => ProcessBatch(batch));\n                }\n            }\n            finally\n            {\n                lock (_processingLock)\n                {\n                    _isProcessing = false;\n                }\n            }\n\n            // Small delay to prevent busy waiting when no messages are arriving.\n            await Task.Delay(10, cancellationToken);\n        }\n    }\n\n    private void ProcessBatch(List<byte[]> batch)\n    {\n        foreach (var message in batch)\n        {\n            // Copy the message buffer into an object\n            var eventMessage = CopyBufferToObject(message);\n\n            // Raise an event \n            OnEventReceived(eventMessage);\n\n            // Release the message buffer back into the ring-buffer pool\n            ReleaseMessageBufferToPool(message);\n        }\n    }\n\n    private EventMessage CopyBufferToObject(byte[] buffer)\n    {\n        // Implement conversion logic here.\n        return new EventMessage();\n    }\n\n    private void OnEventReceived(EventMessage eventMessage)\n    {\n        // Raise the event to notify subscribers.\n        EventReceived?.Invoke(this, eventMessage);\n    }\n\n    public void AddToQueue(SocketAsyncEventArgs e)\n    {\n        if (e.BytesTransferred > 0 && e.Buffer != null)\n        {\n            _eventQueue.Enqueue(e.Buffer.ToArray());\n        }\n    }\n\n    private void ReleaseMessageBufferToPool(byte[] message)\n    {\n        // Implement ring-buffer pool release logic here.\n    }\n\n    public event EventHandler<EventMessage> EventReceived;\n}\n\npublic class EventMessage\n{\n    // Define the structure of your event message here.\n}