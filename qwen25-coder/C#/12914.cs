using Castle.MicroKernel.Registration;\nusing Castle.Windsor;\n\npublic class DefaultConfig\n{\n    public virtual IWindsorContainer InitialiseContainer(IWindsorContainer container)\n    {\n        container.Register(\n            Component.For<X.Y.Z.IActivityService>()\n                     .ImplementedBy<X.Y.Z.ActivityService>()\n                     .Configure(c => c.ExtendedProperties["Listeners"] = new[] { typeof(X.Y.Z.DefaultActivityListener).FullName })\n                     .LifeStyle.Transient\n        );\n        return container;\n    }\n}\n\npublic class DecoratedConfig : DefaultConfig\n{\n    public override IWindsorContainer InitialiseContainer(IWindsorContainer container)\n    {\n        base.InitialiseContainer(container);\n\n        var existingListeners = (string[])container.Kernel.GetAssignableHandlers(typeof(X.Y.Z.IActivityService))[0].ComponentModel.ExtendedProperties["Listeners"];\n        var updatedListeners = existingListeners.Concat(new[] { "MyOtherListenerID" }).ToArray();\n\n        // Reregister the component with updated listeners\n        container.Register(\n            Component.For<X.Y.Z.IActivityService>()\n                     .ImplementedBy<X.Y.Z.ActivityService>()\n                     .Configure(c => c.ExtendedProperties["Listeners"] = updatedListeners)\n                     .LifeStyle.Transient\n                     .Named("updated" + typeof(X.Y.Z.IActivityService).Name)\n        );\n\n        return container;\n    }\n}