using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Security.Cryptography;\nusing System.Security.Permissions;\n\npublic static bool IsAssemblySignedWithStrongName(Assembly assembly, byte[] expectedPublicKeyToken)\n{\n    if (assembly == null) throw new ArgumentNullException(nameof(assembly));\n    if (expectedPublicKeyToken == null) throw new ArgumentNullException(nameof(expectedPublicKeyToken));\n\n    var assemblyName = assembly.GetName();\n    var publicKeyToken = assemblyName.GetPublicKeyToken();\n\n    // Compare the public key tokens.\n    return publicKeyToken.SequenceEqual(expectedPublicKeyToken);\n}\n\n// Usage\nvar loadedAssembly = Assembly.LoadFile(path);\nvar expectedToken = // Your known good token here, e.g., new byte[] { 0xXX, 0xYY, ... };\nbool isTrusted = IsAssemblySignedWithStrongName(loadedAssembly, expectedToken);\n\nif (isTrusted)\n{\n    // Proceed with loading or using the assembly\n}\nelse\n{\n    throw new SecurityException("The assembly does not have a valid strong name signature.");\n}