using System.Collections.Generic;\nusing System.ComponentModel;\n\npublic abstract class ValidatableBindableBase : BindableBase, INotifyDataErrorInfo\n{\n    private readonly Dictionary<string, List<string>> _errors = new Dictionary<string, List<string>>();\n\n    public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;\n\n    protected void SetErrors(string propertyName, IEnumerable<string> errors)\n    {\n        if (UpdateErrors(propertyName, errors))\n            OnErrorsChanged(propertyName);\n    }\n\n    public bool UpdateErrors(string propertyName, IEnumerable<string> currentErrorForProperty)\n    {\n        var newErrors = new HashSet<string>(currentErrorForProperty ?? Enumerable.Empty<string>());\n        var unchangedPropertyName = _errors.ContainsKey(propertyName)\n                                  && newErrors.SetEquals(_errors[propertyName]);\n        if (unchangedPropertyName) return false;\n\n        if (_errors.Count > 0 && _errors.ContainsKey(propertyName))\n            _errors.Remove(propertyName);\n        if (newErrors.Any())\n            _errors.Add(propertyName, new HashSet<string>(newErrors).ToList());\n\n        return true;\n    }\n\n    public IEnumerable GetErrors(string propertyName)\n    {\n        if (String.IsNullOrEmpty(propertyName) || !_errors.ContainsKey(propertyName)) yield break;\n\n        foreach (var error in _errors[propertyName]) yield return error;\n    }\n\n    public bool HasErrors => _errors.Count > 0;\n\n    protected void OnErrorsChanged(string property = "")\n    {\n        ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(property));\n    }\n}