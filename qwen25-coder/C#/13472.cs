using System;\nusing System.IO;\n\npublic class PE32BitModifier\n{\n    [Flags]\n    public enum CorFlags : uint\n    {\n        ILL Any = 0x0,\n        ILOnly = 0x1,\n        _32BITRequired = 0x2, // This is the bit we need to modify\n        StrongNameSigned = 0x8,\n        NativeEntryPoint = 0x10,\n        TrackingServices = 0x20,\n        DisableJITOptimizer = 0x40,\n        DisableJITTracking = 0x80\n    }\n\n    public static void Set32BitFlag(string filePath, bool set32Bit)\n    {\n        using (var fs = new FileStream(filePath, FileMode.OpenReadWrite))\n        {\n            var reader = new BinaryReader(fs);\n            var writer = new BinaryWriter(fs);\n\n            // DOS Header - skip to the PE header offset\n            fs.Seek(0x3C, SeekOrigin.Begin);\n            UInt32 peOffset = reader.ReadUInt32();\n\n            // Jump to the PE header and check if it's valid\n            fs.Seek(peOffset, SeekOrigin.Begin);\n            UInt32 signature = reader.ReadUInt32();\n            if (signature != 0x00004550) // "PE\0\0"\n                throw new Exception("Invalid PE file.");\n\n            // Skip to the COFF header and read it\n            fs.Seek(peOffset + 4 + 18, SeekOrigin.Begin);\n            UInt32 corHeaderRva = reader.ReadUInt32();\n            fs.Seek(peOffset + 4 + 96, SeekOrigin.Begin); // 20 bytes each of DOS and PE headers, plus the optional PE header\n            UInt32 corHeaderSize = reader.ReadUInt32();\n\n            if (corHeaderSize < 72) {\n                throw new Exception("Invalid COR20 header size.");\n            }\n\n            UInt16 machineType = reader.ReadUInt16();\n            bool is64Bit = machineType == 0x8664; // IMAGE_FILE_MACHINE_AMD64\n            bool wantChange = is64Bit != set32Bit;\n\n            if (!wantChange) return;\n\n            fs.Seek(corHeaderRva, SeekOrigin.Begin);\n            signature = reader.ReadUInt32(); \n            if (signature != 0x46524543) // "CER"\n                throw new Exception("Invalid COR header.");\n\n            fs.Seek(8, SeekOrigin.Current); // Skip to the CorFlags\n            CorFlags flags = (CorFlags)reader.ReadUInt32();\n\n            if (set32Bit)\n                flags |= CorFlags._32BITRequired;\n            else\n                flags &= ~CorFlags._32BITRequired;\n\n            fs.Seek(-4, SeekOrigin.Current);\n            writer.Write((UInt32)flags);\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        // Usage example:\n        try\n        {\n            Set32BitFlag("YourAssembly.dll", true); // Set the 32-bit flag\n            Console.WriteLine("The 32-bit flag has been set successfully.");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"An error occurred: {ex.Message}");\n        }\n    }\n}