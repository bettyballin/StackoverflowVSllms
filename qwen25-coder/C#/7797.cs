using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\n\npublic class QueryCondition\n{\n    public string PropertyName { get; set; }\n    public object Value { get; set; }\n    public string Operator { get; set; } // "And", "Or"\n}\n\npublic class DynamicQueryBuilder<T> where T : class\n{\n    private readonly List<QueryCondition> _conditions = new List<QueryCondition>();\n\n    public void AddCondition(string propertyName, object value, string @operator)\n    {\n        _conditions.Add(new QueryCondition { PropertyName = propertyName, Value = value, Operator = @operator });\n    }\n\n    public IEnumerable<T> BuildQuery()\n    {\n        var parameterExpression = Expression.Parameter(typeof(T), "entity");\n        Expression finalExpression = null;\n\n        foreach (var condition in _conditions)\n        {\n            var propertyInfo = typeof(T).GetProperty(condition.PropertyName);\n            if (propertyInfo == null) throw new ArgumentException($"Property {condition.PropertyName} not found on type {typeof(T)}");\n\n            var left = Expression.Property(parameterExpression, propertyInfo);\n            var right = Expression.Constant(Convert.ChangeType(condition.Value, propertyInfo.PropertyType));\n            var comparison = Expression.Equal(left, right);\n\n            if (finalExpression == null)\n            {\n                finalExpression = comparison;\n            }\n            else\n            {\n                switch (condition.Operator.ToLower())\n                {\n                    case "and":\n                        finalExpression = Expression.AndAlso(finalExpression, comparison);\n                        break;\n                    case "or":\n                        finalExpression = Expression.OrElse(finalExpression, comparison);\n                        break;\n                    default:\n                        throw new ArgumentException("Unsupported operator", nameof(condition.Operator));\n                }\n            }\n        }\n\n        if (finalExpression == null) return Enumerable.Empty<T>();\n\n        var lambda = Expression.Lambda<Func<T, bool>>(finalExpression, parameterExpression);\n        return FindByLambda(lambda.Compile());\n    }\n\n    private IEnumerable<T> FindByLambda(Func<T, bool> predicate)\n    {\n        // Replace with your actual data fetching logic\n        using (var session = NHibernateSessionFactory.OpenSession())\n        {\n            return session.Query<T>().Where(predicate).ToList();\n        }\n    }\n}