public class ImageHandler : IHttpHandler\n{\n    public bool IsReusable => false;\n\n    public void ProcessRequest(HttpContext context)\n    {\n        string imagePath = GetImagePathFromRequest(context.Request);\n        \n        // Check if the user has permission to access the image\n        if (!UserHasAccessToImage(context.User, imagePath))\n        {\n            context.Response.StatusCode = (int)HttpStatusCode.Forbidden;\n            return;\n        }\n\n        if (File.Exists(imagePath))\n        {\n            context.Response.ContentType = GetContentType(Path.GetExtension(imagePath));\n            context.Response.TransmitFile(imagePath);\n        }\n        else\n        {\n            context.Response.StatusCode = (int)HttpStatusCode.NotFound;\n        }\n    }\n\n    private string GetImagePathFromRequest(HttpRequest request)\n    {\n        // Extract the image path parameter and construct the full file path\n        var imagePathParameter = request.QueryString["imagepath"]; // Example: product/123/main.jpg\n        return Path.Combine(_env.WebRootPath, "images", imagePathParameter);\n    }\n\n    private bool UserHasAccessToImage(ClaimsPrincipal user, string filePath)\n    {\n        // Implement logic to check if the current user is allowed to access this file\n        // This might involve checking roles or other business rules\n        return user.Identity.IsAuthenticated;\n    }\n\n    private string GetContentType(string extension)\n    {\n        switch (extension.ToLower())\n        {\n            case ".jpg":\n                return "image/jpeg";\n            case ".png":\n                return "image/png";\n            default:\n                return "application/octet-stream";\n        }\n    }\n}