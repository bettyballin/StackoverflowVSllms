using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Rectangle\n{\n    public double X0 { get; set; }\n    public double Y0 { get; set; }\n    public double X1 { get; set; }\n    public double Y1 { get; set; }\n\n    public Rectangle(double x0, double y0, double x1, double y1)\n    {\n        X0 = x0;\n        Y0 = y0;\n        X1 = x1;\n        Y1 = y1;\n    }\n\n    public bool Intersects(Rectangle other)\n    {\n        return !(X1 <= other.X0 || X0 >= other.X1 || Y1 <= other.Y0 || Y0 >= other.Y1);\n    }\n}\n\nclass Event\n{\n    public double X { get; set; }\n    public int Type { get; set; } // 0 = Start, 1 = End\n    public Rectangle Rect { get; set; }\n\n    public Event(double x, int type, Rectangle rect)\n    {\n        X = x;\n        Type = type;\n        Rect = rect;\n    }\n}\n\nclass IntervalTree\n{\n    private List<Event> events;\n\n    public IntervalTree(List<Rectangle> rectangles)\n    {\n        events = new List<Event>();\n        foreach (var rect in rectangles)\n        {\n            events.Add(new Event(rect.X0, 0, rect));\n            events.Add(new Event(rect.X1, 1, rect));\n        }\n        events.Sort((a, b) =>\n        {\n            if (Math.Abs(a.X - b.X) < 0.00001)\n                return a.Type.CompareTo(b.Type);\n            return a.X.CompareTo(b.X);\n        });\n    }\n\n    public double CalculateOverlapArea()\n    {\n        var activeRectangles = new List<Rectangle>();\n        List<(double start, double end)> intervals = new List<(double, double)>();\n        double totalOverlapArea = 0;\n\n        foreach (var e in events)\n        {\n            if (e.Type == 0) // Start of rectangle\n            {\n                activeRectangles.Add(e.Rect);\n                CalculateIntervals(activeRectangles, ref intervals);\n\n                // Sort the intervals by start point and merge overlapping ones\n                intervals.Sort();\n                MergeIntervals(intervals);\n                totalOverlapArea += SumIntervalLengths(intervals) * (e.X - events.Where(ev => ev.X < e.X).Max(ev => ev.X));\n            }\n            else // End of rectangle\n            {\n                activeRectangles.Remove(e.Rect);\n                CalculateIntervals(activeRectangles, ref intervals);\n\n                // Sort the intervals by start point and merge overlapping ones\n                intervals.Sort();\n                MergeIntervals(intervals);\n                totalOverlapArea += SumIntervalLengths(intervals) * (e.X - events.Where(ev => ev.X < e.X).Max(ev => ev.X));\n            }\n        }\n\n        return totalOverlapArea;\n    }\n\n    private static void CalculateIntervals(List<Rectangle> activeRectangles, ref List<(double start, double end)> intervals)\n    {\n        var sortedY = new SortedDictionary<double, int>();\n\n        foreach (var rect in activeRectangles)\n        {\n            if (sortedY.ContainsKey(rect.Y0))\n                sortedY[rect.Y0]++;\n            else\n                sortedY[rect.Y0] = 1;\n            if (sortedY.ContainsKey(rect.Y1))\n                sortedY[rect.Y1]--;\n            else\n                sortedY[rect.Y1] = -1;\n        }\n\n        intervals.Clear();\n        int balance = 0;\n        double start = 0;\n\n        foreach (var kvp in sortedY)\n        {\n            balance += kvp.Value;\n            if (balance == 1 && start == 0)\n                start = kvp.Key;\n            else if ((balance == 0 || balance < 0) && start > 0)\n            {\n                intervals.Add((start, kvp.Key));\n                start = 0;\n            }\n        }\n    }\n\n    private static void MergeIntervals(List<(double start, double end)> intervals)\n    {\n        for (int i = 1; i < intervals.Count; i++)\n        {\n            if (intervals[i].start <= intervals[i - 1].end)\n            {\n                intervals[i] = (intervals[i - 1].start, Math.Max(intervals[i].end, intervals[i - 1].end));\n                intervals.RemoveAt(i - 1);\n                i--;\n            }\n        }\n    }\n\n    private static double SumIntervalLengths(List<(double start, double end)> intervals)\n    {\n        return intervals.Sum(interval => interval.end - interval.start);\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        var rectangles = new List<Rectangle>\n        {\n            new Rectangle(0, 0, 10, 10),\n            new Rectangle(5, 5, 15, 15),\n            new Rectangle(12, 12, 20, 20)\n        };\n\n        var tree = new IntervalTree(rectangles);\n        double overlapArea = tree.CalculateOverlapArea();\n        Console.WriteLine($"Total Overlap Area: {overlapArea}");\n    }\n}