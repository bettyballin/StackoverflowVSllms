using System;\nusing System.IO;\nusing System.Text.Xml;\n\npublic class InvalidCharFilteringStream : Stream\n{\n    private const int BufferSize = 4096;\n    private readonly Stream _baseStream;\n    private byte[] _buffer;\n    private int _bufferPos;\n    private int _bufferLength;\n    private char _currentChar;\n    private bool _atEnd;\n\n    public InvalidCharFilteringStream(Stream baseStream)\n    {\n        _baseStream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));\n        _buffer = new byte[BufferSize];\n        _bufferPos = 0;\n        _bufferLength = 0;\n        _currentChar = '\0';\n        _atEnd = false;\n    }\n\n    public override bool CanRead => true;\n\n    public override bool CanSeek => false;\n\n    public override bool CanWrite => false;\n\n    public override long Length => throw new NotSupportedException();\n\n    public override long Position\n    {\n        get => throw new NotSupportedException();\n        set => throw new NotSupportedException();\n    }\n\n    private void EnsureMoreCharsAvailableIfBufferIsEmpty()\n    {\n        if (_bufferPos >= _bufferLength)\n        {\n            _bufferLength = _baseStream.Read(_buffer, 0, BufferSize);\n            _bufferPos = 0;\n            if (_bufferLength == 0)\n                _atEnd = true;\n        }\n    }\n\n    private bool IsCurrentCharInvalid()\n    {\n        char c = _currentChar;\n        return (c < '\x0009' || \n               (c > '\x000A' && c < '\x000D') ||\n                c == '\x000B' ||\n               (c > '\x000D' && c < '\x0020'));\n    }\n\n    private bool TryReadNextChar(out char ch)\n    {\n        ch = default;\n        EnsureMoreCharsAvailableIfBufferIsEmpty();\n        \n        if (_atEnd) return false;\n\n        ch = (char)_buffer[_bufferPos++];\n        _currentChar = ch;\n        while (_bufferPos < _bufferLength && IsCurrentCharInvalid())\n            ch = (char)(_buffer[_bufferPos++]);\n        _currentChar = ch;\n        return _atEnd ? false : true;\n    }\n\n    public override int Read(byte[] buffer, int offset, int count)\n    {\n        if (!TryReadNextChar(out char first))\n            return 0;\n\n        var bytesWritten = 1;\n        var encoder = Encoding.UTF8.GetEncoder();\n        \n        encoder.Convert(new [] { (char)first }, 0, 1, buffer, offset, count, false, out _, out _, out _);\n        while (bytesWritten < count)\n        {\n            bool hasMoreChars;\n            char readChar;\n            \n            if (!(hasMoreChars = TryReadNextChar(out readChar)))\n                break;\n\n            encoder.Convert(new [] { readChar }, 0, 1, buffer, offset + bytesWritten, count - bytesWritten, false, \n                            out int charsUsed, out int byteCount, out bool completed);\n            bytesWritten += byteCount;\n\n            if (!hasMoreChars || !completed)\n                break;\n        }\n\n        return bytesWritten;\n    }\n\n    public override void Write(byte[] buffer, int offset, int count) => throw new NotSupportedException();\n\n    public override long Seek(long offset, SeekOrigin origin) => throw new NotSupportedException();\n\n    public override void SetLength(long value) => throw new NotSupportedException();\n\n    public override void Flush() { }\n}\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n        var xmlContent = "<Root>\u001fInvalid Char</Root>";\n        using (var stringStream = new MemoryStream(Encoding.UTF8.GetBytes(xmlContent)))\n        using (var invalidCharFiltered = new InvalidCharFilteringStream(stringStream))\n        using (var reader = XmlReader.Create(invalidCharFiltered, XmlReaderSettings.CreateDefault()))\n        {\n            while (reader.Read())\n                Console.WriteLine($"{reader.NodeType}: {reader.Name} - {reader.Value}");\n        }\n    }\n}