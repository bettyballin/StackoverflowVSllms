using System;\nusing System.Runtime.InteropServices;\n\npublic class RegistryHelper\n{\n    private const int ERROR_SUCCESS = 0;\n\n    [DllImport("advapi32.dll", CharSet = CharSet.Unicode, EntryPoint = "RegOpenKeyExW", SetLastError = true)]\n    private static extern int RegOpenKeyEx(IntPtr hKey, string lpSubKey, uint ulOptions, int samDesired, out IntPtr phkResult);\n\n    [DllImport("advapi32.dll", CharSet = CharSet.Auto, EntryPoint = "RegQueryValueExW", SetLastError = true)]\n    private static extern int RegQueryValueEx(IntPtr hKey, string lpValueName, IntPtr lpReserved, out uint lpType, IntPtr lpData, ref uint lpcbData);\n\n    [DllImport("advapi32.dll", SetLastError = true)]\n    private static extern int RegCloseKey(IntPtr hKey);\n\n    public enum RegistryHive : uint\n    {\n        HKEY_LOCAL_MACHINE,\n        HKEY_CURRENT_USER,\n    }\n\n    public static object GetRegistryValue(RegistryHive hive, string keyName, string valueName)\n    {\n        IntPtr keyHandle;\n        uint result = (uint)RegOpenKeyEx((IntPtr)hive, keyName, 0, 1, out keyHandle);\n        if (result != ERROR_SUCCESS)\n            throw new Exception("Failed to open registry key: " + Marshal.GetLastWin32Error());\n\n        uint valueType;\n        uint dataSize = 0;\n\n        // Query the size of the data first\n        result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out valueType, IntPtr.Zero, ref dataSize);\n        if (result != ERROR_SUCCESS)\n            throw new Exception("Failed to query registry value size: " + Marshal.GetLastWin32Error());\n\n        object data;\n\n        switch (valueType)\n        {\n            case 1: // REG_SZ\n                data = ReadStringValue(keyHandle, valueName, dataSize);\n                break;\n            case 2: // REG_EXPAND_SZ\n                data = ReadExpandStringValue(keyHandle, valueName, dataSize);\n                break;\n            case 3: // REG_BINARY\n                data = ReadBinaryValue(keyHandle, valueName, dataSize);\n                break;\n            case 4: // REG_DWORD (32-bit)\n                data = ReadDWORDValue(keyHandle, valueName);\n                break;\n            case 7: // REG_MULTI_SZ\n                data = ReadMultiStringValue(keyHandle, valueName, dataSize);\n                break;\n            default:\n                throw new NotSupportedException("Unsupported registry value type.");\n        }\n\n        RegCloseKey(keyHandle);\n        return data;\n    }\n\n    private static string ReadStringValue(IntPtr keyHandle, string valueName, uint dataSize)\n    {\n        IntPtr buffer = Marshal.AllocHGlobal((int)dataSize);\n        try\n        {\n            uint result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out _, buffer, ref dataSize);\n            if (result != ERROR_SUCCESS)\n                throw new Exception("Failed to read string registry value: " + Marshal.GetLastWin32Error());\n            return Marshal.PtrToStringUni(buffer, (int)dataSize / 2); // sizeof(wchar_t) = 2 bytes\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n\n    private static string ReadExpandStringValue(IntPtr keyHandle, string valueName, uint dataSize)\n    {\n        IntPtr buffer = Marshal.AllocHGlobal((int)dataSize);\n        try\n        {\n            uint result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out _, buffer, ref dataSize);\n            if (result != ERROR_SUCCESS)\n                throw new Exception("Failed to read expand string registry value: " + Marshal.GetLastWin32Error());\n            return Marshal.PtrToStringUni(buffer, (int)dataSize / 2); // sizeof(wchar_t) = 2 bytes\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n\n    private static byte[] ReadBinaryValue(IntPtr keyHandle, string valueName, uint dataSize)\n    {\n        byte[] buffer = new byte[dataSize];\n        GCHandle gcHandle = GCHandle.Alloc(buffer, GCHandleType.Pinned);\n        try\n        {\n            IntPtr ptr = gcHandle.AddrOfPinnedObject();\n            uint result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out _, ptr, ref dataSize);\n            if (result != ERROR_SUCCESS)\n                throw new Exception("Failed to read binary registry value: " + Marshal.GetLastWin32Error());\n            return buffer;\n        }\n        finally\n        {\n            gcHandle.Free();\n        }\n    }\n\n    private static uint ReadDWORDValue(IntPtr keyHandle, string valueName)\n    {\n        IntPtr buffer = Marshal.AllocHGlobal(sizeof(uint));\n        try\n        {\n            uint dataSize = sizeof(uint);\n            uint result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out _, buffer, ref dataSize);\n            if (result != ERROR_SUCCESS)\n                throw new Exception("Failed to read DWORD registry value: " + Marshal.GetLastWin32Error());\n            return Marshal.ReadInt32(buffer);\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n\n    private static string[] ReadMultiStringValue(IntPtr keyHandle, string valueName, uint dataSize)\n    {\n        IntPtr buffer = Marshal.AllocHGlobal((int)dataSize);\n        try\n        {\n            uint result = RegQueryValueEx(keyHandle, valueName, IntPtr.Zero, out _, buffer, ref dataSize);\n            if (result != ERROR_SUCCESS)\n                throw new Exception("Failed to read multi-string registry value: " + Marshal.GetLastWin32Error());\n            \n            // Convert the unmanaged memory to a string array\n            int position = 0;\n            var list = new List<string>();\n            while (position < dataSize - sizeof(char))\n            {\n                int len;\n                for (len = 0; ; len++)\n                    if (Marshal.ReadChar(buffer, position + len) == '\0')\n                        break;\n\n                if (len == 0)\n                    break;\n\n                var s = Marshal.PtrToStringUni(IntPtr.Add(buffer, position), len);\n                list.Add(s);\n\n                // Move to the next string\n                position += sizeof(char) * (len + 1);\n            }\n            return list.ToArray();\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n\n    public static void Main()\n    {\n        RegistryHive hive = RegistryHive.HKEY_LOCAL_MACHINE;\n        string keyName = @"SOFTWARE\Microsoft\Windows NT\CurrentVersion";\n        string valueName = "ProductName";\n\n        try\n        {\n            object value = GetRegistryValue(hive, keyName, valueName);\n            Console.WriteLine(value);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine("Error: " + ex.Message);\n        }\n    }\n}