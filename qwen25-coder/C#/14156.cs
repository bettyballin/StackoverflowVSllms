using System;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\n\npublic class DomainCredentialValidator\n{\n    [DllImport("advapi32.dll", SetLastError = true)]\n    public static extern bool LogonUser(\n        string lpszUsername,\n        string lpszDomain,\n        string lpszPassword,\n        int dwLogonType,\n        int dwLogonProvider,\n        out IntPtr phToken);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    public static extern bool CloseHandle(IntPtr hObject);\n\n    private const int LOGON32_LOGON_NETWORK = 3;\n    private const int LOGON32_PROVIDER_DEFAULT = 0;\n\n    public bool ValidateCredentials(string domain, string username, string password)\n    {\n        IntPtr token = IntPtr.Zero;\n        bool result = LogonUser(username, domain, password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, out token);\n\n        if (result)\n        {\n            // We could use the security token here if needed\n            CloseHandle(token);\n        }\n\n        return result;\n    }\n}\n\n// Usage:\ntry\n{\n    DomainCredentialValidator validator = new DomainCredentialValidator();\n    bool isValid = validator.ValidateCredentials("STACKOVERFLOW", "joel", "splotchy");\n    Console.WriteLine(isValid ? "Credentials are valid." : "Invalid credentials.");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine("Failed to validate credentials: " + ex.Message);\n}