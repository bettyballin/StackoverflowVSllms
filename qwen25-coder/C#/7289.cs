using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Security;\n\npublic class NetworkOnlyLogon\n{\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]\n    private static extern bool CreateProcessWithLogonW(\n        string userName,\n        string domainName,\n        IntPtr password,\n        LogonFlags logonFlags,\n        string applicationName,\n        string commandLine,\n        CreateProcessFlags creationFlags,\n        IntPtr environmentBlock,\n        string currentDirectory,\n        ref STARTUPINFO startupInfo,\n        out PROCESS_INFORMATION processInformation);\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct STARTUPINFO\n    {\n        public uint cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public uint dwX;\n        public uint dwY;\n        public uint dwXSize;\n        public uint dwYSize;\n        public uint dwXCountChars;\n        public uint dwYCountChars;\n        public uint dwFillAttribute;\n        public STARTFFlags dwFlags;\n        public short wShowWindow;\n        public short cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public uint dwProcessId;\n        public uint dwThreadId;\n    }\n\n    [Flags]\n    private enum LogonFlags\n    {\n        LOGON_WITH_PROFILE = 0x1,\n        LOGON_NETCREDENTIALS_ONLY = 0x2\n    }\n\n    [Flags]\n    private enum CreateProcessFlags : uint\n    {\n        ZERO_FLAG = 0x0,\n        CREATE_UNICODE_ENVIRONMENT = 0x400\n    }\n\n    [Flags]\n    private enum STARTFFlags : uint\n    {\n        USESHOWWINDOW = 0x1\n    }\n\n    public void RunAsNetworkUser(string domain, string username, SecureString password, string applicationName)\n    {\n        var si = new STARTUPINFO { cb = (uint)Marshal.SizeOf(typeof(STARTUPINFO)) };\n        var pi = new PROCESS_INFORMATION();\n        \n        IntPtr pwd = Marshal.SecureStringToGlobalAllocUnicode(password);\n        \n        try\n        {\n            if (!CreateProcessWithLogonW(\n                username,\n                domain,\n                pwd,\n                LogonFlags.LOGON_NETCREDENTIALS_ONLY,\n                applicationName,\n                null,\n                CreateProcessFlags.CREATE_UNICODE_ENVIRONMENT | CreateProcessFlags.ZERO_FLAG,\n                IntPtr.Zero,\n                null,\n                ref si,\n                out pi))\n            {\n                int error = Marshal.GetLastWin32Error();\n                throw new Exception($"Failed to create process. Error: {error}");\n            }\n        }\n        finally\n        {\n            Marshal.ZeroFreeGlobalAllocUnicode(pwd);\n            if (pi.hThread != IntPtr.Zero)\n            {\n                CloseHandle(pi.hThread);\n            }\n            if (pi.hProcess != IntPtr.Zero)\n            {\n                CloseHandle(pi.hProcess);\n            }\n        }\n    }\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool CloseHandle(IntPtr hObject);\n}\n\n// Usage:\n// NetworkOnlyLogon logon = new NetworkOnlyLogon();\n// logon.RunAsNetworkUser("DOMAIN", "username", securePassword, @"path\to\your\application.exe");