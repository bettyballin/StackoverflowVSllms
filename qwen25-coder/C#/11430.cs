using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\n\npublic class ImpersonatedProcessStarter\n{\n    [StructLayout(LayoutKind.Sequential)]\n    private struct SECURITY_ATTRIBUTES\n    {\n        public int Length;\n        public IntPtr lpSecurityDescriptor;\n        public bool bInheritHandle;\n    }\n\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]\n    private static extern bool CreateProcessWithLogonW(\n            string userName,\n            string domainName,\n            string password,\n            int logonFlags,\n            string applicationName,\n            string commandLine,\n            uint creationFlags,\n            IntPtr environment,\n            string currentDirectory,\n            ref SECURITY_ATTRIBUTES securityAttributes,\n            out STARTUPINFO startupInfo,\n            out PROCESS_INFORMATION processInformation);\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct STARTUPINFO\n    {\n        public int cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public uint dwX;\n        public uint dwY;\n        public uint dwXSize;\n        public uint dwYSize;\n        public uint dwXCountChars;\n        public uint dwYCountChars;\n        public uint dwFillAttribute;\n        public STARTF dwFlags;\n        public short wShowWindow;\n        public short cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public uint dwProcessId;\n        public uint dwThreadId;\n    }\n\n    [Flags]\n    private enum STARTF : uint\n    {\n        UseStdHandles = 0x00000100,\n    }\n\n    public int StartProcessAsUser(string username, string domain, string password, string applicationName, string commandLine)\n    {\n        SECURITY_ATTRIBUTES securityAttributes = new SECURITY_ATTRIBUTES();\n        PROCESS_INFORMATION processInformation;\n        STARTUPINFO startupInfo = new STARTUPINFO\n        {\n            cb = Marshal.SizeOf(typeof(STARTUPINFO)),\n            dwFlags = STARTF.UseStdHandles,\n            hStdInput = GetStdHandle(STD_INPUT_HANDLE),\n            hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE),\n            hStdError = GetStdHandle(STD_ERROR_HANDLE)\n        };\n        securityAttributes.Length = Marshal.SizeOf(typeof(SECURITY_ATTRIBUTES));\n\n        bool result = CreateProcessWithLogonW(\n                username,\n                domain,\n                password,\n                0, // LOGON_WITH_PROFILE\n                applicationName,\n                commandLine,\n                CREATE_UNICODE_ENVIRONMENT | CREATE_NO_WINDOW,\n                IntPtr.Zero,\n                null,\n                ref securityAttributes,\n                out startupInfo,\n                out processInformation);\n\n        if (!result)\n            throw new InvalidOperationException("CreateProcessWithLogonW failed!");\n\n        // Handle reading output here\n        using (var process = Process.GetProcessById((int)processInformation.dwProcessId))\n        {\n            string output = process.StandardOutput.ReadToEnd();\n            process.WaitForExit();\n\n            Console.WriteLine(output);\n            return process.ExitCode;\n        }\n    }\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr GetStdHandle(int nStdHandle);\n\n    private const int STD_INPUT_HANDLE = -10;\n    private const int STD_OUTPUT_HANDLE = -11;\n    private const int STD_ERROR_HANDLE = -12;\n\n    private const uint CREATE_UNICODE_ENVIRONMENT = 0x00000400;\n    private const uint CREATE_NO_WINDOW = 0x08000000;\n}