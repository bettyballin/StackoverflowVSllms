using System;\nusing System.IO;\n\nprivate static bool IsFileAccessReady(string fileName, TimeSpan waitFor)\n{\n    var lastWriteTime = DateTime.Now;\n    try\n    {\n        // Check the file's last write time multiple times to ensure it's stable.\n        for (int retries = 0; retries < 3; retries++)\n        {\n            if (!File.Exists(fileName))\n            {\n                return false;\n            }\n            \n            var newWriteTime = File.GetLastWriteTimeUtc(fileName);\n            if (retries > 0 && lastWriteTime == newWriteTime)\n            {\n                // If the file's write time hasn't changed for the retries, assume it's stable\n                break;\n            }\n            else if (DateTime.UtcNow - newWriteTime < waitFor)\n            {\n                // If the latest modification is within the waiting period, return false.\n                return false;\n            }\n\n            lastWriteTime = newWriteTime;\n            System.Threading.Thread.Sleep(100); // Small delay to avoid busy-waiting\n        }\n    }\n    catch (Exception ex)\n    {\n        // Handle possible exceptions from file access (e.g., directory doesn't exist)\n        Console.WriteLine("Error checking file status: " + ex.Message);\n        return false;\n    }\n\n    try\n    {\n        using (FileStream inputStream = File.Open(fileName, FileMode.Open, FileAccess.Read, FileShare.None))\n        {\n            return true;\n        }\n    }\n    catch (IOException)\n    {\n        // The file is still locked.\n        return false;\n    }\n}