// Define an interface that all controllers should implement; it's also marked as a metadata attribute.\n[MetadataAttribute]\npublic class ExportControllerMetadata : Attribute\n{\n    public string ControllerName { get; set; }\n}\n\n// Example plugin controller\n[Export(typeof(IPluginController), Metadata = "Plugins.MyPlugin.Controllers")]\npublic class MyPluginController : ControllerBase, IPluginController, IHaveCustomRouting\n{\n    // Implement your controller actions here\n}\n\n// Interface to signal that controllers should be loaded dynamically.\npublic interface IPluginController {}\n\n// Dynamic registration of MEF controllers in the startup\npublic class PluginBootstrapper\n{\n    private readonly CompositionContainer _container;\n\n    public PluginBootstrapper()\n    {\n        var catalog = new AggregateCatalog();\n        // Add your directories here where plugins are located\n        catalog.Catalogs.Add(new DirectoryCatalog(AppDomain.CurrentDomain.BaseDirectory + @"\Plugins\"));\n        \n        _container = new CompositionContainer(catalog);\n    }\n\n    public void ComposeParts()\n    {\n        _container.ComposeParts(this);\n\n        var controllers = _container.GetExportedValues<IPluginController>();\n        foreach (var controller in controllers)\n        {\n            // Register each discovered plugin controller with the MVC routing\n            var metadata = _container.GetExport(controller, MetadataName).Metadata;\n            var metadataValue = (IDictionary<string, object>)metadata[typeof(ExportControllerMetadata).FullName];\n            var routePrefix = metadataValue.TryGetValue("ControllerName", out object value) ? value.ToString() : "";\n\n            // Assuming a simple convention for registering routes\n            RouteTable.Routes.MapRoute(\n                name: routePrefix,\n                url: routePrefix + "/{action}/{id}",\n                defaults: new { controller = routePrefix, action = "Index", id = UrlParameter.Optional }\n            );\n        }\n    }\n}