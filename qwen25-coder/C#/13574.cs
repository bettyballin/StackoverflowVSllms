using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main()\n    {\n        var transactions = new List<int> { 2, 4, 5, 7 };\n        int targetSum = 13;\n        \n        var result = FindSubset(transactions, targetSum);\n        if (result == null)\n            Console.WriteLine("No subset found.");\n        else\n            Console.WriteLine($"Subset: {string.Join(", ", result)}");\n    }\n\n    static List<int> FindSubset(List<int> transactions, int targetSum)\n    {\n        // Dictionary to store the results of subproblems\n        var memo = new Dictionary<(int index, int sum), List<int>>();\n        \n        return RecursiveFind(transactions, targetSum, 0, memo);\n    }\n\n    static List<int> RecursiveFind(List<int> transactions, int remainingSum, int currentIndex, Dictionary<(int index, int sum), List<int>> memo)\n    {\n        // Base cases\n        if (remainingSum == 0) \n            return new List<int>(); // Found a valid subset\n\n        if (currentIndex >= transactions.Count || remainingSum < 0) \n            return null; // No solution found\n        \n        // Check if already computed\n        var key = (currentIndex, remainingSum);\n        if (memo.ContainsKey(key)) \n            return memo[key];\n\n        // Recursive case: include the current transaction\n        var includingCurrent = new List<int>(RecursiveFind(transactions, remainingSum - transactions[currentIndex], currentIndex + 1, memo));\n        if (includingCurrent != null)\n        {\n            includingCurrent.Add(transactions[currentIndex]);\n            memo[key] = includingCurrent;\n            return includingCurrent;\n        }\n\n        // Recursive case: exclude the current transaction\n        var excludingCurrent = RecursiveFind(transactions, remainingSum, currentIndex + 1, memo);\n        \n        // Store the result in cache\n        memo[key] = excludingCurrent;\n\n        return excludingCurrent;\n    }\n}