using System;\nusing System.Collections.Generic;\nusing System.Reflection;\n\npublic class Address\n{\n    public string Street { get; set; }\n    public string Country { get; set; }\n}\n\npublic class Client\n{\n    public int No { get; set; }\n    public string Name { get; set; }\n    public Address Address { get; set; }\n}\n\npublic static class PermutationGenerator\n{\n    private static readonly Dictionary<Type, IEnumerable<object>> _typeValuesMap = new Dictionary<Type, IEnumerable<object>>\n    {\n        { typeof(int), new List<int> { -1, 0, 1 } },\n        { typeof(string), new List<string> { null, string.Empty, "Hello World" } }\n    };\n\n    public static IEnumerable<T> GetPermutations<T>()\n    {\n        return (IEnumerable<T>)GetPermutations(typeof(T));\n    }\n\n    private static IEnumerable<object> GetPermutations(Type myType)\n    {\n        if (_typeValuesMap.TryGetValue(myType, out var list))\n            foreach (var value in list)\n                yield return value;\n\n        if (!myType.IsClass || myType == typeof(string))\n            yield break;\n\n        foreach (var perm in GeneratePermutationsForClass(myType))\n            yield return perm;\n    }\n\n    private static IEnumerable<object> GeneratePermutationsForClass(Type classType)\n    {\n        var result = new List<object>();\n        FillProperties(classType, 0, new List<object>(), result);\n        return result;\n    }\n\n    private static void FillProperties(Type type, int currentPropertyIndex, List<object> currentPath, List<object> resultList)\n    {\n        var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);\n\n        if (currentPropertyIndex == properties.Length)\n        {\n            resultList.Add(CreateObjectWithValues(type, currentPath));\n            return;\n        }\n\n        var property = properties[currentPropertyIndex];\n        var possibleValues = GetPermutations(property.PropertyType);\n\n        foreach (var value in possibleValues)\n        {\n            currentPath.Add(value);\n            FillProperties(type, currentPropertyIndex + 1, currentPath, resultList);\n            currentPath.RemoveAt(currentPath.Count - 1);\n        }\n    }\n\n    private static object CreateObjectWithValues(Type type, List<object> values)\n    {\n        var obj = Activator.CreateInstance(type);\n        int index = 0;\n        foreach (var property in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))\n        {\n            if (index >= values.Count) break; // Safeguard against incorrect number of properties\n            property.SetValue(obj, values[index++]);\n        }\n        return obj;\n    }\n\n    public static void Main()\n    {\n        var permutations = GetPermutations<Client>();\n        foreach (var client in permutations)\n        {\n            Console.WriteLine("No: " + (client as Client)?.No);\n            Console.WriteLine("Name: " + (client as Client)?.Name);\n            Console.WriteLine("Address.Street: " + ((client as Client)?.Address?.Street ?? "(null)"));\n            Console.WriteLine("Address.Country: " + ((client as Client)?.Address?.Country ?? "(null)"));\n            Console.WriteLine();\n        }\n    }\n}