using System;\nusing System.Runtime.InteropServices;\n\npublic class FileHelper\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr OpenFileMapping(uint dwDesiredAccess, bool bInheritHandle, string lpName);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr MapViewOfFile(IntPtr hFileMappingObject, uint dwDesiredAccess, uint dwFileOffsetHigh, uint dwFileOffsetLow, uint dwNumberOfBytesToMap);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool UnmapViewOfFile(IntPtr lpBaseAddress);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool CloseHandle(IntPtr hObject);\n\n    [DllImport("psapi.dll", SetLastError = true)]\n    private static extern uint GetMappedFileName(IntPtr hProcess, IntPtr lpv, [Out] char[] lpszFilename, uint nSize);\n\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr GetCurrentProcess();\n\n    private const uint FILE_MAP_ALL_ACCESS = 0xF001F;\n\n    public static int? GetFileLockingProcessId(string filePath)\n    {\n        using (var fileStream = new System.IO.FileStream(filePath, System.IO.FileMode.Open, System.IO.FileAccess.ReadWrite, System.IO.FileShare.None))\n        {\n            return null; // If the above line succeeds, no other process has a lock on this file.\n        }\n        catch (System.IO.IOException ex) when ((uint)ex.HResult == 0x80070020)\n        {\n            var kernel32 = Interop.Kernel32.OpenFileMapping(FILE_MAP_ALL_ACCESS, false, filePath);\n            if (kernel32 == IntPtr.Zero)\n                return null;\n\n            try\n            {\n                var mapViewOfFile = MapViewOfFile(kernel32, FILE_MAP_ALL_ACCESS, 0, 0, 1024 * 64);\n                if (mapViewOfFile == IntPtr.Zero)\n                    return null;\n\n                try\n                {\n                    var currentProcessHandle = GetCurrentProcess();\n                    char[] fileNameBuffer = new char[1024];\n                    int fileNameLength = Interop.Psapi.GetMappedFileName(currentProcessHandle, mapViewOfFile, fileNameBuffer, 1024);\n                    if (fileNameLength <= 0)\n                        return null;\n\n                    string filePathInUse = new string(fileNameBuffer.TakeWhile(c => c != '\0').ToArray());\n                    var processName = new System.IO.FileInfo(filePathInUse).Name;\n                    \n                    IntPtr[] arrayOfProcessIds = new IntPtr[1024];\n                    int cbNeeded;\n\n                    Interop.Psapi.EnumProcesses(arrayOfProcessIds, Marshal.SizeOf(typeof(IntPtr)) * arrayOfProcessIds.Length, out cbNeeded);\n\n                    for (int i = 0; i < (cbNeeded / Marshal.SizeOf(typeof(IntPtr))); i++)\n                    {\n                        IntPtr processHandle = Interop.Kernel32.OpenProcess(Interop.Kernel32.ProcessQueryLimitedInformation, false, Convert.ToInt32(arrayOfProcessIds[i]));\n                        if (processHandle != IntPtr.Zero)\n                        {\n                            try\n                            {\n                                string procFileName;\n                                using (var moduleNameInfo = new System.Diagnostics.ProcessModule())\n                                {\n                                    if (Interop.Psapi.GetModuleFileNameExW(processHandle, IntPtr.Zero, out procFileName, 1024) > 0)\n                                    {\n                                        if (string.Equals(System.IO.Path.GetFileName(procFileName), processName, StringComparison.OrdinalIgnoreCase))\n                                            return Convert.ToInt32(arrayOfProcessIds[i]);\n                                    }\n                                }\n                            }\n                            finally\n                            {\n                                CloseHandle(processHandle);\n                            }\n                        }\n                    }\n                }\n                finally\n                {\n                    UnmapViewOfFile(mapViewOfFile);\n                }\n            }\n            finally\n            {\n                CloseHandle(kernel32);\n            }\n        }\n\n        return null;\n    }\n\n    private static class Interop\n    {\n        public static class Kernel32\n        {\n            [DllImport("kernel32.dll", SetLastError = true)]\n            public static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);\n\n            public const uint ProcessQueryLimitedInformation = 0x1000;\n        }\n\n        public static class Psapi\n        {\n            [DllImport("psapi.dll", SetLastError = true)]\n            [return: MarshalAs(UnmanagedType.Bool)]\n            public static extern bool EnumProcesses([Out] IntPtr[] lphProcess, int cb, out int cbNeeded);\n\n            [DllImport("psapi.dll", CharSet = CharSet.Unicode, SetLastError = true)]\n            [return: MarshalAs(UnmanagedType.U4)]\n            public static extern uint GetModuleFileNameExW(IntPtr hProcess, IntPtr hModule, [MarshalAs(UnmanagedType.LPStr)] out string lpBaseName, [In] [MarshalAs(UnmanagedType.U4)] int nSize);\n        }\n    }\n}