using System;\nusing System.Net.Security;\nusing System.Security.Cryptography.X509Certificates;\n\npublic class SslServer\n{\n    private static readonly X509Store AllowedClientCerts = new X509Store(StoreName.My, StoreLocation.CurrentUser);\n\n    public void StartSslStream(Stream innerStream, X509Certificate serverCertificate)\n    {\n        AllowedClientCerts.Open(OpenFlags.ReadOnly);\n        var sslStream = new SslStream(innerStream, false, RemoteCertificateValidationCallback, LocalCertificateSelectionCallback);\n        try\n        {\n            sslStream.AuthenticateAsServer(serverCertificate, true, SslProtocols.Default, false);\n        }\n        finally\n        {\n            AllowedClientCerts.Close();\n        }\n    }\n\n    private static bool RemoteCertificateValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)\n    {\n        if (sslPolicyErrors != SslPolicyErrors.None) return false;\n\n        // Check if the certificate is in the allowed list\n        var cert = new X509Certificate2(certificate);\n        foreach (X509Certificate2 allowedCert in AllowedClientCerts.Certificates)\n        {\n            if (allowedCert.Thumbprint == cert.Thumbprint)\n                return true;\n        }\n\n        return false;\n    }\n\n    private static X509Certificate LocalCertificateSelectionCallback(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers)\n    {\n        foreach (X509Certificate cert in localCertificates)\n        {\n            if (cert.Issuer == remoteCertificate?.Issuer || string.IsNullOrEmpty(remoteCertificate?.Issuer))\n            {\n                return cert;\n            }\n        }\n\n        return localCertificates[0]; // Fallback to the first certificate\n    }\n}