using System;\nusing System.Data.SqlClient;\n\npublic class SafeSqlExecution {\n    private static bool IsAllowedCommand(string command) {\n        // Use .Trim() and .ToLowerInvariant() for normalized comparison.\n        var cmd = command.Trim().ToLowerInvariant();\n        return cmd.StartsWith("select ") || cmd.StartsWith("update ");\n    }\n\n    private static bool ValidateNoBatchQueries(string query) {\n        // This is a simple example, in practice use more robust parsing.\n        int firstSemiIndex = query.IndexOf(';');\n        if (firstSemiIndex > -1) {\n            string afterSemi = query.Substring(firstSemiIndex + 1).Trim();\n            return afterSemi.Length == 0 || !char.IsLetterOrDigit(afterSemi[0]);\n        }\n        return true;\n    }\n\n    public static void ExecuteUserQuery(string userInput, SqlConnection conn) {\n        if (!IsAllowedCommand(userInput)) {\n            throw new ArgumentException("Invalid SQL command.");\n        }\n\n        if (!ValidateNoBatchQueries(userInput)) {\n            throw new ArgumentException("Detected multiple queries in one statement (batch query).");\n        }\n\n        // Substitute table names and other user input safety checks here.\n        string safeQuery = SanitizeAndSubstitute(userInput);\n        \n        using (SqlCommand cmd = new SqlCommand(safeQuery, conn)) {\n            cmd.ExecuteNonQuery();\n        }\n    }\n\n    private static string SanitizeAndSubstitute(string query) {\n        // Implement your logic to sanitize and substitute table names etc. here.\n        // This is a placeholder for your implementation logic.\n        return query;\n    }\n}