using Org.BouncyCastle.Cryptography.Digests;\nusing System;\n\npublic class UniqueIdGenerator\n{\n    public static string GenerateShortUniqueId()\n    {\n        // Generate a cryptographic hash of some unique data, such as GUID and timestamp\n        var guid = Guid.NewGuid().ToByteArray();\n        var timeBytes = BitConverter.GetBytes(DateTime.UtcNow.ToBinary());\n        \n        var combinedBytes = new byte[guid.Length + timeBytes.Length];\n        Buffer.BlockCopy(guid, 0, combinedBytes, 0, guid.Length);\n        Buffer.BlockCopy(timeBytes, 0, combinedBytes, guid.Length, timeBytes.Length);\n\n        using (var sha1 = new Sha1Digest())\n        {\n            var hashBytes = new byte[sha1.GetDigestSize()];\n            sha1.BlockUpdate(combinedBytes, 0, combinedBytes.Length);\n            sha1.DoFinal(hashBytes, 0);\n\n            // Encode the hash to a Base32 string\n            return ConvertToBase32(hashBytes).Substring(0, 8); // Take first 8 characters for shorter ID\n        }\n    }\n\n    private static string ConvertToBase32(byte[] bytes)\n    {\n        const string base32Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";\n        var result = new char[bytes.Length * 8 / 5];\n        int bitIndex, charIndex = 0;\n        for (var byteIndex = 0; byteIndex < bytes.Length; ++byteIndex)\n        {\n            for (bitIndex = 0; bitIndex <= 3; ++bitIndex)\n                result[charIndex++] =\n                    base32Chars[(bytes[byteIndex] >> ((3 - bitIndex) * 5 + 3)) & 31];\n            if (byteIndex + 1 < bytes.Length)\n                result[charIndex++] =\n                    base32Chars[(bytes[byteIndex] << 2 | bytes[byteIndex + 1] >> 6) & 31];\n        }\n        return new string(result);\n    }\n\n    public static void Main()\n    {\n        Console.WriteLine(GenerateShortUniqueId());\n    }\n}