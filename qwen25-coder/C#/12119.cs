using System;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static void Main()\n    {\n        // Start the async task for handling console output.\n        Task.Run(() => OutputHandler());\n\n        Console.WriteLine("Type commands or 'exit' to quit.");\n\n        // Handle input in a loop until the user types "exit".\n        while (true)\n        {\n            var keyInfo = Console.ReadKey(intercept: true);\n            if (keyInfo.Key == ConsoleKey.Enter)\n            {\n                string command = new string(buffer.ToArray());\n                buffer.Clear();\n                if (command.ToLower() == "exit")\n                {\n                    break;\n                }\n                ExecuteCommand(command);\n            }\n            else\n            {\n                buffer.Add(keyInfo.KeyChar);\n                WriteBufferToConsole();\n            }\n        }\n    }\n\n    private static char[] buffer = new char[256];\n    private static int bufferSize = 0;\n\n    private static async Task OutputHandler()\n    {\n        while (true)\n        {\n            await Task.Delay(1000); // Simulate a delay between outputs\n            WriteConsoleLine("Server: New message");\n        }\n    }\n\n    private static void ExecuteCommand(string command)\n    {\n        Console.WriteLine($"\nExecuting: {command}");\n        // Add your command execution logic here.\n    }\n\n    private static void WriteBufferToConsole()\n    {\n        if (bufferSize > 0)\n        {\n            Console.SetCursorPosition(0, Console.CursorTop);\n            Console.Write(new string(buffer));\n        }\n    }\n\n    private static void WriteConsoleLine(string message)\n    {\n        var currentCursorLeft = Console.CursorLeft;\n        var currentCursorTop = Console.CursorTop;\n\n        Console.SetCursorPosition(0, Console.WindowHeight - 1);\n        Console.Write(message.PadRight(Console.WindowWidth));\n        Console.SetCursorPosition(currentCursorLeft, currentCursorTop);\n    }\n}