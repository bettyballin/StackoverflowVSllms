using System;\nusing System.Linq.Expressions;\n\npublic class DslParser<T>\n{\n    public Expression<Func<T, bool>> Parse(string dslExpression)\n    {\n        // This is a simplified version and might not cover all cases.\n        // It expects very simple expressions in the format "Property1 == Value && Property2 != Value"\n        var parameterEx = Expression.Parameter(typeof(T), "t");\n        var propNamesAndValues = dslExpression.Split(new[] { "&&" }, StringSplitOptions.RemoveEmptyEntries);\n\n        Expression combineExpr = null;\n        foreach (var part in propNamesAndValues)\n        {\n            var parts = part.Trim().Split(' ');\n            var propertyName = parts[0].Trim();\n            var op = parts[1].Trim();\n            var valueStr = parts[2].Trim();\n\n            dynamic value = Convert.ChangeType(valueStr, typeof(T).GetProperty(propertyName).PropertyType);\n            \n            Expression leftEx = Expression.Property(parameterEx, propertyName);\n            Expression rightEx = Expression.Constant(value);\n\n            BinaryExpression comparisonExpr;\n            switch (op)\n            {\n                case "==":\n                    comparisonExpr = Expression.Equal(leftEx, rightEx);\n                    break;\n                case "!=":\n                    comparisonExpr = Expression.NotEqual(leftEx, rightEx);\n                    break;\n                default: throw new ArgumentException($"Operator {op} not supported");\n            }\n\n            combineExpr = combineExpr == null ? (Expression)comparisonExpr : Expression.AndAlso(combineExpr, comparisonExpr);\n        }\n\n        return Expression.Lambda<Func<T, bool>>(combineExpr, parameterEx);\n    }\n}