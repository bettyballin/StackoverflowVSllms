#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n#include <stdio.h>\n\nvoid PrintProcessCommandLine(DWORD pid) {\n    HANDLE hProcess;\n    TCHAR CommandLine[MAX_PATH] = TEXT("<unknown>");\n\n    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |\n                            PROCESS_VM_READ,\n                            FALSE, pid);\n    if (NULL != hProcess) {\n        HMODULE hMod;\n        DWORD cbNeeded;\n\n        if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {\n            GetModuleBaseName(hProcess, hMod, CommandLine, sizeof(CommandLine)/sizeof(TCHAR));\n            // Now get the command line\n            DWORD size = GetCommandLineA().length() + 1;\n            char* cmdLine = new char[size];\n            if (QueryFullProcessImageNameA(hProcess, 0, cmdLine, &size)) {\n                printf("PID: %u Command Line: %s\n", pid, cmdLine);\n            }\n            delete[] cmdLine;\n        }\n\n        CloseHandle(hProcess);\n    } else {\n        printf("Failed to open process with PID: %u\n", pid);\n    }\n}\n\nint main(void) {\n    DWORD aProcesses[1024], cbNeeded, cProcesses;\n\n    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded)) {\n        return 1;\n    }\n\n    cProcesses = cbNeeded / sizeof(DWORD);\n\n    for (unsigned int i = 0; i < cProcesses; i++) {\n        if (aProcesses[i] != 0) {\n            PrintProcessCommandLine(aProcesses[i]);\n        }\n    }\n}