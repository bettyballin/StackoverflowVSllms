#include <memory>\n#include <mutex>\n\nclass ThreadSafeAllocator {\npublic:\n    template <typename T>\n    T* allocate(std::size_t n) {\n        std::lock_guard<std::mutex> lock(mutex_);\n        return static_cast<T*>(::operator new(n * sizeof(T)));\n    }\n\n    template <typename T>\n    void deallocate(T* p, std::size_t /*n*/) noexcept {\n        std::lock_guard<std::mutex> lock(mutex_);\n        ::operator delete(p);\n    }\nprivate:\n    std::mutex mutex_;\n};\n\n// Usage with smart pointers\n#include <iostream>\n#include <vector>\n\nint main() {\n    ThreadSafeAllocator allocator;\n    auto vec = std::allocate_shared<std::vector<int>>(std::pmr::polymorphic_allocator<std::byte>{&allocator});\n    vec->push_back(10);\n    std::cout << (*vec)[0] << std::endl;\n}