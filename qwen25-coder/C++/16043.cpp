#include <zmq.hpp>\n#include <string>\n#include <iostream>\n#include <thread>\n\nvoid worker_thread(zmq::context_t * context, int id) {\n    zmq::socket_t socket(*context, ZMQ_PULL);\n    std::string addr = "inproc://workers";\n    socket.connect(addr.c_str());\n\n    while (true) {\n        zmq::message_t request;\n\n        // Block until a message is received\n        socket.recv(request, zmq::recv_flags::none);\n        \n        // Process the received message\n        std::cout << "Worker " << id << " processed: [" \n                  << static_cast<char*>(request.data()) << "]" << std::endl;\n    }\n}\n\nint main() {\n    zmq::context_t context(1);\n    \n    // Socket to send messages on\n    zmq::socket_t sender(context, ZMQ_PUSH);\n    sender.bind("inproc://workers");\n\n    // Launch pool of worker threads\n    const int num_workers = 5;\n    std::vector<std::thread> workers;\n    for (int i = 0; i < num_workers; ++i) {\n        workers.emplace_back(worker_thread, &context, i);\n    }\n\n    // Send a batch of tasks to the workers\n    const int task_nbr = 10;\n    std::cout << "Sending tasks to workersâ€¦" << std::endl;\n    for (int task_nbr = 0; task_nbr < 10; task_nbr++) {\n        zmq::message_t message(5);\n        memcpy(message.data(), "Hello", 5);\n\n        // Send the message\n        sender.send(message, zmq::send_flags::none);\n    }\n\n    // Wait for all workers to finish their tasks\n    std::for_each(workers.begin(), workers.end(), [](std::thread &th) {\n        th.join();\n    });\n\n    return 0;\n}