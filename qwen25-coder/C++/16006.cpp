using Graph = boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS>;\n\nstd::pair<Graph::vertex_descriptor, Graph::vertex_descriptor>\nfindClosestNodesBetweenCommunities(const Graph& g, const std::vector<std::set<Graph::vertex_descriptor>>& communities) {\n    double min_distance = std::numeric_limits<double>::max();\n    std::pair<Graph::vertex_descriptor, Graph::vertex_descriptor> closest_pair;\n\n    for (size_t i = 0; i < communities.size(); ++i) {\n        for (size_t j = i + 1; j < communities.size(); ++j) {\n            for (auto vi : communities[i]) {\n                for (auto vj : communities[j]) {\n                    // Calculate the shortest path between vi and vj\n                    std::vector<Graph::vertex_descriptor> p(num_vertices(g));\n                    // Use Dijkstra's algorithm to find the shortest path\n                    boost::dijkstra_shortest_paths(g, vi,\n                                                  boost::predecessor_map(&p[0]).distance_map(boost::make_iterator_property_map(distance.begin(), get(boost::vertex_index, g))));\n                    \n                    double distance = computePathDistance(p(vj), g);\n                    if (distance < min_distance) {\n                        min_distance = distance;\n                        closest_pair = {vi, vj};\n                    }\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}