#include <iostream>\n\nvoid swapRows(float *a, float *b, int cols) {\n    for (int c = 0; c < cols; ++c)\n        std::swap(a[c], b[c]);\n}\n\nbool invert4x4Matrix(float *mat) {\n    float inv[16] = {1, 0, 0, 0, \n                     0, 1, 0, 0, \n                     0, 0, 1, 0, \n                     0, 0, 0, 1}; // Identity matrix\n    \n    for (int r = 0; r < 4; ++r) {\n        if (mat[r * 4 + r] == 0) { // Singular matrix case\n            for (int rr = r + 1; rr < 4; ++rr) {\n                if (mat[rr * 4 + r]) {\n                    swapRows(mat + r * 4, mat + rr * 4, 4);\n                    swapRows(inv + r * 4, inv + rr * 4, 4);\n                    break;\n                }\n            }\n        }\n        \n        float f = mat[r * 4 + r];\n        if (f == 0) // Still singular\n            return false;\n\n        for (int c = 0; c < 4; ++c) {\n            mat[r * 4 + c] /= f;\n            inv[r * 4 + c] /= f;\n        }\n\n        for (int rr = 0; rr < 4; ++rr) { // Eliminate other rows\n            if (rr != r) {\n                float coeff = -mat[rr * 4 + r];\n                for (int cc = 0; cc < 4; ++cc) {\n                    mat[rr * 4 + cc] += coeff * mat[r * 4 + cc];\n                    inv[rr * 4 + cc] += coeff * inv[r * 4 + cc];\n                }\n            }\n        }\n    }\n\n    // Copy inverse matrix back to original space\n    for (int i = 0; i < 16; ++i)\n        mat[i] = inv[i];\n\n    return true;\n}\n\nvoid printMatrix(const float *mat) {\n    for (int r = 0; r < 4; ++r) {\n        std::cout << "[";\n        for (int c = 0; c < 4; ++c)\n            std::cout << mat[r * 4 + c] << ((c < 3) ? ", " : "");\n        std::cout << "]" << std::endl;\n    }\n}\n\nint main() {\n    float mat[16] = { /* Input matrix here, in column-major order */ };\n    \n    if (invert4x4Matrix(mat)) {\n        printMatrix(mat); // Prints the inverted matrix\n    } else {\n        std::cerr << "Matrix is singular and cannot be inverted." << std::endl;\n    }\n    \n    return 0;\n}