// Include necessary headers\n#include <e32base.h>     // Basic definitions and classes\n#include <sipclient.sdp.h> // For SDP processing\n#include <sipclien.h>   // SIP client API\n\n// Class that handles SIP sessions\nclass CSIPCallHandler : public CBase, \n                    MClientObserver,\n                    MSIPClientDialogObserver {\npublic:\n    static CSIPCallHandler* NewL(RWsSession& aSess);\n    ~CSIPCallHandler();\n\nprivate:\n    void ConstructL(RWsSession& aSess);\n    CSIPCallHandler();\n\npublic:\n    // Function to initiate a call\n    void StartCall(const TDesC& aUri);\n\nprivate: // From MSIPClientDialogObserver\n    void DialogStateChangeEvent(CSIPClientDialog* aSender, TInt aError,\n                                TSIPDialogState aNewState);\n    void NewResponseReceived(CSIPClientDialog* aSender, const TDesC8& aResponse,\n                            TInt aError);\n\nprivate:\n    RSISConnection iRisConnection;\n    CSIPClient* iSipClient;\n};\n\n// Implementation of CSIPCallHandler\n\nCSIPCallHandler::CSIPCallHandler() :\niRisConnection()\n{\n}\n\nvoid CSIPCallHandler::ConstructL(RWsSession& aSess)\n{\n    User::LeaveIfError(iRisConnection.Connect());\n    CleanupClosePushL(iRisConnection);\n    \n    iSipClient = CSIPClient::NewL(aSess, *this);\n    CleanupStack::Pop(1); // Take ownership of iSipClient from cleanup stack\n}\n\nCSIPCallHandler* CSIPCallHandler::NewL(RWsSession& aSess)\n{\n    CSIPCallHandler* self = new(ELeave) CSIPCallHandler();\n    CleanupPushL(self);\n    self->ConstructL(aSess);\n    CleanupPop();\n    return self;\n}\n\nvoid CSIPCallHandler::StartCall(const TDesC& aUri)\n{\n    // Create URI object\n    RSIPUri uri = iRisConnection.UriOpenLC(aUri);\n\n    // Create dialog for outgoing call\n    CSIPClientDialog* dialog = CSIPClientDialog::NewL(*iSipClient, uri);\n    CleanupStack::PushL(dialog);    \n\n    // Send INVITE to initiate the call\n    dialog->InviteNoResponseL();\n\n    // Clean up URI object and dialog handling is now caller's responsibility\n    CleanupStack::PopAndDestroy(&uri);\n}\n\nCSIPCallHandler::~CSIPCallHandler()\n{\n    delete iSipClient;\n    iRisConnection.Close();\n}\n\nvoid CSIPCallHandler::DialogStateChangeEvent(CSIPClientDialog* /*aSender*/, TInt aError,\n                                            TSIPDialogState /*aNewState*/)\n{\n    User::LeaveIfError(aError);\n}\n\nvoid CSIPCallHandler::NewResponseReceived(CSIPClientDialog* aSender, const TDesC8& aResponse,\n                                          TInt aError)\n{\n    if (aError != KErrNone) {\n        User::Leave(aError);\n    }\n    if (!aResponse.LocateF(_L8("200 OK"), 3).IsNull()) {\n        // Handle successful response here\n        _LIT(KAnswer, "Call answered successfully");\n        CEikonEnv::Static()->InfoWinL(_L("SIP Call"), KAnswer);\n    }\n}\n\n// Usage in your application, for example in AppUi class or main function:\nRWsSession ws;\nUser::LeaveIfError(ws.Connect());\nCleanupClosePushL(ws);\n\nCSIPCallHandler* callHandler = CSIPCallHandler::NewL(ws);\ncallHandler->StartCall(_L("sip:user@example.com"));\n\n// Cleanup\ndelete callHandler;\nws.Close();