// Define tile size (example: 32x32 pixels)\nint tileSize = 32;\n\n// Calculate position in terms of tiles\nint spriteTileX = static_cast<int>(sprite->x) / tileSize;\nint spriteTileY = static_cast<int>(sprite->y) / tileSize;\n\n// Collision detection should be tile-based now\nif (bushcol == 1) {\n    // Adjust to avoid collision with bush in a tile-manner\n    if (osl_keys->held.down) {\n        sprite->y = (bushTileY - 1) * tileSize;\n    } else if (osl_keys->held.up) {\n        sprite->y = (bushTileY + 1) * tileSize;\n    } else if (osl_keys->held.right) {\n        sprite->x = (bushTileX - 1) * tileSize;\n    } else if (osl_keys->held.left) {\n        sprite->x = (bushTileX + 1) * tileSize;\n    }\n} else {\n    // Move to next tile\n    if (osl_keys->held.down) {\n        sprite->y += tileSize;\n    } else if (osl_keys->held.up) {\n        sprite->y -= tileSize;\n    } else if (osl_keys->held.right) {\n        sprite->x += tileSize;\n    } else if (osl_keys->held.left) {\n        sprite->x -= tileSize;\n    }\n}\n\n// Ensure the sprite stays within bounds in terms of tiles\nint maxX = 455 / tileSize - (static_cast<int>(spritewidth) + 1) / tileSize; // Example calculation, adjust as necessary\nint maxY = 237 / tileSize - (static_cast<int>(spriteheight) + 1) / tileSize; // Example calculation, adjust as necessary\n\nif (spriteTileX < 0) sprite->x = 0;\nelse if (spriteTileX > maxX) sprite->x = maxX * tileSize;\n\nif (spriteTileY < 0) sprite->y = 0;\nelse if (spriteTileY > maxY) sprite->y = maxY * tileSize;\n\n// Update the tile positions\nspriteTileX = static_cast<int>(sprite->x) / tileSize;\nspriteTileY = static_cast<int>(sprite->y) / tileSize;\nbushTileX = static_cast<int>(bush->x) / tileSize;\nbushTileY = static_cast<int>(bush->y) / tileSize;\n\n// Collision detection in terms of tiles\nif ((spriteTileX == bushTileX && spriteTileY == bushTileY)) {\n    bushcol = 1;\n} else {\n    bushcol = 0;\n}