#include <ifaddrs.h>\n#include <net/if.h>\n\nstruct addrinfo *get_non_loopback_addrinfo() {\n    struct ifaddrs *ifAddrStruct = nullptr;\n    void *tmpAddrPtr = nullptr;\n\n    getifaddrs(&ifAddrStruct);\n\n    while (ifAddrStruct != nullptr) {\n        // Check for IPv4 address\n        if (ifAddrStruct->ifa_addr == nullptr || ifAddrStruct->ifa_addr->sa_family != AF_INET)\n            goto next;\n        \n        tmpAddrPtr = &((struct sockaddr_in *) ifAddrStruct->ifa_addr)->sin_addr;\n        \n        // Skip loopback interface\n        char addressBuffer[INET_ADDRSTRLEN];\n        inet_ntop(AF_INET, tmpAddrPtr, addressBuffer, INET_ADDRSTRLEN);\n        if (std::string(addressBuffer) == "127.0.0.1")\n            goto next;\n\n        // Create addrinfo struct for the non-loopback address\n        struct addrinfo hints;\n        memset(&hints, 0, sizeof hints);\n        hints.ai_family = AF_INET;\n        hints.ai_socktype = SOCK_STREAM;\n        \n        struct addrinfo *res;\n        if (getaddrinfo(addressBuffer, "0", &hints, &res) == 0)\n            return res;\n\nnext:\n        ifAddrStruct = ifAddrStruct->ifa_next;\n    }\n\n    // Fallback or error handling\n    std::cerr << "Could not find a non-loopback address." << std::endl;\n    exit(-1);\n}\n\nint main() {\n    struct addrinfo *res = get_non_loopback_addrinfo();\n\n    int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sockfd == -1) {\n        perror("Socket creation failed");\n        return 1;\n    }\n\n    if (bind(sockfd, res->ai_addr, res->ai_addrlen) == -1) {\n        close(sockfd);\n        perror("Bind failed");\n        freeaddrinfo(res); // Free the memory allocated for addrinfo\n        return 1;\n    }\n\n    listen(sockfd, SOMAXCONN);\n\n    // Proceed with your server logic...\n\n    freeaddrinfo(res); // Don't forget to free this as well\n\n    return 0;\n}