#include <QIdentityProxyModel>\n#include <QListView>\n#include <QGraphicsView>\n\nclass RowHeaderProxyModel : public QIdentityProxyModel {\n    Q_OBJECT\npublic:\n    using QIdentityProxyModel::QIdentityProxyModel;\n\n    QVariant data(const QModelIndex &index, int role) const override {\n        if (role == Qt::DisplayRole && index.column() == 0) {\n            return sourceModel()->headerData(index.row(), Qt::Vertical, role);\n        }\n        return QIdentityProxyModel::data(index, role);\n    }\n\n    QModelIndex parent(const QModelIndex &child) const override {\n        return createIndex(child.row(), 0, child.internalPointer());\n    }\n\n    bool hasChildren(const QModelIndex &parent = QModelIndex()) const override {\n        if (parent.isValid())\n            return false;\n        return true;\n    }\n};\n\nint main(int argc, char *argv[]) {\n    QApplication a(argc, argv);\n\n    // Assuming you already have your model and it's called videoModel\n    QAbstractItemModel* videoModel = ...; // Your 2D data model\n\n    RowHeaderProxyModel proxyModel;\n    proxyModel.setSourceModel(videoModel);\n\n    QGraphicsView graphicsView;\n    QListView frameListView;\n\n    // Set the proxy model to list view, so it will use row headers\n    frameListView.setModel(&proxyModel);\n    // Configure the list view orientation and other properties here\n\n    QObject::connect(&frameListView, &QListView::clicked,\n                     [&graphicsView, videoModel](const QModelIndex& index) {\n                         // Update the graphics view to show the selected frame\n                         int frameIndex = index.row();\n                         // Implement your logic to update graphics view with the frameIndex\n                     });\n\n    // Show your widgets here\n    graphicsView.show();\n    frameListView.show();\n\n    return a.exec();\n}