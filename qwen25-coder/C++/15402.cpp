void _findClosest(struct Node* current, Point* queryPoint, Point** first, Point** second, Point** third, unsigned int depth)\n{\n    if (current == NULL) return;\n\n    // Update the closest points so far\n    _setOrder(queryPoint, current->obj, first, second, third);\n\n    unsigned int axis = depth % 2;\n    struct Node* nextBest = NULL; // This will be the node to explore in a deeper level\n    struct Node* other = NULL; // This could be the node on the opposite side of the splitting plane\n\n    if (queryPoint->getValue(axis) < current->obj->getValue(axis))\n    {\n        nextBest = current->left;\n        other = current->right;\n    }\n    else\n    {\n        nextBest = current->right;\n        other = current->left;\n    }\n\n    // Explore the better node first.\n    _findClosest(nextBest, queryPoint, first, second, third, depth + 1);\n\n    double searchToBestDist = std::max(\n        _distance(queryPoint, *first),\n        std::max(_distance(queryPoint, *second), _distance(queryPoint, *third))\n    ); // Get the largest distance from the found points to query point\n\n    double distToSplitPlane = abs(current->obj->getValue(axis) - queryPoint->getValue(axis));\n\n    // Check if we need to explore the opposite branch as well.\n    if (searchToBestDist > distToSplitPlane)\n        _findClosest(other, queryPoint, first, second, third, depth + 1);\n}