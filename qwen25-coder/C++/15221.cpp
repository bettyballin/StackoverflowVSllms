#include <windows.h>\n#include <iostream>\n\nvoid ReadChangeJournal(HANDLE hVolume) {\n    CHANGE_JOURNAL_RECORD_BASIC record;\n    OVERLAPPED overlapped = { 0 };\n    DWORD bytesReturned;\n\n    while (true) {\n        BOOL result = DeviceIoControl(\n            hVolume,\n            FSCTL_READ_USN_JOURNAL,\n            nullptr, // No input buffer\n            0,\n            &record,\n            sizeof(record),\n            &bytesReturned,\n            &overlapped\n        );\n\n        if (result == FALSE && GetLastError() != ERROR_IO_PENDING) {\n            std::cerr << "DeviceIoControl failed. Error: " << GetLastError() << std::endl;\n            return;\n        }\n\n        // Wait for the operation to complete.\n        result = GetQueuedCompletionStatus(\n            overlapped.hEvent,\n            &bytesReturned,\n            nullptr,\n            &overlapped,\n            INFINITE\n        );\n\n        if (result == FALSE) {\n            std::cerr << "GetQueuedCompletionStatus failed. Error: " << GetLastError() << std::endl;\n            return;\n        }\n\n        // Processing the record goes here\n        std::cout << "Change at " << (LONGLONG)(record.Usn) << std::endl;\n\n        // For demonstration, breaking after one change\n        break;\n    }\n}\n\nint main() {\n    HANDLE hVolume = CreateFile(\n        L"\\\\?\\C:\\", \n        GENERIC_READ | GENERIC_WRITE,\n        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n        nullptr,\n        OPEN_EXISTING,\n        0,\n        nullptr\n    );\n\n    if (hVolume == INVALID_HANDLE_VALUE) {\n        std::cerr << "Failed to open drive. Error: " << GetLastError() << std::endl;\n        return -1;\n    }\n\n    ReadChangeJournal(hVolume);\n\n    CloseHandle(hVolume);\n    return 0;\n}