#include <windows.h>\n#include <iostream>\n\nvoid SendMessageToHost(const std::string& message) {\n    HANDLE hPipe = CreateFile(\n        TEXT("\\\\.\\pipe\\MyPipe"),   // pipe name \n        GENERIC_READ |            // read and write access \n        GENERIC_WRITE, \n        0,                         // no sharing \n        NULL,                      // default security attributes\n        OPEN_EXISTING,             // opens existing pipe \n        0,                         // default attributes \n        NULL);                     // no template file \n\n    if (hPipe == INVALID_HANDLE_VALUE) {\n        std::cerr << "Failed to connect to pipe." << std::endl;\n        return;\n    }\n\n    DWORD cbWritten;\n    WriteFile(\n        hPipe,                    // pipe handle \n        message.c_str(),          // message \n        message.length(),         // message length \n        &cbWritten,               // bytes written \n        NULL);                    // not overlapped \n\n    CloseHandle(hPipe);\n}\n\nint main() {\n    SECURITY_ATTRIBUTES saAttr;\n    BOOL bSuccess = FALSE;\n\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;             // Pipe handle is inherited by child processes \n    saAttr.lpSecurityDescriptor = NULL;       // default security attributes \n\n    HANDLE hPipe = CreateNamedPipe(\n        TEXT("\\\\.\\pipe\\MyPipe"),         // pipe name \n        PIPE_ACCESS_DUPLEX |                  // read/write access\n        PIPE_TYPE_MESSAGE |                   // message type pipe \n        1,                                   // max. instances  \n        BUFSIZE,                             // output buffer size \n        BUFSIZE,                             // input buffer size \n        0,                                   // client time-out \n        &saAttr);                            // default security attributes\n\n    if (hPipe == INVALID_HANDLE_VALUE) {\n        std::cerr << "Unable to create pipe." << std::endl;\n        return -1;\n    }\n\n    HANDLE hChild = CreateProcess(\n        NULL,\n        L"Host.exe", // Command line\n        NULL,        // Process handle not inheritable \n        NULL,        // Thread handle not inheritable \n        TRUE,        // Set handle inheritance to TRUE (needed for pipe) \n        CREATE_NEW_CONSOLE,    // Opens a new window when the created process runs. \n        NULL,        // Use parent's environment block \n        NULL,        // Use parent's starting directory \n        NULL,         // Pointer to STARTUPINFO structure\n        NULL);        // Pointer to PROCESS_INFORMATION structure\n\n    if (hChild == NULL) {\n        std::cerr << "Failed to create child process." << std::endl;\n        return -1;\n    }\n\n    while (true) {\n        DWORD dwState = WaitForSingleObject(hChild, 500);\n\n        if (dwState == WAIT_TIMEOUT) { // Check every 500 ms\n            // Send a message to the host process if needed\n            SendMessageToHost("Some instruction");\n        } else if (dwState == WAIT_OBJECT_0) {\n            std::cout << "Child process terminated. Restarting..." << std::endl;\n            CloseHandle(hChild);\n            hChild = CreateProcess(NULL, L"Host.exe", NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, NULL, NULL);\n\n            if (hChild == NULL) {\n                std::cerr << "Failed to restart child process." << std::endl;\n                break; // Exit on fail\n            }\n        } else {\n            break; // Other error\n        }\n    }\n\n    CloseHandle(hPipe);\n    CloseHandle(hChild);\n    return 0;\n}