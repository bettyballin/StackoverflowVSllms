#include <iostream>\n#include <array>\n\n// Base case for the fibonacci sequence\ntemplate<unsigned N>\nstruct Fibonacci {\n    enum { value = Fibonacci<N-1>::value + Fibonacci<N-2>::value };\n};\n\n// Specialization for 0\ntemplate<>\nstruct Fibonacci<0> {\n    enum { value = 0 };\n};\n\n// Specialization for 1\ntemplate<>\nstruct Fibonacci<1> {\n    enum { value = 1 };\n};\n\n// Generate a compile-time array of Fibonacci numbers up to N\ntemplate<unsigned N, typename A>\nstruct BuildFibonacciArray;\n\ntemplate<unsigned N, unsigned... Indices>\nstruct BuildFibonacciArray<N, std::index_sequence<Indices...>> {\n    using type = std::array<unsigned, N>;\n    static constexpr type values = {{ Fibonacci<Indices>::value... }};\n};\n\n// Convenience alias to build the Fibonacci array\ntemplate<unsigned N>\nusing FibonacciArray = typename BuildFibonacciArray<N, std::make_index_sequence<N>>::type;\n\nint main() {\n    // Define the size of the Fibonacci sequence you want at compile time\n    constexpr unsigned fibbMax = 20;\n    \n    // Create a compile-time Fibonacci array\n    constexpr FibonacciArray<fibbMax> fibs = {};\n    \n    // Seed random number generator\n    std::srand(static_cast<unsigned>(std::time(0)));\n    \n    // Get index into sequence\n    unsigned fibb = std::rand() % fibbMax;\n\n    std::cout << "Fibonacci(" << fibb << ") = ";\n    std::cout << fibs[fibb];  // Access Fibonacci number at runtime\n    std::cout << std::endl;\n    \n    return 0;\n}