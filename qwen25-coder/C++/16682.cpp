#include <windows.h>\n#include <winternl.h>\n#include <iostream>\n\ntypedef LONG KPRIORITY;\n\ntypedef struct _CLIENT_ID {\n    HANDLE UniqueProcess;\n    HANDLE UniqueThread;\n} CLIENT_ID, *PCLIENT_ID;\n\ntypedef NTSTATUS (NTAPI *_NtQuerySystemInformation)(\n    ULONG SystemInformationClass,\n    PVOID SystemInformation,\n    ULONG SystemInformationLength,\n    PULONG ReturnLength\n);\n\ntypedef struct _SYSTEM_THREAD_INFORMATION {\n    LARGE_INTEGER KernelTime;\n    LARGE_INTEGER UserTime;\n    LARGE_INTEGER CreateTime;\n    ULONG WaitTime;\n    PVOID StartAddress;\n    CLIENT_ID ClientId;\n    KPRIORITY Priority;\n    LONG BasePriority;\n    ULONG ContextSwitches;\n    LONG ThreadState;\n    LONG WaitReason;\n} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;\n\ntypedef struct _SYSTEM_PROCESS_INFO {\n    ULONG NextEntryOffset;\n    ULONG NumberOfThreads;\n    LARGE_INTEGER WorkingSetPrivateSize;\n    ULONG HardFaultCount;\n    ULONG NumberOfThreadsHighWatermark;\n    ULONGLONG CycleTime;\n    LARGE_INTEGER CreateTime;\n    LARGE_INTEGER UserTime;\n    LARGE_INTEGER KernelTime;\n    UNICODE_STRING ImageName;\n    KPRIORITY BasePriority;\n    HANDLE UniqueProcessId;\n    HANDLE InheritedFromUniqueProcessId;\n    ULONG HandleCount;\n    ULONG SessionId;\n    PVOID UniqueSession;\n    ULONGLONG VadSize;\n    SIZE_T PrivatePageCount;\n    SIZE_T PeakVirtualMemorySize;\n    SIZE_T VirtualMemorySize;\n    SIZE_T PageFaultCount;\n    SIZE_T PeakWorkingSetSize;\n    SIZE_T WorkingSetSize;\n    SIZE_T QuotaPoolUsage;\n    SIZE_T QuotaPeakPoolUsage;\n    ULONG PagefileUsage;\n    ULONG PeakPagefileUsage;\n    SIZE_T PrivateUsage;\n    LARGE_INTEGER ReadOperationCount;\n    LARGE_INTEGER WriteOperationCount;\n    LARGE_INTEGER OtherOperationCount;\n    LARGE_INTEGER ReadTransferCount;\n    LARGE_INTEGER WriteTransferCount;\n    LARGE_INTEGER OtherTransferCount;\n    SYSTEM_THREAD_INFORMATION Threads[1];\n} SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;\n\nint main() {\n    HMODULE ntdll = GetModuleHandle(L"ntdll.dll");\n    if (!ntdll) {\n        std::cerr << "Failed to load ntdll.dll." << std::endl;\n        return 1;\n    }\n\n    _NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");\n    if (!NtQuerySystemInformation) {\n        std::cerr << "Failed to get address of NtQuerySystemInformation." << std::endl;\n        return 1;\n    }\n\n    ULONG bufferSize = 0x10000; // Start with a buffer size\n    PVOID buffer = malloc(bufferSize);\n    if (!buffer) {\n        std::cerr << "Failed to allocate memory for the buffer." << std::endl;\n        return 1;\n    }\n\n    NTSTATUS status = NtQuerySystemInformation(5, buffer, bufferSize, NULL);\n\n    if (status == STATUS_INFO_LENGTH_MISMATCH) {\n        free(buffer);\n        bufferSize *= 2; // Double the size\n        buffer = malloc(bufferSize);\n        if (!buffer) {\n            std::cerr << "Failed to allocate memory for the enlarged buffer." << std::endl;\n            return 1;\n        }\n        status = NtQuerySystemInformation(5, buffer, bufferSize, NULL);\n    }\n\n    if (status != STATUS_SUCCESS) {\n        free(buffer);\n        std::cerr << "NtQuerySystemInformation failed with error: " << status << std::endl;\n        return 1;\n    }\n\n    PSYSTEM_PROCESS_INFO spi = reinterpret_cast<PSYSTEM_PROCESS_INFO>(buffer);\n    DWORD processId = GetCurrentProcessId();\n    bool foundProcess = false;\n\n    while (spi) {\n        if (HandleToUlong(spi->UniqueProcessId) == processId) {\n            for (unsigned int i = 0; i < spi->NumberOfThreads; ++i) {\n                SYSTEM_THREAD_INFORMATION &sti = spi->Threads[i];\n                HANDLE threadId = HandleToUlong(sti.ClientId.UniqueThread);\n                std::cout << "Thread ID: " << threadId\n                          << ", Kernel Time: " << sti.KernelTime.QuadPart\n                          << ", User Time: " << sti.UserTime.QuadPart << std::endl;\n            }\n            foundProcess = true;\n            break;\n        }\n\n        if (spi->NextEntryOffset == 0)\n            break;\n\n        spi = reinterpret_cast<PSYSTEM_PROCESS_INFO>(reinterpret_cast<char*>(spi) + spi->NextEntryOffset);\n    }\n\n    free(buffer);\n\n    if (!foundProcess) {\n        std::cerr << "The process is not found." << std::endl;\n        return 1;\n    }\n\n    return 0;\n}