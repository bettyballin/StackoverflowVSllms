class InnerObject : public IInner {\npublic:\n    long m_refCount;\n    IOuter* m_outerUnknown;\n\n    // Constructor\n    InnerObject(IOuter* outer) : m_refCount(1), m_outerUnknown(outer) {}\n\n    // IUnknown Methods\n    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObject) override {\n        if (riid == IID_IUnknown || riid == IID_IInner) {\n            *ppvObject = static_cast<IInner*>(this);\n        } else {\n            *ppvObject = nullptr;\n            return E_NOINTERFACE;\n        }\n        AddRef();\n        return S_OK;\n    }\n\n    STDMETHODIMP_(ULONG) AddRef() override {\n        return InterlockedIncrement(&m_refCount);\n    }\n\n    STDMETHODIMP_(ULONG) Release() override {\n        ULONG count = InterlockedDecrement(&m_refCount);\n        if (count == 0) {\n            delete this;\n        }\n        return count;\n    }\n\n    // IInner Methods\n    // Implementation of the inner specific methods...\n};\n\nclass OuterObject : public IOuter, IInner {\npublic:\n    long m_refCount;\n\n    // Constructor\n    OuterObject() : m_refCount(1), m_inner(new InnerObject(this)) {}\n\n    InnerObject* m_inner;\n\n    // IUnknown Methods\n    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObject) override {\n        if (riid == IID_IOuter || riid == IID_IInner || riid == IID_IUnknown) {\n            *ppvObject = static_cast<IOuter*>(this);\n        } else {\n            return m_inner->QueryInterface(riid, ppvObject);\n        }\n        AddRef();\n        return S_OK;\n    }\n\n    STDMETHODIMP_(ULONG) AddRef() override {\n        return InterlockedIncrement(&m_refCount);\n    }\n\n    STDMETHODIMP_(ULONG) Release() override {\n        ULONG count = InterlockedDecrement(&m_refCount);\n        if (count == 0) {\n            m_inner->Release();\n            delete this;\n        }\n        return count;\n    }\n\n    // IOuter Methods\n    // Implementation of the outer specific methods...\n\n    // Forwarded from inner methods...\n};