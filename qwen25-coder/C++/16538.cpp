#include <iostream>\n#include <string>\n\nclass StringHolder {\nprivate:\n    std::string data;\npublic:\n    StringHolder(const std::string& initialData) : data(initialData) {}\n\n    // Non-const version: allows modification\n    std::string& getData() {\n        return data;\n    }\n\n    // Const version: does not allow modification\n    const std::string& getData() const {\n        return data;\n    }\n};\n\nint main() {\n    StringHolder mutableHolder("Mutable Data");\n    const StringHolder immutableHolder("Immutable Data");\n\n    // This is allowed because getData() is non-const and we have a non-const object.\n    mutableHolder.getData()[0] = 'm';\n    \n    // This will cause a compile-time error if uncommented, because getData() is const and returns a const reference,\n    // preventing modification of the immutableHolder's data.\n    // immutableHolder.getData()[0] = 'i';\n\n    std::cout << "Mutable Data: " << mutableHolder.getData() << std::endl;\n    std::cout << "Immutable Data: " << immutableHolder.getData() << std::endl;\n\n    return 0;\n}