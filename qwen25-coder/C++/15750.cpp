#include <iostream>\n#include <winsock2.h>\n#include <iphlpapi.h>\n#pragma comment(lib, "iphlpapi.lib")\n\nvoid printPidForLocalPort(DWORD localPort) {\n    DWORD size = 0;\n    PMIB_TCP6TABLE2 table;\n\n    // Get the required buffer size\n    if (GetExtendedTcpTable(nullptr, &size, FALSE, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0) == ERROR_INSUFFICIENT_BUFFER) {\n        table = (PMIB_TCP6TABLE2)malloc(size);\n        if (table == nullptr) {\n            std::cerr << "Memory allocation failed" << std::endl;\n            return;\n        }\n    } else {\n        std::cerr << "Error in GetExtendedTcpTable" << std::endl;\n        return;\n    }\n\n    // Retrieve the TCP table\n    DWORD result = GetExtendedTcpTable(table, &size, FALSE, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);\n    if (result == NO_ERROR) {\n        for (DWORD i = 0; i < table->dwNumEntries; ++i) {\n            MIB_TCPROW2& row = table->table[i];\n            if (row.dwLocalPort == htons(localPort)) {\n                std::cout << "PID: " << row.dwOwningPid << std::endl;\n            }\n        }\n    } else {\n        std::cerr << "Error retrieving TCP table" << std::endl;\n    }\n\n    free(table);\n}\n\nint main() {\n    printPidForLocalPort(1234); // Replace with your known local port\n    return 0;\n}