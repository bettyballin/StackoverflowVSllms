// Collision detection and response functions\nbool checkCollision(float x1, float y1, float width1, float height1,\n                   float x2, float y2, float width2, float height2) {\n    // Basic AABB collision detection\n    return !(x1 + width1 <= x2 || x1 >= x2 + width2 ||\n             y1 + height1 <= y2 || y1 >= y2 + height2);\n}\n\nvoid handleCollision(Sprite* sprite, Bush* bush) {\n    float overlapX = fmax(0.0f, fmin(sprite->x + sprite->stretchX, bush->x + bush->bushwidth) - fmax(sprite->x, bush->x));\n    float overlapY = fmax(0.0f, fmin(sprite->y + sprite->stretchY, bush->y + bush->bushheight) - fmax(sprite->y, bush->y));\n\n    if (overlapX > 0 && overlapY > 0) {\n        // Determine the minimum overlap and adjust the position accordingly\n        if (overlapX < overlapY) {\n            sprite->x += (sprite->x + sprite->stretchX) < (bush->x + bush->bushwidth / 2) ? -overlapX : overlapX;\n        } else {\n            sprite->y += (sprite->y + sprite->stretchY) < (bush->y + bush->bushheight / 2) ? -overlapY : overlapY;\n        }\n    }\n}\n\n// Updated movement logic\nif (osl_keys->held.down && !checkCollision(sprite->x, sprite->y + 4, sprite->stretchX, sprite->stretchY,\n                                          bush->x, bush->y, bush->bushwidth, bush->bushheight)) {\n    sprite->y += 4;\n    sprite_position = DOWN;\n    SpriteAnimate();\n} else if (checkCollision(sprite->x, sprite->y + 4, sprite->stretchX, sprite->stretchY,\n                             bush->x, bush->y, bush->bushwidth, bush->bushheight)) {\n    handleCollision(sprite, bush);\n}\n\n// Similar logic for up, right, and left inputs