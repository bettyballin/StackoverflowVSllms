#include <tr1/functional>\n#include <string>\n\nclass Base {\n    // Common functionality for all wrappers\n};\n\ntemplate<typename FuncType>\nclass Wrapper : public Base {\npublic:\n    std::tr1::function<FuncType> func_;\n    std::string name_;\n\n    template<FuncType funcPtr>\n    Wrapper(const char* name)\n        : name_(name), func_(funcPtr) {}\n};\n\n// Utility class to create member function wrappers\ntemplate<typename Result, typename Class, typename... Args>\nstruct MemberFunction {\n    using FuncType = Result(Class::*)(Args...);\n\n    template<FuncType ptr>\n    static Wrapper<FuncType> wrap(const char* name) {\n        return Wrapper<FuncType, ptr>(name);\n    }\n};\n\n// Example class with member functions\nclass Foo {\npublic:\n    void func0() {\n        // Implementation here\n    }\n\n    int func2(char*, float) {\n        // Implementation here\n        return 42; // Just for example purposes\n    }\n};\n\nclass Bar : public Foo {\n    // Additional functionality can be added to Bar if needed\n};\n\n// Usage example\nint main() {\n    MemberFunction<void, Foo> func0Wrapper;\n    auto wrappedFunc0 = func0Wrapper.template wrap<&Foo::func0>("func0");\n\n    MemberFunction<int, Foo, char*, float> func2Wrapper;\n    auto wrappedFunc2 = func2Wrapper.template wrap<&Foo::func2>("func2");\n\n    // Now you can use wrappedFunc0 and wrappedFunc2 polymorphically\n    return 0;\n}