// Define a new ATL class that handles HTMLElementEvents2.\n#include <atlcom.h>\n#include <mshtml.h>\n\nclass CElementEventSink :\npublic CComObjectRootEx<CComSingleThreadModel>,\npublic IDispEventImpl<1, CElementEventSink, &DIID_HTMLElementEvents2, &LIBID_MSHTML, 4, 0>\n{\npublic:\n    BEGIN_COM_MAP(CElementEventSink)\n        COM_INTERFACE_ENTRY(IDispatch)\n    END_COM_MAP()\n\n    // Sink map to handle HTMLElementEvents2\n    BEGIN_SINK_MAP(CElementEventSink)\n        SINK_ENTRY_EX(1, DIID_HTMLElementEvents2, DISPID_HTMLELEMENTEVENTS2_ONSCROLL, OnScroll)\n    // Add other events as needed...\n    END_SINK_MAP()\n\n    HRESULT STDMETHODCALLTYPE OnScroll()\n    {\n        // Handle scroll event\n        return S_OK;\n    }\n};\n\n// In your main class (CMyClass), instantiate and connect the event sink.\nHRESULT CMyClass::ConnectEvents(IHTMLElement* pElem)\n{\n    if (!pElem) return E_POINTER;\n\n    CComObject<CElementEventSink> *pSink = NULL;\n    HRESULT hr = CComObject<CElementEventSink>::CreateInstance(&pSink);\n    if (FAILED(hr)) return hr;\n\n    IConnectionPointContainer* pCPC;\n    hr = pElem->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);\n    if (FAILED(hr))\n    {\n        delete pSink; // Clean up if this fails\n        return hr;\n    }\n\n    IConnectionPoint* pCP;\n    hr = pCPC->FindConnectionPoint(DIID_HTMLElementEvents2, &pCP);\n    pCPC->Release();\n    if (FAILED(hr))\n    {\n        pSink->Release(); // Clean up\n        return hr;\n    }\n\n    DWORD dwCookie;\n    hr = pCP->Advise(pSink, &dwCookie);\n    pCP->Release();\n    if (FAILED(hr))\n    {\n        pSink->Release(); // Clean up\n        return hr;\n    }\n\n    // Store pSink and dwCookie for later unadvising:\n    m_pElementEventSinks.push_back({pSink, dwCookie});\n\n    return S_OK;\n}\n\n// Ensure to unadvise when done.\nvoid CMyClass::DisconnectEvents()\n{\n    for (auto& [pSink, cookie] : m_pElementEventSinks)\n    {\n        IConnectionPoint* pCP;\n        HRESULT hr = pSink->QueryInterface(IID_IConnectionPoint, (void**)&pCP);\n        if (SUCCEEDED(hr))\n        {\n            pCP->Unadvise(cookie);\n            pCP->Release();\n        }\n        pSink->Release();\n    }\n    m_pElementEventSinks.clear();\n}