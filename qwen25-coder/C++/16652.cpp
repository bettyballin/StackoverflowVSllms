#include <vector>\n#include <cassert>\n\nvoid reorder(vector<char>& vA, const vector<size_t>& vOrder) {\n    assert(vA.size() == vOrder.size());\n    \n    size_t n = vA.size();\n    for (size_t i = 0; i < n; ++i) {\n        // If the element is already in the correct position or marked as visited\n        if (vOrder[i] >= n || vOrder[i] == i) continue;\n\n        // Find the cycle to rotate\n        size_t j = i;\n        char tmp = vA[j];\n\n        do {\n            std::swap(tmp, vA[vOrder[j]]);\n            std::swap(vOrder[j], n + j); // Mark as visited\n            j = vOrder[j] - n;          // Move to the next index in the cycle\n        } while (j != i);\n\n        vA[i] = tmp;\n    }\n}\n\nint main() {\n    char A[] = { 'a', 'b', 'c' };\n    size_t ORDER[] = { 1, 0, 2 };\n\n    std::vector<char> vA(A, A + sizeof(A) / sizeof(*A));\n    std::vector<size_t> vOrder(ORDER, ORDER + sizeof(ORDER) / sizeof(*ORDER));\n\n    reorder(vA, vOrder);\n\n    // Output the result\n    for (char c : vA) {\n        putchar(c);\n    }\n    return 0;\n}