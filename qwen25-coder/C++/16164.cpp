#include <windows.h>\n#include <iostream>\n#include <string>\n\nstd::string ExecuteAndCaptureOutput(const std::string& command) {\n    SECURITY_ATTRIBUTES sa;\n    HANDLE hReadPipe, hWritePipe;\n\n    // Set up security attributes for handles\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;    // Allow the child process to inherit the handle\n    sa.lpSecurityDescriptor = NULL;\n\n    // Create a pipe for redirection of child process' stdout\n    if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0)) {\n        return "Error creating pipe.\n";\n    }\n\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    memset(&si, 0, sizeof(si));\n    si.cb = sizeof(si);\n    si.dwFlags |= STARTF_USESTDHANDLES; // Redirect stdin/stdout\n    si.hStdOutput = hWritePipe;\n    si.hStdError = hWritePipe;\n\n    memset(&pi, 0, sizeof(pi));\n\n    if (!CreateProcess(NULL, const_cast<char*>(command.c_str()), NULL, NULL,\n                       TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {\n        return "Error creating process.\n";\n    }\n\n    // Close the write end of the pipe as no need for writing to it\n    CloseHandle(hWritePipe);\n\n    DWORD bytesRead;\n    char buffer[4096];\n    std::string output;\n\n    while (ReadFile(hReadPipe, buffer, sizeof(buffer), &bytesRead, NULL) && bytesRead != 0) {\n        output.append(buffer, bytesRead);\n    }\n\n    // Clean up\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    CloseHandle(hReadPipe);\n\n    return output;\n}\n\nint main() {\n    std::string command = "dir"; // Example command to execute\n    std::cout << ExecuteAndCaptureOutput(command) << std::endl;\n    return 0;\n}