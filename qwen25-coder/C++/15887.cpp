#include <cuda_runtime.h>\n#include <cmath>\n\n__global__ void findClosestPoint(float *points, float *target, float *closestPoint, int numPoints) {\n    int tid = blockIdx.x * blockDim.x + threadIdx.x;\n    if (tid >= numPoints) return;\n\n    float minDistance = INFINITY;\n    int closestIndex = 0;\n\n    for (int i = 0; i < numPoints; ++i) {\n        float dx = points[3*i] - target[0];\n        float dy = points[3*i+1] - target[1];\n        float dz = points[3*i+2] - target[2];\n\n        float distance = sqrtf(dx*dx + dy*dy + dz*dz);\n\n        if (distance < minDistance) {\n            minDistance = distance;\n            closestIndex = i;\n        }\n    }\n\n    if (tid == 0) {\n        closestPoint[0] = points[3*closestIndex];\n        closestPoint[1] = points[3*closestIndex+1];\n        closestPoint[2] = points[3*closestIndex+2];\n    }\n}\n\n// Host code to launch the kernel\nvoid findClosestPointOnGPU(float *points, float *target, float *closestPoint, int numPoints) {\n    float *d_points, *d_target, *d_closestPoint;\n\n    size_t size = sizeof(float)*numPoints*3;\n    cudaMalloc((void**)&d_points, size);\n    cudaMemcpy(d_points, points, size, cudaMemcpyHostToDevice);\n\n    size = sizeof(float)*3;\n    cudaMalloc((void**)&d_target, size);\n    cudaMemcpy(d_target, target, size, cudaMemcpyHostToDevice);\n\n    cudaMalloc((void**)&d_closestPoint, size);\n\n    int blockSize = 256;\n    int numBlocks = (numPoints + blockSize - 1) / blockSize;\n\n    findClosestPoint<<<numBlocks, blockSize>>>(d_points, d_target, d_closestPoint, numPoints);\n    cudaMemcpy(closestPoint, d_closestPoint, size, cudaMemcpyDeviceToHost);\n\n    cudaFree(d_points); cudaFree(d_target); cudaFree(d_closestPoint);\n}