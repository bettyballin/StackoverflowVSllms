#include <windows.h>\n#include <iostream>\n\nclass Monitor {\nprivate:\n    HANDLE mutex;\n    HANDLE condition;\n\npublic:\n    Monitor() {\n        mutex = CreateMutex(NULL, FALSE, NULL);\n        condition = CreateEvent(NULL, FALSE, FALSE, NULL);\n    }\n\n    ~Monitor() {\n        CloseHandle(mutex);\n        CloseHandle(condition);\n    }\n\n    void enter() {\n        WaitForSingleObject(mutex, INFINITE);\n    }\n\n    void leave() {\n        ReleaseMutex(mutex);\n    }\n\n    void wait() {\n        SignalObjectAndWait(mutex, condition, INFINITE, FALSE);\n        WaitForSingleObject(mutex, INFINITE);\n    }\n\n    void signal_one() {\n        SetEvent(condition);\n        WaitForSingleObject(mutex, 0); // Try to take the mutex\n        ReleaseMutex(mutex);\n    }\n};\n\nint main() {\n    Monitor monitor;\n\n    DWORD WINAPI ThreadProc(LPVOID lpParam) {\n        monitor.enter();\n        std::cout << "Thread waiting..." << std::endl;\n        monitor.wait();\n        std::cout << "Thread signaled and exiting..." << std::endl;\n        monitor.leave();\n        return 0;\n    }\n\n    HANDLE hThreads[2];\n    for (int i = 0; i < 2; ++i) {\n        hThreads[i] = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);\n    }\n\n    Sleep(1000); // Let threads wait\n\n    monitor.enter();\n    std::cout << "Main thread signaling one..." << std::endl;\n    monitor.signal_one();\n    monitor.leave();\n\n    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);\n\n    for (int i = 0; i < 2; ++i) {\n        CloseHandle(hThreads[i]);\n    }\n\n    return 0;\n}