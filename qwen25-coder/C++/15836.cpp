#include <windows.h>\n#include <wincrypt.h>\n#include <iostream>\n\nbool IsFileSigned(LPCWSTR fileName) {\n    HANDLE hFile = CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) return false;\n\n    DWORD size = GetFileSize(hFile, NULL);\n    BYTE* buffer = new BYTE[size];\n    ZeroMemory(buffer, size);\n\n    ReadFile(hFile, buffer, size, &size, NULL);\n    CloseHandle(hFile);\n\n    WINTRUST_FILE_INFO fileInfo;\n    memset(&fileInfo, 0, sizeof(WINTRUST_FILE_INFO));\n    fileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);\n    fileInfo.pcwszFilePath = fileName;\n\n    WINTRUST_DATA trustData;\n    memset(&trustData, 0, sizeof(trustData));\n    trustData.cbStruct = sizeof(WINTRUST_DATA);\n    trustData.dwUIChoice = WTD_UI_NONE;\n    trustData.fdwRevocationChecks = WTD_REVOKE_NONE;\n    trustData.pPolicyCallbackData = NULL;\n    trustData.pSIPClientData = NULL;\n    trustData.dwProvFlags =\n            WVTD_REVOCATIONCHECK_CHAIN_EXCLUDE_ROOT |\n            WTD_USE_DEFAULT_OS_POLICY | WVTD_SAFERITHANDLING;\n    trustData.dwUnionChoice = WTD_CHOICE_FILE;\n    trustData.pFile = &fileInfo;\n\n    LONG result = WinVerifyTrust(NULL,\n                                 &SPC_ECDSA_CERT_EKU_OBJID,\n                                 &trustData);\n\n    LocalFree(buffer);\n    return (result == ERROR_SUCCESS);\n}