#include <iostream>\n#include <list>\n\nstruct Node {\n    int key;\n    int degree = 0;\n    bool mark = false;\n    Node* parent = nullptr;\n    std::list<Node*> child;\n};\n\nclass FibonacciHeap {\nprivate:\n    Node* minPtr = nullptr;\n    size_t size_ = 0;\n\n    void insertNode(Node* node) {\n        if (minPtr == nullptr) {\n            minPtr = node;\n        } else {\n            auto &l = minPtr->child;\n            l.push_front(node);\n        }\n        size_++;\n    }\n\n    void consolidate() {\n        // Array of pointers to nodes of different degrees\n        Node* A[64] = {0};\n        std::list<Node*> rootList;\n        \n        if (!minPtr)\n            return;\n\n        rootList.splice(rootList.end(), minPtr->child);\n        rootList.push_back(minPtr);\n        minPtr->child.clear();\n\n        for (auto it = rootList.begin(); it != rootList.end();) {\n            Node* x = *it;\n            int d = x->degree;\n            \n            while (A[d] != nullptr) {\n                Node* y = A[d];\n\n                if (x->key > y->key)\n                    std::swap(x, y);\n\n                y->parent = x;\n\n                // Link root node of degree d to the end of root of degree d+1's child list\n                x->child.splice(x->child.end(), y->child);\n                \n                x->degree++;\n                y->mark = false;\n                y->parent = x; \n                A[d] = nullptr;\n                d++;\n            }\n            A[x->degree] = x;\n\n            it++;\n        }\n\n        minPtr = nullptr;\n        for (int i = 0; i < 64; ++i) {\n            if (A[i] != nullptr && !minPtr)\n                minPtr = A[i];\n            else if (A[i] != nullptr && A[i]->key <= minPtr->key)\n                minPtr = A[i];\n        }\n    }\n\npublic:\n    void insert(int key) {\n        Node* node = new Node{key};\n        insertNode(node);\n        if (minPtr == nullptr || minPtr->key > key) {\n            minPtr = node;\n        }\n    }\n\n    int getMin() const {\n        return minPtr ? minPtr->key : -1; // Assuming the heap is not empty\n    }\n\n    void extractMin() {\n        Node* z = minPtr;\n\n        if (z != nullptr) {\n\n            for (auto it = z->child.begin(); it != z->child.end();) {\n                (*it)->parent = nullptr;\n                rootList.push_back(*it);\n                it++;\n            }\n            \n            rootList.erase(rootList.iterator_to(*z));\n            if (!rootList.empty()) {\n                minPtr = rootList.front();\n\n                consolidate();\n            } else {\n                minPtr = nullptr; \n            }\n\n            delete z;\n        }\n    }\n\nprivate:\n    std::list<Node*> rootList;\n\npublic:\n    size_t size() const { return size_; }\n};\n\nint main() {\n    FibonacciHeap f_heap;\n    f_heap.insert(10);\n    f_heap.insert(5);\n    f_heap.insert(3);\n    f_heap.insert(20);\n\n    std::cout << "Min element is " << f_heap.getMin() << std::endl; // Should be 3\n    f_heap.extractMin();\n    std::cout << "Min element after extractMin is " << f_heap.getMin() << std::endl; // Should be 5\n\n    return 0;\n}