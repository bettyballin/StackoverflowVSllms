#include <vector>\n#include <map>\n#include <utility>\n#include <set>\n\nstruct Vertex2D {\n    int x, y;\n    Vertex2D(int x, int y) : x(x), y(y) {}\n};\n\nstd::vector<std::vector<Vertex2D>> convertToUnindexed(const std::vector<Vertex2D>& vertices, const std::vector<std::pair<int, int>>& edges) {\n    std::set<std::pair<int, int>> unvisitedEdges(edges.begin(), edges.end());\n    std::map<int, std::vector<int>> edgeMap;\n    \n    // Build a map from start vertex to list of end vertices\n    for (const auto& edge : edges) {\n        edgeMap[edge.first].push_back(edge.second);\n    }\n\n    std::vector<std::vector<Vertex2D>> unindexedPolygons;\n\n    while (!unvisitedEdges.empty()) {\n        std::vector<Vertex2D> currentPolygon;\n        int startVertex = (*unvisitedEdges.begin()).first; // Get any starting vertex\n        int nextVertex = startVertex;\n        \n        do {\n            auto searchIt = edgeMap.find(nextVertex);\n            if (searchIt == edgeMap.end() || searchIt->second.empty()) {\n                throw std::runtime_error("Invalid polygon definition.");\n            }\n            \n            currentPolygon.push_back(vertices[nextVertex]);\n            unvisitedEdges.erase({nextVertex, searchIt->second.back()});\n            \n            nextVertex = searchIt->second.back();\n            // This is a simple implementation that always chooses the last edge.\n            // In case of multiple options, you might want to implement more complex logic\n            // or use additional data structures (like using a stack with backtracking).\n            searchIt->second.pop_back();\n        } while (nextVertex != startVertex);\n\n        unindexedPolygons.push_back(currentPolygon);\n    }\n\n    return unindexedPolygons;\n}