#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, weight;\n};\n\nvoid BFSPFA(int start, vector<Edge>& edges, vector<int>& dist, vector<int>& numUpdates, const int N) {\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0; // Assuming all nodes are numbered from 0 to N-1\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (Edge& edge : edges) {\n            if (edge.from == u) {\n                int v = edge.to;\n                int weight = edge.weight;\n                \n                // Relax the edge\n                if (dist[u] + weight < dist[v]) {\n                    dist[v] = dist[u] + weight;\n                    \n                    // If this vertex is relaxed more than |V| - 1 times, it indicates a cycle\n                    if (++numUpdates[v] > N) {\n                        cout << "Negative weight cycle detected!" << endl;\n                        return;\n                    }\n                    \n                    q.push(v);\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int N = 5; // Number of vertices\n    int E = 6; // Number of edges\n    vector<Edge> edges = {\n        {0, 1, -1},\n        {0, 2, 4},\n        {1, 2, 3},\n        {1, 3, 2},\n        {1, 4, 2},\n        {3, 2, 5}\n    };\n    \n    vector<int> dist(N, INT_MAX); // Distance vector\n    vector<int> numUpdates(N, 0);   // To detect negative cycles\n    \n    BFSPFA(0, edges, dist, numUpdates, N);\n    \n    cout << "Distances from start vertex:" << endl;\n    for (int i = 0; i < N; ++i) {\n        cout << "Node " << i << ": " << dist[i] << endl;\n    }\n    \n    return 0;\n}