#include <iostream>\n#include <sstream>\n#include <streambuf>\n\nclass StringStreamBuffer : public std::streambuf {\npublic:\n    // Override overflow to capture character in our string\n    int overflow(int c) override {\n        if (c != EOF) {\n            m_buffer.push_back(static_cast<char>(c));\n        }\n        return c;\n    }\n\n    std::string str() const { return m_buffer; }\n\nprivate:\n    std::string m_buffer;\n};\n\nclass OutputStreamWrapper : public std::ostream {\npublic:\n    OutputStreamWrapper() : std::ostream(&m_stringStreamBuf) {}\n\n    StringStreamBuffer& rdbuf() { return m_stringStreamBuf; }\n    std::string str() const { return m_stringStreamBuf.str(); }\n\nprivate:\n    StringStreamBuffer m_stringStreamBuf;\n};\n\n// Example usage\nclass A {\npublic:\n    void print(FILE* f);\n    B b; // Assuming B is defined elsewhere\n\n    std::string to_str();\n};\n\nvoid A::print(FILE *f) {\n    std::string s = "stuff";\n    fprintf(f, "some %s\n", s.c_str());\n    b.print(f); // Assuming B's print method writes to FILE*\n}\n\nstd::string A::to_str() {\n    OutputStreamWrapper os;\n    FILE* fp = fmemopen(os.rdbuf().str(), 65536, "w");\n    if (fp == nullptr) {\n        throw std::runtime_error("fmemopen failed.");\n    }\n    print(fp);\n    fclose(fp);\n    return os.str();\n}