#include <windows.h>\n#include <vector>\n#include <iostream>\n\nbool GetDependencies(const char* exePath, std::vector<std::string>& dependencies) {\n    HANDLE hFile = CreateFileA(exePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) return false;\n\n    DWORD fileSize = GetFileSize(hFile, NULL);\n    BYTE* pFileBuffer = new BYTE[fileSize];\n    DWORD bytesRead;\n    ReadFile(hFile, pFileBuffer, fileSize, &bytesRead, NULL);\n\n    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;\n    if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) {\n        delete[] pFileBuffer;\n        CloseHandle(hFile);\n        return false;\n    }\n\n    PIMAGE_NT_HEADERS64 ntHeaders = (PIMAGE_NT_HEADERS64)((BYTE*)pFileBuffer + dosHeader->e_lfanew);\n    if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) {\n        delete[] pFileBuffer;\n        CloseHandle(hFile);\n        return false;\n    }\n\n    PIMAGE_IMPORT_DESCRIPTOR importDirectory = (PIMAGE_IMPORT_DESCRIPTOR)\n        ((BYTE*)pFileBuffer +\n         ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);\n\n    for (; importDirectory->Name; ++importDirectory) {\n        std::string dllName((char*)((BYTE*)pFileBuffer + importDirectory->Name));\n        dependencies.push_back(dllName);\n        std::cout << "Dependency: " << dllName << std::endl;\n    }\n\n    delete[] pFileBuffer;\n    CloseHandle(hFile);\n    return true;\n}\n\nint main() {\n    std::vector<std::string> dependencies;\n    if (GetDependencies("example.exe", dependencies)) {\n        std::cout << "Successfully retrieved dependencies." << std::endl;\n    } else {\n        std::cerr << "Failed to retrieve dependencies." << std::endl;\n    }\n    return 0;\n}