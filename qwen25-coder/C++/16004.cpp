#include <msclr/marshal_cppstd.h>\n\nusing namespace System;\nusing namespace System::Reflection;\n\npublic interface class IEngine {\n    void ProcessData();\n};\n\nint main(array<System::String ^> ^args) {\n    // Read the configuration to determine which engine to load\n    String^ engineName = "Way1";  // This would be read from a config file in real scenarios\n\n    String^ dllPath;\n    if (engineName == "Way1") {\n        dllPath = "project_engine_way1.dll";\n    } else if (engineName == "Way2") {\n        dllPath = "project_engine_way2.dll";\n    } else {\n        Console::WriteLine("No valid engine specified in the configuration.");\n        return -1;\n    }\n\n    // Load the DLL\n    Assembly^ assembly = Assembly::LoadFrom(dllPath);\n    \n    // Assuming classes are named like Way1Engine, Way2Engine etc.\n    String^ typeName = "Namespace." + engineName + "Engine";\n    Type^ type = assembly->GetType(typeName);\n\n    if (type == nullptr) {\n        Console::WriteLine("Could not find class in the DLL.");\n        return -1;\n    }\n\n    // Create an instance of the class and cast to IEngine\n    IEngine^ engineInstance = dynamic_cast<IEngine^>(Activator::CreateInstance(type));\n    if (engineInstance != nullptr) {\n        engineInstance->ProcessData();\n    } else {\n        Console::WriteLine("Type does not implement desired interface.");\n    }\n\n    return 0;\n}