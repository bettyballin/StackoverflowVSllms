#include "config.h"\n#include "system.h"\n#include "coretypes.h"\n#include "tm.h"\n#include "tree.h"\n#include "gimple.h"\n#include "function.h"\n#include "cgraph.h"\n#include "passmanager.h"\n\nstatic unsigned int execute_instrumentation(gimple_stmt_iterator *gsi_p)\n{\n  gimple stmt = gsi_stmt(*gsi_p);\n\n  // Check if the statement is a return\n  if (gimple_code(stmt) == GIMPLE_RETURN)\n    {\n      /* Create a call to dbg function */\n      tree result_var = gimple_return_retval(stmt);\n      tree dbg_func = build_function_call_expr(tree_lookup_name(get_identifier("dbg")), NULL);\n\n      // If there's a return value, pass it as an argument\n      if (result_var)\n        {\n          vec<tree, va_gc> *args;\n          vec_alloc(args, 1);\n          vec_safe_push(args, result_var);\n          gimple_call_set_args(dbg_func, args);\n        }\n\n      // Insert the call before return statement\n      gsi_insert_before(gsi_p, dbg_func);\n    }\n\n  return 0;\n}\n\nstatic bool gate_instrumentation(void)\n{\n  /* This instrumentation pass should only be run for specific functions */\n  const char *target_function = "foo";\n  if (strcmp(current_function_name(), target_function) == 0)\n    {\n      return true;\n    }\n  else\n    {\n      return false;\n    }\n}\n\nconst pass_data pass_instrumentation =\n{\n  GIMPLE_PASS, /* type */\n  "instrument", /* name */\n  OPTGROUP_NONE, /* optinfo_flags */\n  TV_TREE_LOOP, /* tv_id */\n  PROP_ssa, /* properties_required */\n  0, /* properties_provided */\n  0, /* properties_destroyed */\n  0, /* todo_flags_start */\n  TODO_gimplify | TODO_update_ssa | TODO_verify_ssa | TODO_verify_stmts, /* todo_flags_finish */\n};\n\nclass pass_instrument : public gimple_opt_pass\n{\npublic:\n  pass_instrument(gcc::context *ctx)\n    : gimple_opt_pass(pass_instrumentation, ctx)\n  {}\n\n  bool gate(function *) { return gate_instrumentation(); }\n  unsigned int execute(function *)\n  {\n    basic_block bb;\n    gimple_stmt_iterator gsi;\n\n    FOR_EACH_BB_FN(bb, cfun)\n      for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi))\n        execute_instrumentation(&gsi);\n\n    return 0;\n  }\n\n}; // class pass_instrument\n\ngimple_opt_pass *\nmake_pass_instrument(gcc::context *ctx)\n{\n  return new (ctx) pass_instrument(ctx);\n}