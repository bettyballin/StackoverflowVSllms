class QueryBuilder {\nprivate:\n    std::string selectClause;\n    std::string fromClause;\n\npublic:\n    void select(const std::string& column) {\n        if (!selectClause.empty()) {\n            selectClause += ", ";\n        }\n        selectClause += column;\n    }\n\n    void from(const std::string& table) {\n        fromClause = table;\n    }\n\n    virtual std::string generate() const = 0;\n\nprotected:\n    std::string getSelectClause() const { return selectClause; }\n    std::string getFromClause() const { return fromClause; }\n};\n\nclass MySqlQueryBuilder : public QueryBuilder {\npublic:\n    std::string generate() const override {\n        return "SELECT " + getSelectClause() + " FROM " + getFromClause();\n    }\n};\n\nclass AVECQueryBuilder : public QueryBuilder {\npublic:\n    std::string generate() const override {\n        return "SELECT " + getSelectClause() + " AVEC " + getFromClause();\n    }\n};\n\n// Usage\nvoid executeQuery(QueryBuilder* builder, DatabaseConnection* dbConnection) {\n    builder->select("id");\n    builder->from("table");\n\n    CString query = builder->generate().c_str();\n    Results results = dbConnection->Query(query);\n}\n\nint main() {\n    MySqlQueryBuilder mySqlBuilder;\n    AVECQueryBuilder avecBuilder;\n\n    // Depending on the database in use\n    QueryBuilder* currentBuilder = &mySqlBuilder;  // or &avecBuilder\n\n    executeQuery(currentBuilder, dbConnection);\n\n    return 0;\n}