// In the first block of code, no change needed for SafeArrayDestroy\nif (((newVal.vt & VT_ARRAY) == VT_ARRAY) && ((newVal.vt & VT_BSTR) == VT_BSTR))\n{\n    SAFEARRAY* paArray = newVal.parray;\n    BSTR * str = NULL;\n    SafeArrayAccessData(paArray, (void**)&str);\n\n    long lLBound = 0;\n    long lUBound = 0;\n\n    if (FAILED(SafeArrayGetLBound(paArray, 1, &lLBound)) || \n        FAILED(SafeArrayGetUBound(paArray, 1, &lUBound)))\n    {\n        ASSERT(false);\n        SafeArrayUnaccessData(paArray); // Ensure data is unaccessed before leaving the function\n        return FALSE;\n    }\n\n    long nCount = ( lUBound - lLBound + 1 );\n    for (long i = lLBound; i <= lUBound ; i++) // Use bounds directly\n    {           \n        m_cstrList.AddString(W2T(str[i]));                  \n    }   \n\n    SafeArrayUnaccessData(paArray);\n}