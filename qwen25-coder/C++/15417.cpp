STDMETHODIMP CAnalisis::Load(IStream* pStm) {\n    ULONG cb;\n    HRESULT hr;\n\n    if (NULL == pStm)\n        return ResultFromScode(E_POINTER);\n\n    // Read the numeric values directly.\n    hr = pStm->Read(&img.size, sizeof(img.size), &cb);\n    if (FAILED(hr) || cb != sizeof(img.size)) return E_FAIL;\n\n    hr = pStm->Read(&img.color, sizeof(img.color), &cb);\n    if (FAILED(hr) || cb != sizeof(img.color)) return E_FAIL;\n\n    hr = pStm->Read(&img.light, sizeof(img.light), &cb);\n    if (FAILED(hr) || cb != sizeof(img.light)) return E_FAIL;\n\n    // Read the length of imgName.\n    ULONG len;\n    hr = pStm->Read(&len, sizeof(len), &cb);\n    if (FAILED(hr) || cb != sizeof(len)) return E_FAIL;\n\n    SysFreeString(img.imgName); // Free existing BSTR before allocating new one.\n    if (len > 0) { // Allocate and read the BSTR data.\n        img.imgName = SysAllocStringLen(NULL, len);\n        if (!img.imgName) return STG_E_INSUFFICIENTMEMORY;\n        hr = pStm->Read(img.imgName, sizeof(OLECHAR) * len, &cb);\n        if (FAILED(hr) || cb != sizeof(OLECHAR) * len) {\n            SysFreeString(img.imgName);\n            img.imgName = NULL;\n            return E_FAIL;\n        }\n    } else {\n        img.imgName = NULL;\n    }\n\n    // Do the same for uname.\n    hr = pStm->Read(&len, sizeof(len), &cb);\n    if (FAILED(hr) || cb != sizeof(len)) return E_FAIL;\n\n    SysFreeString(img.uname); // Free existing BSTR before allocating new one.\n    if (len > 0) { // Allocate and read the BSTR data.\n        img.uname = SysAllocStringLen(NULL, len);\n        if (!img.uname) return STG_E_INSUFFICIENTMEMORY;\n        hr = pStm->Read(img.uname, sizeof(OLECHAR) * len, &cb);\n        if (FAILED(hr) || cb != sizeof(OLECHAR) * len) {\n            SysFreeString(img.uname);\n            img.uname = NULL;\n            return E_FAIL;\n        }\n    } else {\n        img.uname = NULL;\n    }\n\n    return NOERROR;\n}\n\nSTDMETHODIMP CAnalisis::Save(IStream* pStm) {\n    ULONG cb;\n    HRESULT hr;\n\n    if (NULL == pStm)\n        return ResultFromScode(E_POINTER);\n\n    // Write the numeric values directly.\n    hr = pStm->Write(&img.size, sizeof(img.size), &cb);\n    if (FAILED(hr)) return hr;\n\n    hr = pStm->Write(&img.color, sizeof(img.color), &cb);\n    if (FAILED(hr)) return hr;\n\n    hr = pStm->Write(&img.light, sizeof(img.light), &cb);\n    if (FAILED(hr)) return hr;\n\n    // Write the length and then the actual BSTR data for imgName.\n    ULONG lenImgName = SysStringLen(img.imgName);\n    hr = pStm->Write(&lenImgName, sizeof(lenImgName), &cb);\n    if (FAILED(hr)) return hr;\n\n    if (img.imgName) {\n        hr = pStm->Write(img.imgName, sizeof(OLECHAR) * lenImgName, &cb);\n        if (FAILED(hr)) return hr;\n    }\n\n    // Do the same for uname.\n    ULONG lenUname = SysStringLen(img.uname);\n    hr = pStm->Write(&lenUname, sizeof(lenUname), &cb);\n    if (FAILED(hr)) return hr;\n\n    if (img.uname) {\n        hr = pStm->Write(img.uname, sizeof(OLECHAR) * lenUname, &cb);\n        if (FAILED(hr)) return hr;\n    }\n\n    return NOERROR;\n}