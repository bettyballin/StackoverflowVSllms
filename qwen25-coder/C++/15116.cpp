#include <windows.h>\n#include <gdiplus.h>\n#include <comdef.h>\n\n#pragma comment (lib,"Gdiplus.lib")\n\n#include <sqltypes.h>\n#include <sqlext.h>\n#include <iostream>\n\nusing namespace Gdiplus;\n\nint main() {\n    // Initialize GDI+\n    GdiplusStartupInput gdiplusStartupInput;\n    ULONG_PTR gdiplusToken;\n    GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);\n\n    // SQL Variables\n    SQLHENV hEnv = NULL;\n    SQLHDBC hDbc = NULL;\n    SQLHSTMT hStmt = NULL;\n\n    // SQL Connection and Query Setup\n    SQLRETURN ret;\n    ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &hEnv);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -1;\n    ret = SQLSetEnvAttr(hEnv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -2;\n\n    ret = SQLAllocHandle(SQL_HANDLE_DBC, hEnv, &hDbc);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -3;\n    ret = SQLDriverConnect(hDbc, NULL, \n        (SQLWCHAR*)L"DRIVER={SQL Server};SERVER=your_server;DATABASE=your_db;UID=your_user;PWD=your_password;",  \n        SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -4;\n\n    // Allocate a statement handle\n    if (SQLAllocHandle(SQL_HANDLE_STMT, hDbc, &hStmt) != SQL_SUCCESS) return -5;\n\n    // Prepare the query to select the image data\n    const char* sql = "SELECT ImageData FROM Images WHERE Id=1";\n    ret = SQLExecDirect(hStmt, (SQLCHAR*)sql, SQL_NTS);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -6;\n\n    // Bind binary column to buffer\n    BYTE* blobData = NULL;\n    SQLLEN imageSize;\n    if (SQLBindCol(hStmt, 1, SQL_C_BINARY, &blobData, 0, &imageSize) != SQL_SUCCESS) return -7;\n\n    // Fetch the row\n    ret = SQLFetch(hStmt);\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) return -8;\n\n    // Create IStream from memory blob data\n    HGLOBAL memHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, imageSize);\n    LPVOID pImageMemory = GlobalLock(memHandle);\n    memcpy(pImageMemory, blobData, imageSize);\n    GlobalUnlock(memHandle);\n\n    IStream* pStream;\n    HRESULT hr = CreateStreamOnHGlobal(memHandle, TRUE, &pStream);\n\n    // Load GDI+ Image from IStream\n    Image* gdiplusImage = new Image(pStream);\n    if (gdiplusImage->GetLastStatus() != Ok) return -9;\n\n    // Save or manipulate the image as needed\n    CLSID jpegClsid;\n    GetEncoderClsid(L"image/jpeg", &jpegClsid);\n\n    Gdiplus::Status saveStatus = gdiplusImage->Save(L"output.jpg", &jpegClsid);\n    if (saveStatus != Ok) return -10;\n\n    delete gdiplusImage;\n    pStream->Release();\n\n    // Clean up SQL handles\n    SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    SQLDisconnect(hDbc);\n    SQLFreeHandle(SQL_HANDLE_DBC, hDbc);\n    SQLFreeHandle(SQL_HANDLE_ENV, hEnv);\n\n    GdiplusShutdown(gdiplusToken);\n    \n    return 0;\n}\n\n// Function to get encoder CLSID for specific format\nint GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {\n    UINT num = 0;          // number of image encoders\n    UINT size = 0;         // size of the image encoder array in bytes\n\n    ImageCodecInfo* pImageCodecInfo = NULL;\n\n    GetImageEncodersSize(&num, &size);\n    if (size == 0)\n        return -1;  // Failure\n\n    pImageCodecInfo = (ImageCodecInfo*)(malloc(size));\n    if(pImageCodecInfo == NULL)\n        return -1;  // Failure\n\n    GetImageEncoders(num, size, pImageCodecInfo);\n\n    for(UINT j = 0; j < num; ++j) {\n        if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 ) {\n            *pClsid = pImageCodecInfo[j].Clsid;\n            free(pImageCodecInfo);\n            return j;  // Success\n        }    \n    }\n\n    free(pImageCodecInfo);\n    return -1;  // Failure\n}