#include <iostream>\n#include <string>\n#include <regex>\n\nbool isValidURL(const std::string &url) {\n    const std::regex pattern(R"(^(https?|ftp):\/\/[^\s/$.?#].[^\s]*)");\n    return std::regex_match(url, pattern);\n}\n\nstd::string sanitizeHTML(const std::string &input) {\n    // Simple regex to allow only certain tags and attributes\n    std::regex allowed_tags(R"(<(\/)?(b|i|a)( href=['"][^'"]*['"])?>)");\n    std::smatch match;\n    std::string result;\n\n    size_t lastEnd = 0;\n    while (std::regex_search(input.begin() + lastEnd, input.end(), match, allowed_tags)) {\n        result += input.substr(lastEnd, match.position());\n        if (match.size() == 4) { // Full tag with attribute\n            std::string full_tag(match.str());\n            // Check href attribute for valid URLs only\n            size_t hrefStart = match.str(3).find("href='");\n            if (hrefStart != std::string::npos) {\n                size_t valStart = hrefStart + 6;\n                size_t valEnd = match.str(3).rfind("'");\n                if (isValidURL(match.str(3).substr(valStart, valEnd - valStart))) {\n                    result += full_tag;\n                } else {\n                    result += "<" + match.str(1) + match.str(2) + ">";\n                }\n            } else {\n                result += full_tag;\n            }\n        } else { // Single tags\n            result += match.str();\n        }\n        lastEnd = match.position() + match.length();\n    }\n\n    // Append any remaining characters\n    if (lastEnd < input.size()) {\n        result += input.substr(lastEnd);\n    }\n\n    return result;\n}\n\nint main() {\n    std::string input = "<b>Bold</b> <a href='http://example.com'>Link</a> <script>bad()</script>";\n    std::cout << "Original: " << input << std::endl;\n    std::cout << "Sanitized: " << sanitizeHTML(input) << std::endl;\n    return 0;\n}