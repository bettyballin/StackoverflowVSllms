#include <iostream>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <condition_variable>\n\nclass ReadWriteLock {\npublic:\n    void lockRead() {\n        std::unique_lock<std::mutex> lk(m);\n        cond.wait(lk, [this] { return writers == 0; });\n        readers++;\n    }\n\n    void unlockRead() {\n        std::lock_guard<std::mutex> lk(m);\n        if (--readers == 0)\n            cond.notify_one();\n    }\n\n    void lockWrite() {\n        std::unique_lock<std::mutex> lk(m);\n        cond.wait(lk, [this] { return writers == 0 && readers == 0; });\n        writers++;\n    }\n\n    void unlockWrite() {\n        std::lock_guard<std::mutex> lk(m);\n        writers--;\n        cond.notify_all();\n    }\nprivate:\n    int readers = 0;\n    int writers = 0;\n    mutable std::mutex m;\n    std::condition_variable cond;\n};\n\nvoid reader(ReadWriteLock &lock) {\n    lock.lockRead();\n    std::cout << "Reading..." << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    lock.unlockRead();\n}\n\nvoid writer(ReadWriteLock &lock, int id) {\n    lock.lockWrite();\n    std::cout << "Writing by " << id << "..." << std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    lock.unlockWrite();\n}\n\nint main() {\n    ReadWriteLock lock;\n    std::vector<std::thread> threads;\n\n    for (int i = 0; i < 3; ++i) {\n        threads.emplace_back(reader, std::ref(lock));\n    }\n    for (int i = 0; i < 2; ++i) {\n        threads.emplace_back(writer, std::ref(lock), i);\n    }\n\n    for (auto& t : threads) {\n        t.join();\n    }\n\n    return 0;\n}