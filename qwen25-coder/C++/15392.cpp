#include <cstring>\n#include <queue>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n#define V 100 // Maximum number of nodes including sources and sink\n\nbool bfs(int rGraph[V][V], int s, int t, int parent[]) {\n    bool visited[V];\n    memset(visited, 0, sizeof(visited));\n\n    queue<int> q;\n    q.push(s);\n    visited[s] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v = 1; v <= t; v++) {\n            if (visited[v] == false && rGraph[u][v] > 0) {\n                q.push(v);\n                parent[v] = u;\n                visited[v] = true;\n\n                if (v == t)\n                    return true;\n            }\n        }\n    }\n\n    // If we reached sink in BFS starting from source, then return true\n    // else false\n    return false;\n}\n\n// Returns the maximum flow from s to t in the given graph rGraph. rGraph is\n// residual graph and it doesn't include 0-1 multiple edges like the original\n// graph. The 2D array rGraph[i][j] indicates residual capacity of edge i-j\nint fordFulkerson(int rGraph[V][V], int s, int t) {\n    int parent[V]; // This array is filled by BFS and stores path\n\n    int max_flow = 0; // There is no flow initially\n\n    // Augment the flow while there is a augmenting path from source to sink\n    while (bfs(rGraph, s, t, parent)) {\n        // Find minimum residual capacity of the edhes along the path filled by BFS.\n        int path_flow = INT_MAX;\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            path_flow = min(path_flow, rGraph[u][v]);\n        }\n\n        // update residual capacities of the edges and reverse edges along\n        // the path\n        for (int v = t; v != s; v = parent[v]) {\n            int u = parent[v];\n            rGraph[u][v] -= path_flow;\n            rGraph[v][u] += path_flow;\n        }\n\n        max_flow += path_flow;\n    }\n    return max_flow;\n}\n\nvoid findMatch(int graph[V][V], int n, int m) {\n    // Create a residual graph and fill the residual graph with\n    // given capacities in the original graph as given capacity in\n    // residual graph\n    int rGraph[V][V];\n    memset(rGraph, 0, sizeof(rGraph));\n\n    int source = n + m + 1;\n    int sink = source + 1;\n\n    for (int i = 1; i <= n; i++) {\n        rGraph[source][i] = 1; // Connect each male to the source\n    }\n\n    for (int i = 1; i <= m; i++) {\n        rGraph[i + n][sink] = 1; // Connect each female to the sink\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (!graph[i][j]) continue;\n            rGraph[i][j + n] = 1; // Connect each male to matching females\n        }\n    }\n\n    int max_flow = fordFulkerson(rGraph, source, sink);\n\n    cout << "Maximum Match: " << max_flow << endl;\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= m; j++) {\n            if (!graph[i][j] || rGraph[i][j + n])\n                continue;\n            cout << i << "&" << j << " ";\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    int graph[V][V];\n    memset(graph, 0, sizeof(graph));\n\n    // Assuming there are 2 males and 3 females for the given example\n    int n = 2; // Number of males\n    int m = 3; // Number of females\n\n    // Parsing your input (1-based indexing)\n    graph[1][3] = 1;\n    graph[1][5] = 1;\n    graph[2][5] = 1;\n\n    findMatch(graph, n, m);\n}