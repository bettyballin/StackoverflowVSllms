#include <iostream>\n#include <vector>\n#include <limits>\nusing namespace std;\n\nint minDistance = numeric_limits<int>::max();\n\nvoid findPath(const vector<vector<int>>& graph, int node, int visitedCount,\n             const int& n, int currentNodeDistance, int startNode, \n             vector<bool>& visited) {\n    // Check if all nodes have been visited\n    if (visitedCount == n && graph[node][startNode]) {\n        minDistance = min(minDistance, currentNodeDistance + graph[node][startNode]);\n        return;\n    }\n\n    // Explore each node\n    for (int i = 0; i < n; ++i) {\n        // If the node has not been visited and there is an edge to it\n        if (!visited[i] && graph[node][i]) {\n            visited[i] = true;\n            findPath(graph, i, visitedCount + 1, n,\n                     currentNodeDistance + graph[node][i], startNode, visited);\n            visited[i] = false; // Backtrack\n        }\n    }\n}\n\nint main() {\n    int n = 4; // number of vertices in the graph\n    vector<vector<int>> graph = {\n        {0, 10, 15, 20},\n        {10, 0, 35, 25},\n        {15, 35, 0, 30},\n        {20, 25, 30, 0}\n    };\n        \n    vector<bool> visited(n);\n    int startNode = 0;\n    visited[startNode] = true;\n\n    findPath(graph, startNode, 1, n, 0, startNode, visited);\n\n    cout << "Minimum distance of Hamiltonian Cycle: " << minDistance << endl;\n\n    return 0;\n}