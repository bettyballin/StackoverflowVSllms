#include <windows.h>\n#include <Wbemidl.h>\n#pragma comment(lib, "wbemuuid.lib")\n\nvoid ListMemorySlots() {\n    HRESULT hres;\n\n    // Initialize COM library\n    hres = CoInitializeEx(0, COINIT_MULTITHREADED);\n    if (FAILED(hres)) {\n        printf("Failed to initialize COM library. Error code = 0x%x\n", hres);\n        return;\n    }\n\n    // Initialize security for WMI\n    hres = CoInitializeSecurity(\n             NULL,\n             -1,                          // nMaxSessions\n             NULL,                        // pSids\n             NULL,                        // pRestrictedSids\n             RPC_C_AUTHN_LEVEL_CALL,      // dwAuthnLevel\n             RPC_C_IMP_LEVEL_IMPERSONATE, // dwImpLevel\n             NULL,                        // pAuthInfo\n             EOAC_NONE,                   // dwCapabilities\n             NULL                         // pReserved\n         );\n\n    if (FAILED(hres)) {\n        printf("Failed to initialize security. Error code = 0x%x\n", hres);\n        CoUninitialize();\n        return;\n    }\n\n    // Obtain the initial locator to WMI\n    IWbemLocator *pLoc = NULL;\n\n    hres = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,\n                            IID_IWbemLocator, (LPVOID *) &pLoc);\n\n    if (FAILED(hres)) {\n        printf("Failed to create IWbemLocator object. " \\n               "Err code = 0x%x\n", hres);\n        CoUninitialize();\n        return;\n    }\n\n    // Connect to WMI through the IWbemLocator::ConnectServer method\n    IWbemServices *pSvc = NULL;\n\n    // Connect to the local root\cimv2 namespace with the current user security token.\n    hres = pLoc->ConnectServer(\n             BSTR(L"ROOT\\CIMV2"),        // Object path of WMI namespace\n             NULL,                    // User name. NULL = current user\n             NULL,                         // User password. NULL = current\n             0,                           // Locale. NULL indicates current\n             NULL,                        // Security flags.\n             0,                           // Authority\n             0,                           // Context object \n             &pSvc                          // IWbemServices proxy\n         );\n\n    if (FAILED(hres)) {\n        printf("Could not connect. Error code = 0x%x\n", hres);\n        pLoc->Release();\n        CoUninitialize();\n        return;\n    }\n\n    printf("Connected to ROOT\\CIMV2 WMI namespace\n");\n\n    // Set security levels on the proxy -------------------------\n    hres = CoSetProxyBlanket(pSvc,                  // Indicates the proxy to set\n                              RPC_C_AUTHN_WINNT,      // RPC_C_AUTHN_xxx \n                              RPC_C_AUTHZ_NONE,       // RPC_C_AUTHZ_xxx \n                              NULL,                 // Server principal name \n                              RPC_C_AUTHN_LEVEL_CALL, // RPC_C_AUTHN_LEVEL_xxx \n                              RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx\n                              NULL,                 // client identity\n                              EOAC_NONE             // proxy capabilities \n                     );\n\n    if (FAILED(hres)) {\n        printf("Could not set proxy blanket. Error code = 0x%x\n", hres);\n        pSvc->Release();\n        pLoc->Release();     \n        CoUninitialize();\n        return;\n    }\n\n    // Use the IWbemServices pointer to make requests of WMI ----\n\n    IEnumWbemClassObject* pEnumerator = NULL;\n    hres = pSvc->ExecQuery(\n             bstr_t("WQL"), \n             bstr_t("SELECT * FROM Win32_PhysicalMemory"),\n             WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, \n             NULL,\n             &pEnumerator);\n\n    if (FAILED(hres)) {\n        printf("Query for physical memory failed."\n               "Error code = 0x%x\n", hres);\n        pSvc->Release();\n        pLoc->Release();     \n        CoUninitialize();\n        return;\n    }\n\n    // Go through the returned data and print it out\n    IWbemClassObject *pclsObj;\n    ULONG uReturn = 0;\n\n    while (pEnumerator) {\n        HRESULT hr = pEnumerator->Next(WBEM_INFINITE, 1,\n                                        &pclsObj, &uReturn);\n\n        if (0 == uReturn) {\n            break;\n        }\n\n        VARIANT vtProp;\n\n        // Get the value of the Name property\n        hr = pclsObj->Get(L"DeviceID", 0, &vtProp, 0, 0);\n        wprintf(L"\n Device ID: %s", vtProp.bstrVal);\n        VariantClear(&vtProp);\n\n        hr = pclsObj->Get(L"Capacity", 0, &vtProp, 0, 0);\n        if (SUCCEEDED(hr)) {\n            double capacityGB = vtProp.uintVal / (1024 * 1024 * 1024.0); // Convert bytes to GB\n            wprintf(L"\n Capacity: %.2f GB", capacityGB);\n        }\n        VariantClear(&vtProp);\n\n        hr = pclsObj->Get(L"Speed", 0, &vtProp, 0, 0);\n        if (SUCCEEDED(hr)) {\n            wprintf(L"\n Speed: %d MHz", vtProp.uintVal);\n        }\n        VariantClear(&vtProp);\n\n        hr = pclsObj->Get(L"FormFactor", 0, &vtProp, 0, 0);\n        if (SUCCEEDED(hr)) {\n            wprintf(L"\n Form Factor: %d", vtProp.uintVal);\n        }\n        VariantClear(&vtProp);\n\n        pclsObj->Release();\n    }\n\n    // Cleanup\n    // ========\n\n    if (pSvc != NULL)\n        pSvc->Release();\n\n    if (pLoc != NULL)\n        pLoc->Release();\n\n    if (pEnumerator != NULL)\n        pEnumerator->Release();\n\n    CoUninitialize();\n}\n\nint main() {\n    ListMemorySlots();\n    return 0;\n}