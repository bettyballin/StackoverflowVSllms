#include <iostream>\n#include <functional>\n\n// Y-combinator implementation in C++\ntemplate<typename F>\nstruct RecursiveFunc {\n    std::function<F(RecursiveFunc)> f;\n};\n\ntemplate<typename F, typename A>\nauto operator()(const RecursiveFunc<F>& w, A&& arg) -> decltype(w.f(w)(std::forward<A>(arg))) {\n    return w.f(w)(std::forward<A>(arg));\n}\n\ntemplate<typename F>\nstruct YCombinator {\n    std::function<std::function<F(RecursiveFunc<F>)>(std::function<F(RecursiveFunc<F>)>)> f;\n};\n\ntemplate<typename F, typename A>\nauto operator()(const YCombinator<F>& y, A&& arg) -> decltype(y.f(y)(std::forward<A>(arg))) {\n    return y.f(\n        std::function<F(RecursiveFunc<F>)>(\n            [&y](RecursiveFunc<F> w) -> F {\n                return [w](A a) { \n                    return static_cast<std::function<F(A)>>(y.f(y))(w, a); \n                };\n            }\n        )\n    )(std::forward<A>(arg));\n}\n\ntemplate<typename T>\nYCombinator<T(*)(RecursiveFunc<T(*)(RecursiveFunc<T>>>)>>\nmake_y_combinator(T(*func)(RecursiveFunc<T(*)(RecursiveFunc<T>>>))) {\n    return { func };\n}\n\nint main() {\n    // Define a recursive function using Y-combinator for factorial\n    auto fact = make_y_combinator<int(int)>([](const RecursiveFunc<int(int)> self) -> std::function<int(int)> {\n        return [self](int n) {\n            return (n == 0) ? 1 : n * self(n - 1);\n        };\n    });\n\n    int result = fact(5);\n    std::cout << "Factorial of 5 is: " << result << std::endl; // Output: Factorial of 5 is: 120\n\n    return 0;\n}