#include <iostream>\n#include <fstream>\n\nbool getJPEGDimensions(const std::string& filename, int &width, int &height) {\n    std::ifstream file(filename, std::ios::binary);\n    if (!file) return false;\n\n    char buffer[2];\n    if (!file.read(buffer, 2)) return false;\n    \n    // Check for SOI marker\n    if (buffer[0] != 0xFF || buffer[1] != 0xD8) {\n        std::cerr << "Not a valid JPEG file.\n";\n        return false;\n    }\n\n    while (true) {\n        if (!file.read(buffer, 2)) break; // could not read bytes\n        if (buffer[0] != 0xFF) continue;    // marker does not begin with 0xFF\n\n        int length = buffer[1];\n        if (length == 0xD8 || length == 0xE0 || length == 0xE1 || length == 0xEE) { // skip headers of these types\n            continue;\n        }\n\n        file.read(buffer, 2); // read the next two bytes (usually, segment length) into buffer\n        int seglength = ((buffer[0] << 8) | buffer[1]) - 4; // calculate remaining length of the current segment\n\n        if (length == 0xC0 || length == 0xC2) { // SOF0 or SOF2 marker\n            file.read(buffer, 3); seglength -= 3; // skip three bytes\n            if (!file.read(buffer, 4)) break;\n            \n            height = (buffer[0] << 8) | buffer[1]; // get height\n            width = (buffer[2] << 8) | buffer[3];  // get width\n            \n            return true; // succeeded to extract dimensions\n        }\n        \n        file.ignore(seglength); // skip segment body and padding bytes\n    }\n\n    std::cerr << "Failed to find the dimensions!\n";\n    return false;\n}\n\nint main() {\n    int width, height;\n    if (getJPEGDimensions("example.jpg", width, height)) {\n        std::cout << "Width: " << width << ", Height: " << height << '\n';\n    }\n    return 0;\n}