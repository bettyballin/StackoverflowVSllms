#include <openssl/evp.h>\n#include <iostream>\n#include <vector>\n#include <fstream>\n\nvoid handleErrors() {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nint main(int argc, char *argv[]) {\n    // Example password and IV setup (IV should be random for real usage)\n    unsigned char key[] = "0123456789012345"; // 16 bytes long for AES-128\n    unsigned char iv[] = "0123456789012345";  // Initialization vector\n\n    FILE *ifp = fopen("input.txt", "rb");\n    FILE *ofp = fopen("encrypted.enc", "wb");\n\n    if (!ifp || !ofp) {\n        std::cerr << "Cannot open file(s)";\n        return -1;\n    }\n\n    fseek(ifp, 0 , SEEK_END);\n    long lSize = ftell(ifp);\n    rewind(ifp);\n\n    unsigned char *buffer = new unsigned char[lSize];\n    fread(buffer, 1, lSize, ifp);\n\n    fclose(ifp);\n\n    EVP_CIPHER_CTX *ctx;\n\n    int len;\n    int ciphertext_len;\n\n    /* Create and initialize the context */\n    if(!(ctx = EVP_CIPHER_CTX_new())) handleErrors();\n\n    /* Initialize the encryption operation. IMPORTANT - ensure you use a key\n     *   and IV size appropriate for your cipher\n     *   In this example we are using 128 bit AES (i.e. a key size of 16 bytes)\n     *   The IV size for *most* modes is the same as the blocksize */\n    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv))\n        handleErrors();\n\n    /* Provide the message to be encrypted, and obtain the encrypted output.\n     * EVP_EncryptUpdate can be called multiple times if necessary  */\n    if(1 != EVP_EncryptUpdate(ctx, buffer, &len, buffer, lSize))\n        handleErrors();\n    ciphertext_len = len;\n\n    /* Finalize the encryption. Further ciphertext bytes may be written at\n     * this stage.\n     */\n    if(1 != EVP_EncryptFinal_ex(ctx, buffer + len, &len)) handleErrors();\n    ciphertext_len += len;\n\n    /* Clean up */\n    EVP_CIPHER_CTX_free(ctx);\n\n    fwrite(buffer, 1, ciphertext_len, ofp);\n    fclose(ofp);\n    return 0;\n}