#include <stack>\n\nvoid buildPowerNetIterative(powerNetInfo * powerNet, unsigned long startX, unsigned long startY, tilemapData * levelMap) {\n    std::stack<std::pair<unsigned long, unsigned long>> tilesToVisit;\n    tilesToVisit.push({startX, startY});\n    \n    bool * isWalked = new bool[level->mapDimensions[0] * level->mapDimensions[1]];\n    for (unsigned int i = 0; i < level->mapDimensions[0] * level->mapDimensions[1]; ++i) {\n        isWalked[i] = false;\n    }\n\n    while (!tilesToVisit.empty()) {\n        auto [x, y] = tilesToVisit.top();\n        tilesToVisit.pop();\n\n        // If out of bounds or already walked or non-conductive, skip\n        if (x < 0 || x >= level->mapDimensions[0] || y < 0 || y >= level->mapDimensions[1] ||\n            isWalked[x + (y * level->mapDimensions[0])] ||\n            !(level->tiles[levelMap->map[x + (y * level->mapDimensions[0])]]->flags & TILETYPE_CONDUCTIVE)) {\n            continue;\n        }\n\n        // Mark current tile as walked\n        isWalked[x + (y * level->mapDimensions[0])] = true;\n\n        // Check and set powered objects on this tile\n        findSetPoweredObjects(x, y, powerNet);\n\n        // Push adjacent tiles to the stack to visit later\n        tilesToVisit.push({x - 1, y});\n        tilesToVisit.push({x + 1, y});\n        tilesToVisit.push({x, y - 1});\n        tilesToVisit.push({x, y + 1});\n    }\n\n    delete[] isWalked;\n}\n\nbool buildPowerNets(void) {\n    tilemapData * levelMap = level->layers[level->activeMap];\n    for (unsigned long y = 0; y < level->mapDimensions[1]; ++y) {\n        for (unsigned long x = 0; x < level->mapDimensions[0]; ++x) {\n            if (level->tiles[levelMap->map[x + (y * level->mapDimensions[0])]]->flags & TILETYPE_CONDUCTIVE) {\n                // Create new power Net\n                powerNetInfo * powerNet = new powerNetInfo;\n                powerNet->objectsInNet = 0;\n                powerNet->producerId = -1;\n                powerNet->supplyType = POWER_OFF;\n                powerNet->prevSupplyType = POWER_OFF;\n                powerNet->powerFor = 0;\n\n                // Build it using the iterative approach\n                buildPowerNetIterative(powerNet, x, y, levelMap);\n            }\n        }\n    }\n\n    for (int i = 0; i < level->numChunks[CHUNKTYPE_POWEREDDEF]; ++i) {\n        if (level->poweredObjects[i]->powerNet == NULL) return false;\n    }\n    return true;\n}