#include <memory>\n#include <stdexcept>\n#include <cstring>\n\n#ifdef _WIN32\n#include <windows.h>\n#else // Assume Unix-like system\n#include <sys/mman.h>\n#include <unistd.h>\n#endif\n\ntemplate<class _Ty>\nclass SecureMemoryAllocator : public std::allocator<_Ty> {\npublic:\n    using size_type = size_t;\n    using pointer = _Ty*;\n\n    template<class _Other>\n    struct rebind {\n        typedef SecureMemoryAllocator<_Other> other;\n    };\n\n    SecAllocException(const char *msg) : msg_(msg) {}\n    const char* what() const noexcept override { return msg_; }\n\n    SecureMemoryAllocator() = default;\n\n    pointer allocate(size_type n, const void* hint = 0) {\n        size_t allocLen = n * sizeof(_Ty);\n#ifdef _WIN32\n        LPVOID pMem = VirtualAlloc(NULL, allocLen, MEM_COMMIT, PAGE_READWRITE);\n#else\n        pointer pMem = reinterpret_cast<_Ty*>(mmap(nullptr, allocLen, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0));\n#endif\n        if (pMem == nullptr) {\n#ifdef _WIN32\n            throw std::bad_alloc();\n#else\n            throw std::bad_alloc();\n#endif\n        }\n\n#ifdef _WIN32\n        if (!VirtualLock(pMem, allocLen)) {\n            VirtualFree(pMem, 0, MEM_RELEASE);\n            throw SecAllocException("Failed to lock memory");\n        }\n#else\n        if (mlock(pMem, allocLen) != 0) {\n            munmap(pMem, allocLen);\n            throw SecAllocException("Failed to lock memory");\n        }\n#endif\n\n        return reinterpret_cast<pointer>(pMem);\n    }\n\n    void deallocate(pointer p, size_type n) {\n        if (p!=nullptr) {\n            std::memset(p, 0, n * sizeof(_Ty)); // Securely wipe the memory\n#ifdef _WIN32\n            VirtualUnlock(p, n * sizeof(_Ty));\n            VirtualFree(p, 0, MEM_RELEASE);\n#else\n            munlock(p, n * sizeof(_Ty));\n            munmap(p, n * sizeof(_Ty));\n#endif\n        }\n    }\n\nprivate:\n    const char* msg_;\n};\n\ntemplate<class _Ty>\nusing securevector = std::vector<_Ty, SecureMemoryAllocator<_Ty>>;