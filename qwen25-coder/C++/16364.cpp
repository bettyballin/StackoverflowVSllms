#include <windows.h>\n#include <iostream>\n\nvoid CaptureOutput(const char* command) {\n    SECURITY_ATTRIBUTES sa;\n    HANDLE hReadPipe, hWritePipe;\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;\n    sa.lpSecurityDescriptor = NULL;\n\n    if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0)) {\n        std::cerr << "Failed to create pipe\n";\n        return;\n    }\n\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    si.hStdInput = NULL;     // no stdin redirection\n    si.hStdOutput = hWritePipe;\n    si.hStdError = hWritePipe;\n    si.dwFlags |= STARTF_USESTDHANDLES;\n\n    if (!CreateProcess(NULL, (LPSTR)command, NULL, NULL, TRUE,\n                       0, NULL, NULL, &si, &pi)) {\n        std::cerr << "Failed to create process\n";\n        CloseHandle(hWritePipe);\n        CloseHandle(hReadPipe);\n        return;\n    }\n\n    CloseHandle(hWritePipe);\n\n    char outputBuffer[4096];\n    DWORD bytesRead;\n\n    while (ReadFile(hReadPipe, outputBuffer, sizeof(outputBuffer) - 1, &bytesRead, NULL)) {\n        if (bytesRead == 0) break;\n        outputBuffer[bytesRead] = '\0';\n        std::cout << "Output: " << outputBuffer;\n        // Send to web server logic here\n    }\n\n    CloseHandle(hReadPipe);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n}\n\nint main() {\n    CaptureOutput("your_game_server_command_here");\n}