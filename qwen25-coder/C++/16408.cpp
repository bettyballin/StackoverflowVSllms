#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <iostream>\n\n#pragma comment(lib, "wsock32.lib")\n#pragma comment(lib, "libeay32.lib")  // OpenSSL Static Library (link-time)\n#pragma comment(lib, "ssleay32.lib") // OpenSSL SSL Library\n\n// Initialize Winsock and load the certificates\nSSL_CTX *InitServerCTX(void) {\n    const SSL_METHOD *method;\n    SSL_CTX *ctx;\n\n    CRYPTO_malloc_init();        /* For single-thread applications only */\n    ERR_load_crypto_strings();\n    SSL_load_error_strings();\n\n    method = TLS_server_method();  // Create new server-method instance \n    ctx = SSL_CTX_new(method);   /* Create new context */\n    if (!ctx) {\n        ERR_print_errors_fp(stderr);\n        abort();\n    }\n    return ctx;\n}\n\nvoid LoadCertificates(SSL_CTX *ctx, const char* CertFile, const char* KeyFile) {\n    /* set the local certificate from CertFile */\n    if (SSL_CTX_use_certificate_file(ctx, CertFile, SSL_FILETYPE_PEM) <= 0) {\n        ERR_print_errors_fp(stderr);\n        abort();\n    }\n    /* set the private key from KeyFile (may be the same as CertFile) */\n    if (SSL_CTX_use_PrivateKey_file(ctx, KeyFile, SSL_FILETYPE_PEM) <= 0) {\n        ERR_print_errors_fp(stderr);\n        abort();\n    }\n\n    /* verify private key */\n    if (!SSL_CTX_check_private_key(ctx)) {\n        std::cerr << "Private key does not match the public certificate" << std::endl;\n        abort();\n    }\n}\n\nvoid ShowCerts(SSL *ssl) {\n    X509 *cert = SSL_get_peer_certificate(ssl); // Get certificates (if available)\n    if (cert != NULL) {\n        std::cout << "Server certificates:" << std::endl;\n        char* line;\n        line = X509_NAME_oneline(X509_get_subject_name(cert), 0, 0);\n        std::cout << "Subject: " << line << std::endl;\n        free(line);       // free the malloc'ed string\n        line = X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0);\n        std::cout << "Issuer: " << line << std::endl;\n        free(line);       // free the malloc'ed string\n        X509_free(cert);     // free the malloc'ed certificate copy\n    } else {\n        std::cout << "No certificates." << std::endl;\n    }\n}\n\nint OpenListener(int port) {\n    int sd;\n    struct addrinfo hints, *addr;\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;       // IPv4\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = IPPROTO_TCP;\n    hints.ai_flags = AI_PASSIVE;\n\n    std::string portStr = std::to_string(port);\n    if (getaddrinfo(NULL, portStr.c_str(), &hints, &addr)) {\n        perror("getaddrinfo");\n        exit(EXIT_FAILURE);\n    }\n\n    sd = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);\n    if (sd == -1) {\n        perror("socket");\n        freeaddrinfo(addr);\n        exit(EXIT_FAILURE);\n    }\n\n    int optval = 1;\n    setsockopt(sd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n\n    if (bind(sd, addr->ai_addr, addr->ai_addrlen)) {\n        perror("bind");\n        close(sd);\n        freeaddrinfo(addr);\n        exit(EXIT_FAILURE);\n    }\n\n    if (listen(sd, 5) == -1) { // queue up to 5 connect requests\n        perror("listen");\n        close(sd);\n        freeaddrinfo(addr);\n        exit(EXIT_FAILURE);\n    }\n    \n    freeaddrinfo(addr);\n\n    return sd;\n}\n\nvoid Servlet(SSL *ssl) {\n    char buf[1024];\n    int sd, bytes;\n    const char *rep = "I hear you speaking over SSL.\n";\n\n    if (SSL_accept(ssl) == -1) { // do SSL-protocol accept\n        ERR_print_errors_fp(stderr);\n    } else {\n        ShowCerts(ssl);                   // get any certificates\n        bytes = SSL_read(ssl, buf, sizeof(buf)); // get request\n        buf[bytes] = 0;\n        std::cout << "Client msg: \"" << buf << "\" length=" << std::to_string(bytes) << std::endl;\n\n        if (bytes > 0) {\n            SSL_write(ssl, rep, strlen(rep));   // send reply\n        }\n    }\n\n    sd = SSL_get_fd(ssl);           // get socket connection\n    SSL_free(ssl);                    // release SSL state\n    closesocket(sd);                  // close connection from client\n}\n\nint main(void) {\n    WSADATA wsaData;\n    WSAStartup(MAKEWORD(2, 0), &wsaData);\n\n    SSL_CTX *ctx;\n    int server, client;\n\n    ctx = InitServerCTX();        // initialize SSL\n    LoadCertificates(ctx, "server-cert.pem", "server-key.pem"); /* load certs */\n    server = OpenListener(4431);    // create server socket\n\n    while (true) {\n        struct sockaddr_in addr;\n        int len = sizeof(addr);\n        client = accept(server, (SOCKADDR*)&addr, &len);  // get connections\n        std::cout << "Connection: " << inet_ntoa(addr.sin_addr) << ":" << ntohs(addr.sin_port) << std::endl;\n\n        SSL *ssl;                 /* connection using SSL */\n        ssl = SSL_new(ctx);       // get new SSL state with context\n        SSL_set_fd(ssl, client);  // set connection socket to SSL state\n\n        Servlet(ssl);             // service connection\n    }\n\n    closesocket(server);          // close server socket\n    SSL_CTX_free(ctx);            // release context\n\n    WSACleanup();\n\n    return 0;\n}