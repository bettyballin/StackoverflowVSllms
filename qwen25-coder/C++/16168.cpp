#include <windows.h>\n#include <iostream>\n\nint main() {\n    // Get the full path of the currently running executable.\n    char szFilePath[MAX_PATH];\n    DWORD dwPathLen = GetModuleFileNameA(NULL, szFilePath, MAX_PATH);\n    if (!dwPathLen) {\n        std::cerr << "Failed to get module file name." << std::endl;\n        return 1;\n    }\n\n    // Open the executable in read mode with shared access.\n    HANDLE hFile = CreateFileA(szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n    if (hFile == INVALID_HANDLE_VALUE) {\n        std::cerr << "Failed to open file: " << GetLastError() << std::endl;\n        return 1;\n    }\n\n    // Determine the size of the file.\n    LARGE_INTEGER fileSize;\n    if (!GetFileSizeEx(hFile, &fileSize)) {\n        CloseHandle(hFile);\n        std::cerr << "Failed to get file size." << std::endl;\n        return 1;\n    }\n\n    // Map a view of the file into memory for reading.\n    void* pFileData = MapViewOfFile(hFile, FILE_MAP_READ, 0, 0, fileSize.QuadPart);\n    if (!pFileData) {\n        CloseHandle(hFile);\n        std::cerr << "Failed to map file." << std::endl;\n        return 1;\n    }\n\n    // You can now read from pFileData up to fileSize.QuadPart.\n    // Example: Read the last byte of the executable\n    char lastByte = *(((char*)pFileData) + (fileSize.QuadPart - 1));\n    std::cout << "The last byte is: " << static_cast<int>(lastByte) << std::endl;\n\n    // Clean up.\n    UnmapViewOfFile(pFileData);\n    CloseHandle(hFile);\n\n    return 0;\n}