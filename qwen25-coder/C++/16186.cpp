#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<uint64_t> multiply(const std::vector<uint64_t>& num1, const std::vector<uint64_t>& num2) {\n    std::vector<uint64_t> result(num1.size() + num2.size());\n\n    for (size_t i = 0; i < num1.size(); ++i) {\n        uint64_t carry = 0;\n        for (size_t j = 0; j < num2.size(); ++j) {\n            uint128_t prod = (uint128_t)result[i + j] + (uint128_t)num1[i] * num2[j] + carry;\n            result[i + j] = (uint64_t)(prod & 0xFFFFFFFFFFFFFFFF);\n            carry = (uint64_t)(prod >> 64);\n        }\n        if (carry)\n            result[i + num2.size()] += carry;\n    }\n\n    // Remove leading zeros\n    while (result.size() > 1 && result.back() == 0)\n        result.pop_back();\n\n    return result;\n}\n\nstd::string toString(const std::vector<uint64_t>& num) {\n    if (num.empty())\n        return "0";\n\n    const uint32_t BASE = 1000000000; // example base\n    std::vector<uint32_t> decNum;\n    for(auto i : num) {\n        if(i == 0){\n            decNum.push_back(0);\n        } else{\n            while (i > 0) {\n                decNum.push_back(i % BASE);\n                i /= BASE;\n            }\n        }\n    }\n\n    std::string result;\n    bool leadingZero = true;\n    for (auto it = decNum.rbegin(); it != decNum.rend(); ++it) {\n        if (leadingZero && *it == 0)\n            continue;\n        leadingZero = false;\n        result += std::to_string(*it);\n    }\n\n    return result.empty() ? "0" : result;\n}\n\nint main() {\n    // Represent numbers as vectors of 64-bit unsigned integers\n    std::vector<uint64_t> num1({123456789, 987654321}); // Example: 987654321123456789\n    std::vector<uint64_t> num2({987654321, 123456789}); // Example: 123456789987654321\n\n    std::vector<uint64_t> result = multiply(num1, num2);\n\n    std::cout << "Result: " << toString(result) << std::endl;\n\n    return 0;\n}