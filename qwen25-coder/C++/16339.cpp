// Project 5.cpp : main project file.\n\n#include "stdafx.h"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace System;\nusing namespace std;\n\nint checkCommand (string line);\n\ntemplate<typename T>\nvoid writeVector(ofstream &out, const vector<T> &vec);\n\ntemplate<typename T>\nvector<T> readVector(ifstream &in);\n\nstruct InventoryItem {\n    string Item;\n    string Description;\n    int Quantity;\n    int wholesaleCost;\n    int retailCost;\n    int dateAdded;\n};\n\nint main(void)\n{\n    cout << "Welcome to the Inventory Manager extreme! [Version 1.0]" << endl;\n    ifstream in("data.dat", ios::binary); // Open file in binary mode\n    if (in.is_open()) { \n        cout << "File \'data.dat\' has been opened successfully." << endl; \n    } else {\n        cout << "Error opening data.dat" << endl; \n        return 0;\n    }\n    cout << "Loading data..." << endl;\n    vector<InventoryItem> structList = readVector<InventoryItem>( in );\n    cout <<"Load complete." << endl;\n\n    while (1)\n    {\n\n        string line = "";\n        cout << "There are currently " << structList.size() << " items in memory.";\n        cout << endl;\n        cout << "Commands: " << endl;\n        cout << "1: Add a new record " << endl;\n        cout << "2: Display a record " << endl;\n        cout << "3: Edit a current record " << endl;\n        cout << "4: Exit the program " << endl;\n        cout << endl;\n        cout << "Enter a command 1-4: ";\n        getline(cin , line);\n\n        int rValue = checkCommand(line);\n        if (rValue == 1)\n        {\n            cout << "You've entered an invalid command! Try Again." << endl;\n        } else if (rValue == 2){ \n            cout << "Error calling command!" << endl;\n        } else if (!rValue) {\n            break;\n        }\n    }\n\n    system("pause");\n\n    return 0;\n}\n\nint checkCommand (string line)\n{\n    int intReturn = atoi(line.c_str());\n    int status = 3;\n\n    switch (intReturn)\n    {\n        case 1:\n            break;\n        case 2:\n            break;\n        case 3:\n            break;\n        case 4:\n            status = 0;\n            break;\n        default:\n            status = 1;\n            break;\n    }\n    return status;\n}\n\ntemplate<typename T>\nvoid writeVector(ofstream &out, const vector<T> &vec)\n{\n    size_t size = vec.size();\n    out.write(reinterpret_cast<const char*>(&size), sizeof(size));\n\n    for(vector<T>::const_iterator i = vec.begin(); i != vec.end(); i++)\n    {\n        out << *i;\n    }\n}\n\nostream &operator<<(ostream &out, const InventoryItem &i)\n{\n    // Write each field with a size prefix\n    size_t itemSize = i.Item.size();\n    out.write(reinterpret_cast<const char*>(&itemSize), sizeof(itemSize));\n    out.write(i.Item.c_str(), itemSize);\n\n    size_t descSize = i.Description.size();\n    out.write(reinterpret_cast<const char*>(&descSize), sizeof(descSize));\n    out.write(i.Description.c_str(), descSize);\n\n    out.write(reinterpret_cast<const char*>(&i.Quantity), sizeof(i.Quantity));\n    out.write(reinterpret_cast<const char*>(&i.wholesaleCost), sizeof(i.wholesaleCost));\n    out.write(reinterpret_cast<const char*>(&i.retailCost), sizeof(i.retailCost));\n    out.write(reinterpret_cast<const char*>(&i.dateAdded), sizeof(i.dateAdded));\n\n    return out;\n}\n\nistream &operator>>(istream &in, InventoryItem &i)\n{\n    // Read each field with a size prefix\n    size_t itemSize, descSize;\n    in.read(reinterpret_cast<char*>(&itemSize), sizeof(itemSize));\n    i.Item.resize(itemSize);\n    in.read(&i.Item[0], itemSize);\n\n    in.read(reinterpret_cast<char*>(&descSize), sizeof(descSize));\n    i.Description.resize(descSize);\n    in.read(&i.Description[0], descSize);\n\n    in.read(reinterpret_cast<char*>(&i.Quantity), sizeof(i.Quantity));\n    in.read(reinterpret_cast<char*>(&i.wholesaleCost), sizeof(i.wholesaleCost));\n    in.read(reinterpret_cast<char*>(&i.retailCost), sizeof(i.retailCost));\n    in.read(reinterpret_cast<char*>(&i.dateAdded), sizeof(i.dateAdded));\n\n    return in;\n}\n\ntemplate<typename T>\nvector<T> readVector(ifstream &in)\n{\n    size_t size;\n    in.read(reinterpret_cast<char*>(&size), sizeof(size));\n\n    vector<T> vec;\n    vec.reserve(size);\n\n    for(unsigned int i = 0; i < size; i++)\n    {\n        T tmp;\n        in >> tmp;\n        vec.push_back(tmp);\n    }\n\n    return vec;\n}