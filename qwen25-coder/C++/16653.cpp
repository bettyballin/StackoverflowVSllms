#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <thread>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::tcp;\n\nvoid handle_client(tcp::socket sock, std::map<std::string , tcp::endpoint>& clients);\n\nint main() {\n    try {\n        boost::asio::io_context io_context;\n        tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), 1234));\n\n        std::map<std::string, tcp::endpoint> clients; // Map of client names to endpoints\n\n        while (true) {  // Forever loop accepting connections\n            tcp::socket socket(io_context);\n            acceptor.accept(socket);\n\n            std::thread t(handle_client, std::move(socket), std::ref(clients));\n            t.detach();\n        }\n    } catch (std::exception& e) {\n        std::cerr << e.what() << "\n";\n    }\n\n    return 0;\n}\n\nvoid handle_client(tcp::socket sock, std::map<std::string , tcp::endpoint>& clients) {\n    try {\n        boost::asio::streambuf buffer;\n        while(boost::asio::read_until(sock, buffer, '\n') > 0) {\n            std::istream is(&buffer);\n            std::string line;\n            getline(is, line);\n\n            if(line[0] == 'R') { // Register command\n                size_t first_space = line.find(' ');\n                std::string clientname = line.substr(1, first_space - 1);\n                clients[clientname] = sock.remote_endpoint();\n\n                boost::asio::write(sock, boost::asio::buffer("REGISTERED\n"));\n            } else if (line[0] == 'G') { // Get Clients command\n                std::string response;\n                for(const auto& client : clients) {\n                    response += client.first + " " + client.second.address().to_string() + " " +\n                              std::to_string(client.second.port()) + "\n";\n                }\n                boost::asio::write(sock, boost::asio::buffer(response));\n            } else {\n                // Error or unsupported command\n                boost::asio::write(sock, boost::asio::buffer("ERROR\n"));\n            }\n        }\n    } catch (std::exception& e) {\n        std::cerr << "Exception in thread: " << e.what() << "\n";\n    }\n\n}