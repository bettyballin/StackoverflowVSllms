#include <type_traits>\n#include <iostream>\n\n// Define a concept interface\nstruct IFoo {\n    virtual void foo() = 0;\n};\n\n// A class that implements the interface\nclass Bar : public IFoo {\npublic:\n    void foo() override { std::cout << "Bar foo" << std::endl; }\n};\n\n// Another class not implementing the interface\nclass Simpson {};\n\n// Template class with a static assertion to check if T inherits from IFoo\ntemplate<typename T>\nclass Foo {\n    static_assert(std::is_base_of<IFoo, T>::value, "T must inherit from IFoo");\npublic:\n    void callFoo(T* t) { \n        t->foo();\n    }\n};\n\nint main() {\n    Bar bar;\n    Simpson simpson;\n\n    Foo<Bar> fooBar; // This will work\n    fooBar.callFoo(&bar);\n\n    // Foo<Simpson> fooSimpson; // This will cause a compile-time error\n\n    return 0;\n}