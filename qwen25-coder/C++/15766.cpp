#include <stdio.h>\n#include <winsock2.h>\n\nint receive_data(SOCKET sock, unsigned char* buf, size_t len) {\n    size_t currentLen = 0;\n    int result;\n\n    while (currentLen < len) {\n        // Calculate remaining buffer space\n        size_t bufferSize = (len - currentLen > TCP_BlockSize) ? TCP_BlockSize : (len - currentLen);\n        result = recv(sock, (char*)(buf + currentLen), bufferSize, 0);\n\n        if (result == SOCKET_ERROR) {\n            int error = WSAGetLastError();\n            printf("recv failed with error: %d\n", error);\n            return -1; // Error occurred\n        } else if (result == 0) {\n            // Connection closed by the peer\n            break;\n        } else {\n            currentLen += result;\n        }\n    }\n\n    if (currentLen < len) {\n        printf("Received less data than expected: got %zu, expected %zu\n", currentLen, len);\n        return -1; // Did not receive all expected data\n    }\n\n    return 0; // Success\n}\n\nint main() {\n    WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        printf("Failed to initialize Winsock.\n");\n        return -1;\n    }\n\n    SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    // Assume here that the socket is properly connected to the server...\n\n    unsigned int len; // Length of data to receive\n    // ... code to request and receive 'len' ...\n\n    unsigned char *buf = new unsigned char[len];\n    if (receive_data(sock, buf, len) != 0) {\n        printf("Failed to receive all data.\n");\n    } else {\n        printf("All data received successfully.\n");\n        // Process the buffer\n    }\n\n    delete[] buf;\n    closesocket(sock);\n    WSACleanup();\n\n    return 0;\n}