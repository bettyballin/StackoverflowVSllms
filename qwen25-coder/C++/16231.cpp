#include <boost/asio.hpp>\n#include <iostream>\n#include <thread>\n#include <functional>\n\nusing boost::asio::ip::tcp;\n\nvoid session(tcp::socket socket) {\n    try {\n        char data[1024];\n        while (true) {\n            boost::system::error_code error;\n            size_t length = socket.read_some(boost::asio::buffer(data), error);\n            if (error == boost::asio::error::eof)\n                break; // Connection closed cleanly by peer.\n            else if (error)\n                throw boost::system::system_error(error); // Some other error.\n\n            // Process the request and send a response back\n            std::string response = "HTTP/1.1 200 OK\r\nContent-Length: 5\r\nConnection: close\r\n\r\nHello";\n            boost::asio::write(socket, boost::asio::buffer(response));\n        }\n    } catch (std::exception& e) {\n        std::cerr << "Exception in thread: " << e.what() << "\n";\n    }\n}\n\nvoid server(boost::asio::io_context& io_context, short port) {\n    tcp::acceptor acceptor(io_context, tcp::endpoint(tcp::v4(), port));\n   \n    for (;;) {\n        auto socket = std::make_shared<tcp::socket>(io_context);\n        acceptor.accept(*socket);\n\n        boost::asio::post(io_context,\n            [socket]() {\n                session(std::move(*socket));\n            });\n    }\n}\n\nint main() {\n    try {\n        const short port = 8000;\n        boost::asio::io_context io_context;\n\n        std::vector<std::thread> threads;\n        for (std::size_t i = 0; i < std::thread::hardware_concurrency(); ++i) {\n            threads.emplace_back([&io_context](){ io_context.run(); });\n        }\n\n        server(io_context, port);\n\n        for (auto& thread : threads)\n            thread.join();\n    } catch (std::exception& e) {\n        std::cerr << "Exception: " << e.what() << "\n";\n    }\n\n    return 0;\n}