#include <vector>\n#include <algorithm>\n\nstruct Point {\n    int x;\n    int y;\n};\n\n// Function to compute intersections and sort them\nvoid fillPolygonScanline(std::vector<Point>& polygon, unsigned char* buffer, int width, int height, unsigned char color) {\n    std::vector<std::pair<int, float>> activeEdges;\n\n    for (size_t i = 0; i < polygon.size(); ++i) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[(i + 1) % polygon.size()];\n\n        int yMax = std::max(p1.y, p2.y);\n        int yMin = std::min(p1.y, p2.y);\n\n        if (yMax < 0 || yMin >= height) continue; // Skip lines outside the viewport\n\n        for (int y = yMin; y <= yMax; ++y) {\n            float xIntersect = ((float)(p1.x - p2.x) / (p1.y - p2.y)) * (y - p1.y) + p1.x;\n\n            if (p1.y > p2.y)\n                activeEdges.emplace_back(y, xIntersect);\n            else\n                activeEdges.emplace_back(y, xIntersect);\n        }\n    }\n\n    std::sort(activeEdges.begin(), activeEdges.end());\n\n    int scanline = 0;\n    while (!activeEdges.empty()) {\n        auto it = partition(activeEdges.begin(), activeEdges.end(), [scanline](const std::pair<int, float>& edge) {\n            return edge.first <= scanline; });\n\n        for (auto L = activeEdges.begin(); L < it;) {\n            auto R = std::find_if(L + 1, it, [](const std::pair<int, float>& edge) {\n                return edge.second > (*L).second; });\n            if (R != it) {\n                int xStart = static_cast<int>((*L).second + 0.5f);\n                int xEnd = static_cast<int>((*R).second - 0.5f);\n\n                for (int x = std::max(xStart, 0); x <= std::min(xEnd, width - 1); ++x) {\n                    buffer[scanline * width + x] = color;\n                }\n\n                L += 2; // Move to next pair of intersections\n            } else {\n                activeEdges.erase(L);\n            }\n        }\n\n        scanline++;\n        if (it == activeEdges.begin()) {\n            activeEdges.erase(it);\n        }\n    }\n}