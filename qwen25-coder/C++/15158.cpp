template<class ForwardIt1, class ForwardIt2>\nvoid merge_without_buffer(ForwardIt1 first, ForwardIt1 middle, ForwardIt1 last) {\n    auto itLeft = first;\n    auto itRight = middle;\n\n    while (itLeft != middle && itRight != last) {\n        if (*itRight < *itLeft) { // if the right element is smaller\n            rotate(itLeft, next(itLeft), ++itRight); // move it to the left partition and advance right iterator\n        } else {\n            ++itLeft; // otherwise, just advance the left iterator\n        }\n    }\n\n    // No need to handle remaining elements in the right subrange because they are already in place.\n}