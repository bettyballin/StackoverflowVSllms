// Pseudo-code for plugin-side verification in C++\nbool verifySignature(const std::string& data, const std::vector<unsigned char>& signature) {\n    // Load public key\n    FILE* publicKeyFile = fopen("path/to/public/key.pem", "r");\n    RSA* publicKey = PEM_read_RSAPublicKey(publicKeyFile, nullptr, nullptr, nullptr);\n    fclose(publicKeyFile);\n\n    EVP_PKEY* pkey = EVP_PKEY_new();\n    EVP_PKEY_set1_RSA(pkey, publicKey);\n    \n    // Decode base64 signature\n    BIO *bio, *b64;\n    BUF_MEM *bufferPtr;\n\n    b64 = BIO_new(BIO_f_base64());\n    bio = BIO_new_mem_buf(signature.data(), -1); // read  until EOF\n    bio = BIO_push(b64, bio);\n\n    BIO_get_mem_ptr(bio, &bufferPtr);\n    std::vector<unsigned char> decodedSignature(bufferPtr->length);\n    BIO_read(bio, (void*)decodedSignature.data(), bufferPtr->length);\n    BIO_free_all(bio);\n\n    // Verify signature\n    EVP_MD_CTX* ctx = EVP_MD_CTX_new();\n    int verified = EVP_DigestVerifyInit(ctx, nullptr, EVP_sha256(), nullptr, pkey);\n    if (!verified) return false;\n\n    verified = EVP_DigestVerifyUpdate(ctx, data.data(), data.size());\n    if (!verified) return false;\n    \n    verified = EVP_DigestVerifyFinal(ctx, decodedSignature.data(), decodedSignature.size());   \n    if (1 == verified) {\n        printf("Signature is valid.\n");\n        // Check domain here against stored hashes\n        return true; \n    } else {\n        printf("Signature verification failed!\n");\n        return false;\n    }\n\n    EVP_MD_CTX_free(ctx);\n    RSA_free(publicKey);\n    EVP_PKEY_free(pkey);    \n}