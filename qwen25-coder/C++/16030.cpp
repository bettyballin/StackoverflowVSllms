#include <iostream>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <cstdlib>\n#include <cstring>\n#include <unistd.h>\n#include <sstream>\n\n#define BUFFER_SIZE 1024 // Increased buffer size\n\nint main() {\n    int socketFileDescriptor = /* Assume this is initialized */;\n    char *buffer = new char[BUFFER_SIZE + 1]; // Extra space for null terminator\n    std::stringstream readStream;\n    bool readData = true;\n    int totalReads = 0;\n    const int maxReads = 1000; // Limit to prevent infinite loops\n\n    while (readData && totalReads < maxReads) {\n        std::cout << "Receiving chunk... ";\n\n        bzero(buffer, BUFFER_SIZE + 1); // Clear the buffer and make sure it's null-terminated\n        int readResult = read(socketFileDescriptor, buffer, BUFFER_SIZE);\n        \n        if (readResult < 0) {\n            perror("Error reading from socket");\n            exit(EXIT_FAILURE);\n        } else if (readResult == 0) { // Connection closed by peer\n            std::cerr << "Connection closed by remote host." << std::endl;\n            break;\n        }\n\n        buffer[readResult] = '\0'; // Null-terminate the received data\n        readStream << buffer;\n\n        // Check for "end;" in the accumulated string\n        if (readStream.str().find("end;") != std::string::npos) {\n            readData = false;\n        }\n\n        std::cout << "Done (length: " << readStream.str().length() << ")" << std::endl;\n        totalReads++;\n    }\n\n    delete[] buffer; // Clean up memory\n    close(socketFileDescriptor); // Close the socket\n\n    return 0;\n}