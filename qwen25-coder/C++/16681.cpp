#include <iostream>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n\nusing Edge = std::tuple<int, int, int>; // From Node ID, To Node ID, Weight\n\nclass Graph {\npublic:\n    Graph(int size) : nodes(size), positions(size) {}\n\n    void addEdge(int from, int to, int weight) {\n        adjList[from][to] = weight;\n        adjList[to][from] = weight; // Ensure undirected graph\n        // Store initial position of nodes for resetting and verifying swaps\n        if (positions[from].empty()) positions[from].insert(from);\n        if (positions[to].empty()) positions[to].insert(to);\n    }\n\n    void swapHeaviestEdge() {\n        // Find the heaviest edge\n        int maxWeight = 0;\n        Edge heaviest;\n        for (const auto& [node, neighbors] : adjList) {\n            for (const auto& [neighbor, weight] : neighbors) {\n                if (weight > maxWeight) {\n                    maxWeight = weight;\n                    heaviest = {node, neighbor, weight};\n                }\n            }\n        }\n\n        if (maxWeight == 0) return; // No more swaps possible\n\n        int nodeA = std::get<0>(heaviest);\n        int nodeB = std::get<1>(heaviest);\n\n        // Swap the nodes by updating positions\n        auto posSetOfNodeA = positions[nodeA];\n        auto posSetOfNodeB = positions[nodeB];\n\n        for (int i : posSetOfNodeA) positions[i].erase(i); \n        for (int i : posSetOfNodeB) positions[i].erase(i);\n\n        positions[nodeB] = posSetOfNodeA;\n        positions[nodeA] = posSetOfNodeB;\n\n        // Reset weights involving the swapped nodes\n        std::set<int> nodesToReset{nodeA, nodeB};\n        for (int node : nodesToReset) {\n            for (auto& [neighbor, weight] : adjList[node]) {\n                adjList[neighbor].erase(node);\n                adjList[node][neighbor] = 0; // or remove edge\n            }\n        }\n\n        printGraphState();\n    }\n\n    void printGraphState() const {\n        std::cout << "Current graph state:\n";\n        for (const auto& [node, positionsSet] : positions) {\n            if (!positionsSet.empty()) {\n                std::cout << "Node " << node << " at position ";\n                for (int pos : positionsSet) std::cout << pos << ",";\n                std::cout << "\n";\n            }\n        }\n    }\n\nprivate:\n    std::vector<std::map<int, int>> adjList; // adjacency list with weights\n    std::vector<std::set<int>> positions;      // position tracking for nodes\n};\n\nint main() {\n    Graph g(4);\n    g.addEdge(0, 1, 100); // A-B\n    g.addEdge(2, 3, 150); // C-D\n    g.addEdge(0, 2, 120); // A-C\n    g.addEdge(1, 3, 220); // B-D\n\n    g.swapHeaviestEdge(); // First swap BD -> next state AC,DB\n    g.swapHeaviestEdge(); // Next swap CB -> final state CADB\n\n    return 0;\n}