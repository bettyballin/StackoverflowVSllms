#include <iostream>\n#include <chrono>\n#include <functional>\n\ntemplate<typename Function>\nclass Timer {\npublic:\n    // Store a copy of the function object, so we don't have dangling references.\n    Timer(Function fct) : fct_(std::move(fct)), elapsed_time_{0} {}\n\n    template<typename... Args>\n    auto operator()(Args&&... args) -> decltype(fct_(args...)) {\n        using ret_type = decltype(fct_(args...));\n        \n        auto start = std::chrono::high_resolution_clock::now();\n        ret_type result = fct_(std::forward<Args>(args)...);\n        auto end = std::chrono::high_resolution_clock::now();\n\n        elapsed_time_ += std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();\n        \n        return result;\n    }\n\n    long GetElapsedTime() const { return elapsed_time_; }\n\nprivate:\n    Function fct_;\n    mutable long elapsed_time_;\n};\n\ndouble foo(int x) {\n    // Simulate a time-consuming task\n    for (int i = 0; i < x * 1000000; ++i) {}\n    return static_cast<double>(x);\n}\n\nint main() {\n    Timer<decltype(&foo)> timed_foo(&foo);\n\n    double a = timed_foo(3);\n    double b = timed_foo(2);\n    double c = timed_foo(5);\n\n    std::cout << "Elapsed: " << timed_foo.GetElapsedTime() << " microseconds" << std::endl;\n\n    return 0;\n}