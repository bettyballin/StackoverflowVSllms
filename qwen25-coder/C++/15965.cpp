// Features for a safe C++ plug-in system\n\n// Use abstract classes for polymorphism, but beware of vtable layout differences.\n// Solution: Define a minimal interface using C-style function pointers or simple virtual functions.\nclass PluginInterface {\npublic:\n    virtual ~PluginInterface() {}\n    virtual void doWork() = 0; // Pure virtual function\n};\n\n// Built-in types and pointers are generally safe to use across different compilers for inter-module communication.\nint* createIntegerPointer();\n\n// Structs and unions can be used safely, but layout packing rules might vary.\nstruct PluginConfig {\n    int id;\n    double version;\n};\n\n// Exceptions should be avoided between plugins and host if cross-compiler compatibility is a concern.\n// Instead, use return codes or other error handling mechanisms.\n\n// extern "C" functions are safe as long as the function signatures do not require C++ name mangling.\nextern "C" {\n    int pluginRegister(PluginInterface* plugin);\n}\n\n// stdcall calling convention can be used safely with built-in parameter types across different compilers on Windows.\n#ifdef _WIN32\n__stdcall void callMeBack(int arg1, float arg2); // On Windows\n#else\nvoid callMeBack(int arg1, float arg2); // On other platforms, avoid stdcall\n#endif\n\n// Avoid using non-extern "C" functions with user-defined parameter types across different compilers.\n// Instead, use simple data structures for passing complex parameters or encode them in a standard format like JSON.