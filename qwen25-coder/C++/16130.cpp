#include <windows.h>\n#include <iostream>\n\nvoid CreateChildProcess() {\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    ZeroMemory(&pi, sizeof(pi));\n\n    // Start the child process.\n    if (!CreateProcess(\n        NULL,   // No module name (use command line).\n        "notepad.exe",        // Command line.\n        NULL,           // Process handle not inheritable.\n        NULL,           // Thread handle not inheritable.\n        FALSE,          // Set handle inheritance to FALSE.\n        0,              // No creation flags.\n        NULL,           // Use parent's environment block.\n        NULL,           // Use parent's starting directory. \n        &si,            // Pointer to STARTUPINFO structure.\n        &pi)            // Pointer to PROCESS_INFORMATION structure.\n    ) {\n        std::cerr << "CreateProcess failed (" << GetLastError() << ").\n";\n        return;\n    }\n\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n\n    // Child process is now running.\n}\n\nint main() {\n    HANDLE hJob = CreateJobObject(NULL, NULL);\n\n    JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {0};\n    jeli.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n\n    if (!SetInformationJobObject(hJob, JobObjectExtendedLimitInformation,\n                                 &jeli, sizeof(jeli))) {\n        std::cerr << "Failed to set job information (" << GetLastError() << ").\n";\n        return 1;\n    }\n\n    // Assign the child process to the job object\n    CreateChildProcess();\n\n    AssignProcessToJobObject(hJob, GetCurrentProcess());\n\n    // The parent will now wait for some input or timeout before exiting\n    std::cout << "Parent is running. Press Enter to exit...\n";\n    getchar();  // Wait until user hits enter\n\n    CloseHandle(hJob);  // This will cause the child process to also be killed\n\n    return 0;\n}