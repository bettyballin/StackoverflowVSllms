#include <glm/glm.hpp>\n#include <cmath>\n\nbool canSeeGameObject(const glm::vec3& observerPosition, const glm::vec3& observerDirection,\n                      float fieldOfViewRadians, float maxRange,\n                      const glm::vec3& targetPosition)\n{\n    // Calculate the direction vector from the observer to the target\n    glm::vec3 directionToTarget = targetPosition - observerPosition;\n    float distance = glm::length(directionToTarget);\n    \n    // Check if the target is within view range\n    if (distance > maxRange) {\n        return false;\n    }\n\n    // Normalize the direction vector to get a unit vector\n    directionToTarget /= distance;\n\n    // Calculate the dot product between the observer's direction and directionToTarget\n    float dotProduct = glm::dot(observerDirection, directionToTarget);\n\n    // Get the angle in radians using arccos of the dot product\n    float angleBetweenVectors = std::acos(dotProduct);\n    \n    // Check if the target is within the field of view\n    return angleBetweenVectors <= (fieldOfViewRadians / 2.0f);\n}\n\nint main() {\n    glm::vec3 observerPosition(0, 0, 0);\n    glm::vec3 observerDirection(1, 0, 0); // Observer facing right\n    float fieldOfViewDegrees = 45.0f;\n    float maxRange = 100.0f;\n    glm::vec3 targetPosition(70, 0, 0);\n\n    #define PI 3.14159265\n\n    bool isVisible = canSeeGameObject(observerPosition, observerDirection,\n                                      fieldOfViewDegrees * (PI / 180), maxRange,\n                                      targetPosition);\n    \n    if (isVisible) {\n        // Target is within view range and angle\n    } else {\n        // Target is not visible\n    }\n\n    return 0;\n}