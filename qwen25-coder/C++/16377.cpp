#include <windows.h>\n#include <gdiplus.h>\nusing namespace Gdiplus;\n\n// Function to get the CLSID for JPEG format\nint GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {\n    UINT num;          // number of image encoders\n    UINT size;         // size of the image encoder array in bytes\n\n    ImageCodecInfo* pImageCodecInfo = NULL;\n\n    GetImageEncodersSize(&num, &size);\n    if(size == 0)\n        return -1;  // Failure\n\n    pImageCodecInfo = (ImageCodecInfo*)(malloc(size));\n    if(pImageCodecInfo == NULL)\n        return -1;  // Failure\n\n    GetImageEncoders(num, size, pImageCodecInfo);\n\n    for(UINT j = 0; j < num; ++j) {\n        if( wcscmp(pImageCodecInfo[j].MimeType, format) == 0 ) {\n            *pClsid = pImageCodecInfo[j].Clsid;\n            free(pImageCodecInfo);\n            return j;  // Success\n        }    \n    }\n\n    free(pImageCodecInfo);\n    return -1;  // Failure\n}\n\n// Main code\nGdiplus::Bitmap bitmap(hBackBitmap, NULL); ///loading the HBITMAP\nCLSID clsid;\nGetEncoderClsid(L"image/jpeg", &clsid);\nHGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, 0); // No initial allocation size needed\nif(!hGlobal)\n    return;\n\nIStream* pStream = NULL;\nif(CreateStreamOnHGlobal(hGlobal, TRUE, &pStream) != S_OK )\n    return;\n\n// Save bitmap to stream as JPEG\nbitmap.Save(pStream, &clsid);\n\n// Get the size of the stream\nULARGE_INTEGER size;\npStream->Seek(ULARGE_INTEGER(), STREAM_SEEK_END, &size);\nULONGLONG jpegSize = size.QuadPart;\npStream->Seek(ULARGE_INTEGER(), STREAM_SEEK_SET, NULL); // Rewind to the beginning\n\n// Lock the global memory and get a pointer\nvoid* pImageMemory = GlobalLock(hGlobal);\nif (!pImageMemory)\n    return;\n\n// Now you can use pImageMemory with jpegSize to manipulate or send data over the internet\n\n// ... (your code for sending data)\n\n// Cleanup\nGlobalUnlock(hGlobal);\npStream->Release();\n\n// Optionally, free the global memory if done with it\nGlobalFree(hGlobal);