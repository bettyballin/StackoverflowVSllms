from collections import defaultdict\nimport hashlib\n\nclass Node:\n    def __init__(self, other_data):\n        self.other_data = other_data\n        self.children = []\n        self.parent = self  # For Union-Find\n        self.rank = 0      # For Union-Find\n\n# Find with path compression\ndef find(node):\n    if node.parent != node:\n        node.parent = find(node.parent)\n    return node.parent\n\n# Union by rank\ndef union(node1, node2):\n    root1, root2 = find(node1), find(node2)\n    if root1 == root2:\n        return\n    if root1.rank < root2.rank:\n        root1.parent = root2\n    elif root1.rank > root2.rank:\n        root2.parent = root1\n    else:\n        root2.parent = root1\n        root1.rank += 1\n\n# Generate a signature for the node to use in the hash\ndef generate_signature(node):\n    children_hashes = [find(child).__hash__() for child in node.children]\n    return hashlib.md5((node.other_data + ''.join(map(str, sorted(children_hashes)))).encode()).hexdigest()\n\n# Hash table to hold nodes by their signature\nnodes_by_signature = defaultdict(set)\n\n# Function to add a new node and find its equivalence class\ndef create_node(other_data, children):\n    new_node = Node(other_data)\n    new_node.children = children\n\n    # Generate the signature based on "other data" and the equivalence classes of children\n    sig = generate_signature(new_node)\n    \n    existing_nodes = nodes_by_signature[sig]\n    if existing_nodes:\n        canonical_node = next(iter(existing_nodes))\n        union(canonical_node, new_node)\n    else:\n        # New class\n        nodes_by_signature[sig].add(new_node)\n\n    return new_node\n\n# Example usage\nroot1 = create_node("data", [])\nchild1 = create_node("child_data", [])\nunion(root1, child1)