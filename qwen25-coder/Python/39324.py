import multiprocessing as mp\nfrom ctypes import cdll, c_bool, c_int\n\n# Load your shared library\nlib = cdll.LoadLibrary('./your_library.so')\n\n# Define a function that will be executed by the worker process\ndef worker(shared_stop_event, result_queue):\n    # Pass the stop event flag to C function\n    lib.your_function.argtypes = [c_bool]\n    lib.your_function.restype = c_int\n\n    while not shared_stop_event.is_set():\n        # Call your long-running function from the .so/.dll\n        partial_result = lib.your_function(shared_stop_event.is_set())\n        \n        if shared_stop_event.is_set():\n            break\n    \n    result_queue.put(partial_result)\n\ndef main():\n    # Create a manager for inter-process communication\n    manager = mp.Manager()\n    \n    # Share an event that will be used to signal stop\n    shared_stop_event = manager.Event()\n    \n    # Create a queue to receive partial results from the worker process\n    result_queue = mp.Queue()\n    \n    # Start the worker process\n    p = mp.Process(target=worker, args=(shared_stop_event, result_queue))\n    p.start()\n\n    # Simulate some work or UI response loop here\n    try:\n        while True:  # Replace with your actual stopping condition\n            user_input = input("Type 'stop' to terminate early:\n")\n            if user_input == 'stop':\n                shared_stop_event.set()\n                break\n    except KeyboardInterrupt:\n        shared_stop_event.set()\n\n    p.join()  # Wait for the process to finish\n\n    # Retrieve and print final result from the queue\n    print("Final (or partial) result:", result_queue.get())\n\nif __name__ == '__main__':\n    main()