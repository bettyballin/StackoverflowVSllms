class DAG:\n    def __init__(self):\n        self.graph = {}  # Adjacency list representation\n\n    def add_node(self, node):\n        if node not in self.graph:\n            self.graph[node] = set()\n\n    def add_edge(self, from_node, to_node):\n        # Ensure that adding this edge does not create a cycle\n        # This is a simplified version without full cycle detection logic\n        if to_node not in self.find_reachable_nodes(from_node):\n            self.graph[from_node].add(to_node)\n        else:\n            raise ValueError("Adding this edge would form a cycle")\n\n    def find_reachable_nodes(self, start_node):\n        # Use DFS or BFS to find all reachable nodes from a given start node\n        visited = set()\n        stack = [start_node]\n        while stack:\n            current_node = stack.pop()\n            if current_node in visited:\n                continue\n            visited.add(current_node)\n            stack.extend(self.graph[current_node] - visited)\n        return visited\n\n# Example usage:\ndag = DAG()\ndag.add_node('A')\ndag.add_node('B')\ndag.add_edge('A', 'B')  # Valid insertion\n# dag.add_edge('B', 'A')  # This would raise an error, as it forms a cycle