import heapq\n\ndef max_min_path(graph, source, target):\n    # Priority queue to store (negative of min_weight, current_node)\n    pq = [(-float('inf'), source)]\n    visited = set()\n    \n    while pq:\n        min_weight, node = heapq.heappop(pq)\n        min_weight = -min_weight  # Convert back to positive\n\n        if node == target:\n            return min_weight\n\n        if node in visited:\n            continue\n        visited.add(node)\n\n        for neighbor, weight in graph[node]:\n            # New minimum weight considering current path's minimum weight\n            new_min_weight = min(min_weight, weight)\n            heapq.heappush(pq, (-new_min_weight, neighbor))\n    \n    return 0  # If no path is found\n\n# Example usage:\ngraph = {\n    'A': [('B', 10), ('C', 2)],\n    'B': [('D', 1)],\n    'C': [('D', 2)],\n    'D': []\n}\n\nsource = 'A'\ntarget = 'D'\nprint(max_min_path(graph, source, target))  # Output: 2