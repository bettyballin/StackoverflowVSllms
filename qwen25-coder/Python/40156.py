def smallest_interval_modulo_n(angles, N=360):\n    # Normalize angles to be within [0, N)\n    normalized_angles = [angle % N for angle in angles]\n    \n    # Create an extended list of angles including their modulo N counterparts\n    extended_angles = normalized_angles + [(angle + N) % N for angle in angles]\n    \n    # Sort all the angles\n    extended_angles.sort()\n    \n    # Initialize the minimum interval to a large number\n    min_interval = float('inf')\n    \n    # Use two pointers to find the smallest interval\n    original_count = len(normalized_angles)\n    num_angles = len(extended_angles)\n    \n    for i in range(original_count):\n        j = i + original_count - 1\n        if j >= num_angles:\n            break\n        min_interval = min(min_interval, extended_angles[j] - extended_angles[i])\n        \n        # Also check the interval starting from i by considering circular wrap-around\n        if i + 1 < num_angles:\n            min_interval = min(min_interval, N - (extended_angles[i+1] - extended_angles[i]))\n    \n    return min_interval\n\n# Example usage:\nangles = [350, 10, 20, 340]\nN = 360\nprint(smallest_interval_modulo_n(angles, N))  # Output should be smallest interval size containing all angles in a circle of 360 degrees.