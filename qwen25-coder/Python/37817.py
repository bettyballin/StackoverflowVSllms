class Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\n\ndef invert_dag(root_nodes):\n    # Dictionary to hold the new nodes with reversed edges\n    new_node_map = {}\n    \n    # Stack for DFS traversal\n    stack = list(root_nodes)\n    \n    while stack:\n        current_node = stack.pop()\n        \n        if current_node not in new_node_map:\n            new_node_map[current_node] = Node(current_node.value)\n        \n        # Traverse and invert edges\n        for child in current_node.children:\n            if child not in new_node_map:\n                new_node_map[child] = Node(child.value)\n            \n            # Add reversed edge\n            new_node_map[child].children.append(new_node_map[current_node])\n            \n            # Continue DFS traversal\n            stack.append(child)\n    \n    # Collect the new root nodes (nodes with no incoming edges in the inverted graph)\n    inverted_roots = [node for node in new_node_map.values() if not any(node in other.children for other in new_node_map.values())]\n    \n    return inverted_roots, new_node_map\n\n# Example usage:\n# Create DAG\nA = Node('A')\nB = Node('B')\nC = Node('C')\nD = Node('D')\nE = Node('E')\nF = Node('F')\nG = Node('G')\n\n# Set up relationships (original graph)\nA.children.extend([B, C])\nB.children.append(G)\nC.children.extend([E, D])\nE.children.append(F)\nD.children.append(F)\n\n# Invert DAG\ninverted_roots, inverted_graph = invert_dag([A])\n\n# Print new root nodes of the inverted graph\nprint("Inverted Root Nodes:", [node.value for node in inverted_roots])