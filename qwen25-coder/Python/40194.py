def min_lengths_needed(target_length):\n    bitstrings = []\n    lengths = [1]  # Start with the first bit length\n\n    while len(bitstrings) < target_length:\n        # Generate all possible bitstrings of the current length\n        new_bitstrings = ['{0:0{b}b}'.format(i, b=lengths[-1]) for i in range(2 ** lengths[-1])]\n        \n        # Filter out strings that have prefixes already existing in bitstrings\n        valid_new_bitstrings = []\n        for bs in new_bitstrings:\n            prefix_free = True\n            for b in bitstrings:\n                if b.startswith(bs) or bs.startswith(b):\n                    prefix_free = False\n                    break\n            if prefix_free:\n                valid_new_bitstrings.append(bs)\n        \n        # Add valid strings to our list of bitstrings\n        bitstrings.extend(valid_new_bitstrings)\n\n        # If we haven't reached the target length, add a new length\n        if len(bitstrings) < target_length:\n            lengths.append(lengths[-1] + 1)\n\n    return sum(lengths), bitstrings\n\n# Example usage for finding the cost of N = 32768\ntarget_length = 32768\ncost, bitstrings = min_lengths_needed(target_length)\nprint(f"The minimum cost for {target_length} is: {cost}")