def is_valid_graph(graph, start, end):\n    def dfs(node, visited, path):\n        # If we reach a dead end but it's not the end node\n        if len(graph[node]) == 0 and node != end:\n            return False\n        \n        # Add the current node to the path\n        path.add(node)\n        \n        # Recur for all the vertices adjacent to this vertex\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                \n                # If a cycle is detected, or a dead end is found that's not 'end', return False\n                if neighbor in path or not dfs(neighbor, visited, path):\n                    return False\n                \n                visited.remove(neighbor)\n        \n        # Remove the current node from the path\n        path.discard(node)\n        \n        # If we reach the end node, return True\n        return node == end\n\n    visited = set()\n    path = set()\n    visited.add(start)\n    \n    # If all paths lead to end and no cycles are found, it's a valid graph\n    for neighbor in graph[start]:\n        if not dfs(neighbor, visited, path):\n            return False\n    \n    return True\n\n# Example usage:\ngraph = {\n    'start': ['n1'],\n    'n1': ['n2', 'n5'],\n    'n2': ['n3', 'n5'],\n    'n3': ['n4', 'n6'],\n    'n4': ['end', 'n7'],\n    'n5': ['n8'],\n    'n6': ['n9', 'end'],\n    'n7': ['n10'],\n    'n8': ['n9'],\n    'n9': ['n10'],\n    'n10': ['n11'],\n    'n11': [],\n    'end': []\n}\n\nprint(is_valid_graph(graph, 'start', 'end'))  # Output: True or False depending on the graph structure