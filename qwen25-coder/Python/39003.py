from collections import deque\n\ndef bfs_shortest_path(graph, start, goal):\n    # keep track of explored nodes\n    explored = set()\n    # keep track of all the paths to be checked\n    queue = deque([[start]])\n    \n    # return path if start is goal\n    if start == goal:\n        return [start]\n    \n    while queue:\n        # pop the first path from the queue\n        path = queue.popleft()\n        # get the last node from the path\n        node = path[-1]\n        \n        if node not in explored:\n            neighbours = graph[node]\n            \n            for neighbour in neighbours:\n                new_path = list(path)\n                new_path.append(neighbour)\n                queue.append(new_path)\n                \n                # Return path if neighbour is goal\n                if neighbour == goal:\n                    return new_path\n            \n            # mark node as explored\n            explored.add(node)\n\n    return None  # In case there's no path\n\n# Graph represented as adjacency list\ngraph = {\n    'A': ['B', 'C'],\n    'B': ['D', 'E'],\n    'C': ['D'],\n    'D': ['E'],\n    'E': []\n}\n\nprint(bfs_shortest_path(graph, 'A', 'E'))  # Output should be ['A', 'B', 'E']