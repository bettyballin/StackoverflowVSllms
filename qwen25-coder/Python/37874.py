def bfs(matched, level, n):\n    queue = []\n    for u in range(n):\n        if not matched[u]:\n            level[u] = 0\n            queue.append(u)\n        else:\n            level[u] = -1\n\n    level[-1] = -1\n    while queue:\n        u = queue.pop(0)\n        if level[u] < level[-1]:\n            for v in adj[u]:  # adj is the adjacency list of the graph representing job-machine connections\n                if level[matched[v]] == -1:\n                    level[matched[v]] = level[u] + 1\n                    queue.append(matched[v])\n\n    return level[-1] != -1\n\ndef dfs(u, level):\n    if u != -1:\n        for v in adj[u]:\n            if level[matched[v]] == level[u] + 1:\n                if dfs(matched[v], level):\n                    matched[v] = u\n                    matched[u] = v\n                    return True\n        level[u] = -1\n        return False\n\ndef hopcroft_karp():\n    result = 0\n    while bfs(matched, level, len(adj)):\n        for u in range(len(adj)):\n            if not matched[u]:\n                if dfs(u, level):\n                    result += 1\n    return result\n\n# Example usage:\nadj = [\n    [1], # job 0 can be assigned to machine 1\n    [0, 2], # job 1 can be assigned to machines 0 and 2\n    [1] # job 2 can be assigned to machine 1\n]\nmatched = [-1 for _ in range(len(adj) + 1)]\nlevel = [-1 for _ in range(len(adj) + 1)]\n\nprint("Maximum number of busy machines:", hopcroft_karp())