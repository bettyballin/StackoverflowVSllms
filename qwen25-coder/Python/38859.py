def round_preserve_sum(fn, N):\n    # Step 1: Get integer parts and fractions\n    integer_parts = [int(f) for f in fn]\n    fractional_parts = [f - int(f) for f in fn]\n    \n    # Step 2: Calculate the initial sum of integer parts\n    current_sum = sum(integer_parts)\n    \n    # Step 3: Determine how many more integers need to be added\n    additional_integers_needed = N - current_sum\n    \n    # Step 4: Distribute additional integers to minimize rounding variance\n    # We can distribute them based on the fractional part in ascending order\n    sorted_indices = sorted(range(len(fractional_parts)), key=lambda i: (fractional_parts[i], -i))\n    \n    for _ in range(additional_integers_needed):\n        index_to_increase = sorted_indices.pop(0)\n        integer_parts[index_to_increase] += 1\n    \n    return integer_parts\n\n# Test cases\nprint(round_preserve_sum([0.02, 0.03, 0.05, 0.06, 0.07, 0.08, 0.09, 0.1, 0.11, 0.12, 0.13, 0.14], 1))\nprint(round_preserve_sum([0.1, 0.3, 0.4, 0.4, 0.8], 2))\nprint(round_preserve_sum([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], 1))\nprint(round_preserve_sum([0.4, 0.4, 0.4, 0.4, 9.2, 9.2], 20))