class UnionFind:\n    def __init__(self):\n        self.parent = {}\n    \n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        rootX = self.find(x)\n        rootY = self.find(y)\n        if rootX != rootY:\n            self.parent[rootY] = rootX\n\ndef merge_sets(sets_list):\n    uf = UnionFind()\n    element_to_set = {}\n    \n    for set_id, s in enumerate(sets_list):\n        elements = sorted(s)  # Sort to prevent duplicate edges\n        key = tuple(elements[:2])  # Use the first two elements as a hash key initially\n        \n        if len(elements) >= 2:\n            for i in range(len(elements)):\n                element = elements[i]\n                new_key = tuple(elements[i:i+2])\n                \n                if element not in element_to_set:\n                    element_to_set[element] = set_id\n                    uf.parent[set_id] = set_id\n                \n                # Union with the previous sets that share at least two elements\n                for j in range(i):\n                    shared_with = element_to_set.get(elements[j])\n                    if shared_with is not None and len(s & sets_list[shared_with]) >= 2:\n                        uf.union(set_id, shared_with)\n\n    connected_components = {}\n    \n    for set_id in range(len(sets_list)):\n        root = uf.find(set_id)\n        if root not in connected_components:\n            connected_components[root] = []\n        connected_components[root].extend(list(sets_list[set_id]))\n\n    # Remove duplicates and sort the final merged sets\n    return [sorted(set(component)) for component in connected_components.values()]\n\n# Example usage\nsets_list = [\n    {1, 2, 3, 4},\n    {3, 4, 5, 6, 7},\n    {8, 9, 10, 11},\n    {1, 8, 12, 13},\n    {6, 7, 14, 15, 16, 17}\n]\n\nmerged_sets = merge_sets(sets_list)\nprint(merged_sets)