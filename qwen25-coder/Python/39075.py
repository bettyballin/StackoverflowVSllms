import time\n\nclass Estimator:\n    def __init__(self, alpha=0.1):\n        self.alpha = alpha  # Smoothing factor, between 0 and 1\n        self.previous_time = None\n        self.previous_progress = 0\n        self.avg_speed = None\n\n    def update(self, current_progress, current_time=None):\n        if current_time is None:\n            current_time = time.time()\n\n        if self.previous_time is not None:\n            elapsed_time = current_time - self.previous_time\n            progress_diff = current_progress - self.previous_progress\n            speed = progress_diff / elapsed_time\n\n            # Calculate exponentially weighted moving average for the download speed\n            if self.avg_speed is not None:\n                self.avg_speed = self.alpha * speed + (1 - self.alpha) * self.avg_speed\n            else:\n                self.avg_speed = speed\n\n        self.previous_time = current_time\n        self.previous_progress = current_progress\n\n    def estimate_remaining(self, total_progress):\n        remaining_progress = 1.0 - self.previous_progress\n        if self.avg_speed is not None and self.avg_speed > 0:\n            return remaining_progress / self.avg_speed\n        else:\n            return float('inf')  # Return infinity when we cannot compute the speed\n\n# Example usage:\nestimator = Estimator(alpha=0.2)\nstart_time = time.time()\n\n# Simulate progress updates\nfor progress in [0.1, 0.3, 0.5, 0.7, 0.8, 0.9]:\n    current_time = start_time + (progress / 1) * 60  # Simulate passage of time\n    estimator.update(progress, current_time)\n    eta = estimator.estimate_remaining(1.0)\n    print(f"Progress: {progress*100:.2f}%, ETA: {eta:.2f} seconds")