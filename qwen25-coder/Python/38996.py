def find_and_break_cycles(graph, start_node, fixed_edges):\n    visited = set()\n    parents = {}\n    stack = []\n\n    def dfs(node):\n        if node in visited:\n            return\n\n        visited.add(node)\n        stack.append(node)\n\n        for neighbor in graph[node]:\n            edge = (node, neighbor)\n            if edge not in fixed_edges:  # Only consider non-fixed edges\n                if neighbor in stack:  # Cycle detected\n                    break_cycle(neighbor)\n                else:\n                    parents[neighbor] = node\n                    dfs(neighbor)\n\n        stack.remove(node)  # Backtrack\n\n    def break_cycle(end_node):\n        cycle_nodes = set()\n        current = end_node\n        while True:\n            cycle_nodes.add(current)\n            if current == start_node or current not in parents:\n                break\n            current = parents[current]\n        if end_node in parents and parents[end_node] in cycle_nodes:\n            # Remove an edge from the back of the cycle (non-fixed)\n            remove_edge = (parents[end_node], end_node)\n            graph[parents[end_node]].remove(end_node)\n            print(f"Removed edge: {remove_edge}")\n\n    dfs(start_node)\n\n# Example usage\ngraph = {\n    'A': ['B'],\n    'B': ['C', 'D'],\n    'C': ['A'],  # Cycle with A and B\n    'D': ['E']\n}\nfixed_edges = set([{'A', 'B'}, {'B', 'D'}])  # Fixed edges (undirected representation for example)\nfind_and_break_cycles(graph, 'A', fixed_edges)