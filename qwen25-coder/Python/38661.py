import random\n\n# Initialize all images with an initial rating and confidence (uncertainty)\nimages = [{'id': i, 'rating': 1500, 'confidence': 350} for i in range(1_000_000)]\n\ndef expected_score(rating_a, rating_b):\n    return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))\n\ndef update_ratings(winner_index, loser_index):\n    K = 50  # Constant factor that determines the weight given to new comparisons\n    \n    winner = images[winner_index]\n    loser = images[loser_index]\n    \n    expectation_winner = expected_score(winner['rating'], loser['rating'])\n    expectation_loser = expected_score(loser['rating'], winner['rating'])\n    \n    winner['rating'] += K * (1 - expectation_winner)\n    loser['rating'] += K * (0 - expectation_loser)\n\n# Simulate getting comparisons from users\ndef simulate_user_comparisons(comparison_count=2_000):\n    for _ in range(comparison_count):\n        # Randomly select two distinct images\n        idx_a, idx_b = random.sample(range(len(images)), 2)\n        \n        # Assume the user will always pick the image with a higher rating as "better"\n        if images[idx_a]['rating'] > images[idx_b]['rating']:\n            winner_index, loser_index = idx_a, idx_b\n        else:\n            winner_index, loser_index = idx_b, idx_a\n            \n        update_ratings(winner_index, loser_index)\n\nsimulate_user_comparisons()\n\n# Sort images based on their final elo rating\nsorted_images = sorted(images, key=lambda x: x['rating'], reverse=True)\nprint(f"Top 10 most appealing images by Elo rating: {[img['id'] for img in sorted_images[:10]]}")