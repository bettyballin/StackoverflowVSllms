import subprocess\nimport threading\n\n# Mock function to simulate running a test on a client\ndef run_test_on_client(test_id):\n    # Simulate test execution and return some result\n    import random\n    test_result = {"test_id": test_id, "status": "PASS" if random.choice([True, False]) else "FAIL"}\n    return test_result\n\n# Class to handle the distribution of tests and aggregation of results\nclass TestHarness:\n    def __init__(self):\n        self.results = []\n        self.lock = threading.Lock()\n\n    def run_tests(self, num_tests, num_clients):\n        threads = []\n        # Splitting the load based on number of clients\n        tests_per_client = num_tests // num_clients\n\n        for client_id in range(num_clients):\n            start_test = client_id * tests_per_client\n            end_test = start_test + tests_per_client if (client_id != num_clients - 1) else num_tests\n            thread = threading.Thread(target=self.run_tests_on_client_async, args=(start_test, end_test))\n            threads.append(thread)\n            thread.start()\n\n        # Wait for all to finish\n        for thread in threads:\n            thread.join()\n\n    def run_tests_on_client_async(self, start_test, end_test):\n        for test_id in range(start_test, end_test):\n            result = run_test_on_client(test_id)\n            with self.lock:\n                self.results.append(result)\n\n    def get_results(self):\n        return self.results\n\n# Example usage\nif __name__ == "__main__":\n    harness = TestHarness()\n    num_tests = 20\n    num_clients = 5\n    harness.run_tests(num_tests, num_clients)\n    results = harness.get_results()\n    for result in results:\n        print(f"Test {result['test_id']} status: {result['status']}")