import networkx as nx\nfrom itertools import combinations\n\ndef count_unique_msts(G):\n    # Sort edges by weight\n    edges = sorted(G.edges(data=True), key=lambda x: x[2]['weight'])\n    \n    unique_weights = set()\n    for _, _, data in edges:\n        unique_weights.add(data['weight'])\n\n    mst_count = 0\n    visited_edges = []\n\n    # Try all combinations of edges with the same weight\n    for weight in sorted(unique_weights):\n        current_edges = [edge for edge in edges if edge[2]['weight'] == weight]\n        selected_edges = []\n        \n        for edge_subset in combinations(current_edges, r=len(current_edges)):\n            combined_edge_set = visited_edges + list(edge_subset)\n            H = nx.Graph()\n            H.add_nodes_from(G.nodes())\n            H.add_edges_from(combined_edge_set)\n            \n            if nx.is_spanning_tree(G, H):\n                mst_count += 1\n        visited_edges.extend(current_edges)\n\n    return mst_count\n\n# Example usage:\nG = nx.Graph()\nedges = [(0, 1, {'weight': 1}), (0, 2, {'weight': 1}), (1, 3, {'weight': 1}),\n         (2, 3, {'weight': 1}), (3, 4, {'weight': 2})]\nG.add_edges_from(edges)\n\nprint("Number of unique MSTs:", count_unique_msts(G))