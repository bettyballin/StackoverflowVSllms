class BKTreeNode:\n    def __init__(self, term="", children=None):\n        self.term = term  # The key stored at this node (must be hashable type)\n        self.children = children if children is not None else {}\n\ndef hamming_distance(s1, s2):\n    return sum(c1 != c2 for c1, c2 in zip(s1, s2))\n\nclass BKTree:\n    def __init__(self, distance_func=hamming_distance):\n        self.root = None\n        self.distance_func = distance_func\n\n    def add(self, term):\n        if self.root is None:\n            self.root = BKTreeNode(term)\n        else:\n            curr_node = self.root\n            while True:\n                p = self.distance_func(curr_node.term, term)\n                child = curr_node.children.get(p)\n                if child is None:\n                    curr_node.children[p] = BKTreeNode(term)\n                    break\n                else:\n                    curr_node = child\n\n    def find_within(self, node, query, threshold):\n        results = []\n        if node is None:\n            return results\n        p = self.distance_func(node.term, query)\n        if p <= threshold:\n            results.append((p, node.term))\n        for distance in range(p - threshold, p + threshold + 1):\n            if distance in node.children:\n                results += self.find_within(node.children[distance], query, threshold)\n        return results\n\n    def query(self, query, threshold=6):\n        return self.find_within(self.root, query, threshold)\n\n# Usage\nbkt = BKTree()\nfor key in keys:  # Assuming 'keys' is your list of bit fields\n    bkt.add(key)\n\nsimilar_keys = bkt.query(query_key)\nprint(similar_keys)