import numpy as np\n\ndef marching_squares(grid, isovalue):\n    # Directions for drawing lines:\n    DIRECTIONS = [\n        [],  [(0.5, 0),   (1,0.5)],  [(1,0.5),  (0.5,1)],\n        [     (0.5, 0),            (0.5, 1) ], \n        [(1,0.5),  (0.5,0)],  [],  [(0.5,1),   (0.5,0)],\n         [(0.5, 1),            (0.5, 0)]\n    ]\n    \n    # Define vertices of a square\n    vertices = {\n        'bottom-left': (0, 0),\n        'top-left': (0, 1),\n        'top-right': (1, 1),\n        'bottom-right': (1, 0)\n    }\n    \n    lines = []\n    for i in range(grid.shape[0] - 1):\n        for j in range(grid.shape[1] - 1):\n            # Calculate the square's corners' indices\n            square = {\n                'bottom-left': grid[i,   j],\n                'top-left':    grid[i+1, j],\n                'top-right':   grid[i+1, j+1],\n                'bottom-right':grid[i,   j+1]\n            }\n            \n            # Check which vertices are below/above the isovalue\n            config = 0\n            for index, vertex in enumerate(vertices.items()):\n                key, position = vertex\n                if square[key] < isovalue:\n                    config |= (1 << index)\n            \n            # Find which edges to draw based on the configuration\n            direction = DIRECTIONS[config]\n            for a, b in direction:\n                vertex_a = (\n                    j + vertices[next(key for key, _ in enumerate(vertices.items()) if config & (1<<key))][0] * (a-0.5) +\n                    i + vertices[next(key for key, _ in enumerate(vertices.items()) if config & (1<<key))][1] * (b-0.5)\n                )\n                vertex_b = (\n                    j + vertices[next(key for key, _ in enumerate(vertices.items()) if config & (1<<(config & (1<<key)).bit_length()-1))][0] * (a-0.5) +\n                    i + vertices[next(key for key, _ in enumerate(vertices.items()) if config & (1<<(config & (1<<key)).bit_length()-1))][1] * (b-0.5)\n                )\n                lines.append(((vertex_a, j), (vertex_b, i)))\n    \n    return np.array(lines)\n\n# Example usage:\ngrid = np.random.rand(20, 20) * 10 - 5  # Create a sample grid\nisovalue = 0\n\nlines = marching_squares(grid, isovalue)\nprint(lines.shape, lines)  # Array of line segments that form the contours