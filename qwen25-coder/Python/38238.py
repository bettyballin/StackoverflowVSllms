# Define the graph as an adjacency list\ngraph = {\n    1: [2],\n    2: [3, 5],\n    3: [6],\n    4: [2],\n    5: [11, 6],\n    6: [7, 8],\n    7: [],\n    8: [9, 10],\n    9: [],\n    10: [],\n    11: [12],\n    12: []\n}\n\nclass MyQUEUE:  # just an implementation of a queue\n    def __init__(self):\n        self.holder = []\n\n    def enqueue(self, val):\n        self.holder.append(val)\n\n    def dequeue(self):\n        val = None\n        try:\n            val = self.holder[0]\n            if len(self.holder) == 1:\n                self.holder = []\n            else:\n                self.holder = self.holder[1:]\n        except:\n            pass\n\n        return val\n\n    def IsEmpty(self):\n        result = False\n        if len(self.holder) == 0:\n            result = True\n        return result\n\n\ndef BFS(graph, start, end, q):\n    temp_path = [start]\n    q.enqueue(temp_path)\n\n    paths_found = []\n\n    while not q.IsEmpty():\n        tmp_path = q.dequeue()\n        last_node = tmp_path[-1]\n\n        if last_node == end:\n            paths_found.append(tmp_path)\n            continue\n\n        for link_node in graph[last_node]:\n            if link_node not in tmp_path:  # Ensure no cycles\n                new_path = tmp_path + [link_node]\n                q.enqueue(new_path)\n\n    return paths_found\n\n\n# Initialize the queue and perform BFS\npath_queue = MyQUEUE()\npaths = BFS(graph, 1, 7, path_queue)\n\n# Print all paths found\nprint(f"{len(paths)} paths found and they are")\nfor path in paths:\n    print(path)