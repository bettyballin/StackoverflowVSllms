import hashlib\nfrom Crypto.Cipher import AES\nfrom struct import pack, unpack\n\n# Ensure block size fits within AES requirements.\nBLOCK_SIZE = 8  # Half of AES block size (128 bits key)\nKEY = b'Sixteen byte key'\n\ndef pad(s):\n    return s + b'\0' * (BLOCK_SIZE - len(s) % BLOCK_SIZE)\n\ndef aes_round_key(key, round_num):\n    h = hashlib.sha512()\n    h.update(key + str(round_num).encode())\n    return h.digest()[:BLOCK_SIZE]\n\ndef feistel_encrypt(number, rounds=4, key=KEY):\n    L0, R0 = unpack('<LL', pack('<Q', number))\n    for i in range(rounds):\n        round_key = aes_round_key(key, i)\n        cipher = AES.new(pad(round_key), AES.MODE_ECB)\n        L1 = R0\n        k = unpack('<L', cipher.encrypt(pack('<4L', 0, 0, R0, 0)))[0]\n        R1 = L0 ^ k\n        L0, R0 = L1, R1\n    return (R0 << 32) + L0\n\ndef feistel_decrypt(number, rounds=4, key=KEY):\n    R0, L0 = unpack('<LL', pack('<Q', number))\n    for i in range(rounds - 1, -1, -1):\n        round_key = aes_round_key(key, i)\n        cipher = AES.new(pad(round_key), AES.MODE_ECB)\n        k = unpack('<L', cipher.encrypt(pack('<4L', 0, 0, L0, 0)))[0]\n        L1 = R0\n        R1 = L0 ^ k\n        L0, R0 = L1, R1\n    return (L0 << 32) + R0\n\n# Example usage:\noriginal_number = 1234567890\nencrypted = feistel_encrypt(original_number)\ndecrypted = feistel_decrypt(encrypted)\n\nprint(f"Original: {original_number}")\nprint(f"Encrypted: {encrypted}")\nprint(f"Decrypted: {decrypted}")