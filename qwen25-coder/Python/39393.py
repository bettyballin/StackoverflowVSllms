#!/usr/bin/env python3\n\n   from bcc import BPF\n   from time import sleep\n\n   bpf_code = """\n       struct data_t {\n           u32 pid;\n           char comm[TASK_COMM_LEN];\n           char func_name[64];\n       };\n\n       BPF_HASH(stats, struct data_t);\n\n       int trace_function_call(struct pt_regs *ctx) {\n           struct data_t data = {};\n           data.pid = bpf_get_current_pid_tgid() >> 32;\n           bpf_get_current_comm(&data.comm, sizeof(data.comm));\n\n           // Replace 'g_lib_function_name' with the actual function you want to trace\n           __builtin_memcpy(&data.func_name, "g_lib_function_name", 19);\n\n           u64 zero = 0, *val;\n\n           val = stats.lookup_or_init(&data, &zero);\n           ++(*val);\n\n           return 0;\n       }\n   """\n\n   bpf_code += """\n       tracepoint:syscalls:sys_enter_* {\n           struct data_t data = {};\n           data.pid = bpf_get_current_pid_tgid() >> 32;\n           bpf_get_current_comm(&data.comm, sizeof(data.comm));\n\n           // You need to replace 'g_lib_function_name' with an actual glib function.\n           if (bpf_usdt_readarg_pstring(1, ctx, &data.func_name) == 0 &&\n               strcmp(&data.func_name, "g_lib_function_name") == 0) {\n               u64 zero = 0, *val;\n               val = stats.lookup_or_init(&data, &zero);\n               ++(*val);\n           }\n       }\n   """\n\n   b = BPF(text=bpf_code)\n   # Attach uprobes to glib functions. Add more as needed.\n   b.attach_uprobe(name="/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0", sym="g_hash_table_new", fn_name="trace_function_call")\n\n   print("Tracing... Hit Ctrl-C to end.")\n\n   try:\n       sleep(99999999)\n   except KeyboardInterrupt:\n       print("Dumping stats...")\n       s = b["stats"]\n       for k, v in sorted(s.items(), key=lambda stats: -stats[1].value):\n           print("%d %-16s %s" % (k.pid, str(k.comm.decode()), str(k.func_name.decode())))