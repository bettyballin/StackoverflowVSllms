import struct\n\n# Convert to signed and unsigned integers\ndef str_to_signed_8bit(s):\n    return struct.unpack('b', s.encode('latin1'))[0]\n\ndef str_to_unsigned_8bit(s):\n    return struct.unpack('B', s.encode('latin1'))[0]\n\ndef str_to_signed_16bit(s):\n    return struct.unpack('h', s.encode('latin1'))[0]  # 'h' is for signed short\n\ndef str_to_unsigned_16bit(s):\n    return struct.unpack('H', s.encode('latin1'))[0]  # 'H' is for unsigned short\n\ndef str_to_signed_32bit(s):\n    return struct.unpack('i', s.encode('latin1'))[0]  # 'i' is for signed int\n\ndef str_to_unsigned_32bit(s):\n    return struct.unpack('I', s.encode('latin1'))[0]  # 'I' is for unsigned int\n\ndef str_to_signed_64bit(s):\n    return struct.unpack('q', s.encode('latin1'))[0]  # 'q' is for signed long long\n\ndef str_to_unsigned_64bit(s):\n    return struct.unpack('Q', s.encode('latin1'))[0]  # 'Q' is for unsigned long long\n\n# Example usage\nnum_str = "A"\nprint(signed_8bit := str_to_signed_8bit(num_str))  # Output based on ASCII value of 'A'\nprint(unsigned_8bit := str_to_unsigned_8bit(num_str))  # Same, but unsigned