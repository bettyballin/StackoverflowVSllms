def count_permutations_with_inversions(n, k_max):\n    # dp[n][k] will be the number of permutations of n elements with exactly k inversions\n    dp = [[0] * (k_max + 1) for _ in range(n + 1)]\n    \n    # Base case: there's one way to arrange zero elements with zero inversions\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for n_size in range(1, n + 1):\n        prefix_sum = [0] * (k_max + 2)\n        for k in range(k_max + 1):\n            prefix_sum[k + 1] = (prefix_sum[k] + dp[n_size - 1][k])\n        \n        for k in range(k_max + 1):\n            if k < n_size:\n                dp[n_size][k] = prefix_sum[k + 1]\n            else:\n                dp[n_size][k] = (prefix_sum[k + 1] - prefix_sum[k - n_size + 1])\n    \n    # Sum up all permutations with inversions <= k_max\n    return sum(dp[n][k] for k in range(k_max + 1))\n\n# Example usage:\nn = 4  # number of elements in the array\nN = 2  # maximum bubble sort swaps (inversions) allowed\nprint(count_permutations_with_inversions(n, N))  # Output: Number of permutations with <= N inversions