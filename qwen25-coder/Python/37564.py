import numpy as np\nfrom scipy.spatial import cKDTree\n\ndef generate_grid(points, buffer=0.01):\n    # Unzip points into separate lists for latitude and longitude\n    lats, longs = zip(*points)\n    \n    # Calculate the minimum and maximum lat/long to define the bounding box\n    min_lat, max_lat = min(lats), max(lats)\n    min_long, max_long = min(longs), max(longs)\n    \n    # Calculate the range for latitude and longitude\n    lat_range = max_lat - min_lat + buffer * 2\n    long_range = max_long - min_long + buffer * 2\n    \n    # Calculate grid cell dimensions; for simplicity, assume square cells\n    num_points = len(points)\n    side_length = np.sqrt(num_points / (lat_range * long_range)) * buffer\n    \n    # Decide the number of grid divisions based on cell size\n    lat_divs = int(lat_range / side_length) + 1\n    long_divs = int(long_range / side_length) + 1\n    \n    # Generate the grid bounds\n    lat_bounds = np.linspace(min_lat - buffer, max_lat + buffer, lat_divs)\n    long_bounds = np.linspace(min_long - buffer, max_long + buffer, long_divs)\n    \n    # Initialize a 2D list to hold grid cells, each cell represented as a tuple of (lat_min, lat_max, lon_min, lon_max)\n    grid_cells = []\n    for i in range(len(lat_bounds) - 1):\n        for j in range(len(long_bounds) - 1):\n            grid_cell = (lat_bounds[i], lat_bounds[i+1], long_bounds[j], long_bounds[j+1])\n            grid_cells.append(grid_cell)\n    \n    # Build a KDTree from the points to quickly find the nearest point\n    tree = cKDTree(points)\n    \n    # Create a dictionary to map each point to its corresponding cell\n    point_in_cell = {point: None for point in points}\n    \n    # Iterate over each grid cell and find its containing point using the KDTree\n    for cell in grid_cells:\n        lat_min, lat_max, lon_min, lon_max = cell\n        \n        # Create a bounding box query region as a rectangle (a min/max pair of coordinates)\n        bbox_query = ((lat_min, lon_min), (lat_max, lon_max))\n        \n        # Find the nearest point to the center of this cell\n        query_center = (0.5 * (lat_min + lat_max), 0.5 * (lon_min + lon_max))\n        distance, index = tree.query(query_center)\n        \n        if distance < max(side_length * np.sqrt(2) / 2, buffer):\n            point = points[index]\n            # Assign the point to its cell if there's no assigned yet and it fits in the cell\n            if point_in_cell[point] is None:\n                point_in_cell[point] = cell\n    \n    # Filter out empty cells and return the non-empty grid\n    non_empty_grid = {k: v for k, v in point_in_cell.items() if v is not None}\n    \n    return non_empty_grid\n\n# Example usage\npoints_of_interest = [(-34.05321, 146.978), (-34.05322, 146.9785)]\ngrid_with_points = generate_grid(points_of_interest)\nprint(grid_with_points)