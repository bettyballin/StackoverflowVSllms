import numpy as np\n\ndef cubic_bezier(p0, p1, p2, p3, t):\n    return (1 - t)**3 * p0 + 3 * (1 - t)**2 * t * p1 + 3 * (1 - t) * t**2 * p2 + t**3 * p3\n\ndef compute_curvature(p0, p1, p2, p3):\n    dx = -3*p0 + 9*p1 - 9*p2 + 3*p3\n    dy = -3*(p0.imag) + 9*(p1.imag) - 9*(p2.imag) + 3*(p3.imag)\n    ddx = 6*p0 - 12*p1 + 6*p2\n    ddy = 6*(p0.imag) - 12*(p1.imag) + 6*(p2.imag)\n\n    return np.sqrt((ddy*dx - ddx*dy)**2) / ((dx**2 + dy**2)**(3/2))\n\ndef adaptive_bezier(p0, p1, p2, p3, threshold=1e-4):\n    mid = (p0 + 3*p1 + 3*p2 + p3) / 8\n    t_mid = 0.5\n\n    curvature = compute_curvature(p0, p1, p2, p3)\n    if curvature < threshold:\n        return [p0, mid], []\n    \n    left_points, _ = adaptive_bezier(p0, (p0 + p1) / 2, \n                                      (p0 + 2*p1 + p2) / 4,\n                                      (p0 + 3*p1 + 3*p2 + p3) / 8)\n    \n    right_points, _ = adaptive_bezier((p0 + 3*p1 + 3*p2 + p3) / 8, \n                                       (2*p1 + 2*p2 + p3) / 4,\n                                       (p1 + p2) / 2, p3)\n\n    return left_points[:-1] + right_points, []\n\n# Example usage:\nstart = np.array([0, 0])\ncontrol1 = np.array([1, 2])\ncontrol2 = np.array([3, -1])\nend = np.array([4, 0])\n\npoints, control_points = adaptive_bezier(start, control1, control2, end)\nprint("Points on the curve:", points)\n\n# Note: This is a simplified example and may need adjustments for your specific use case.