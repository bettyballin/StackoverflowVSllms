class Node:\n    def __init__(self, prefix=""):\n        self.prefix = prefix\n        self.children = {}\n        self.is_end_of_word = False\n\nclass CompressedTrie:\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, word):\n        current_node = self.root\n        i = 0\n        while i < len(word):\n            common_prefix_found = False\n            for node in current_node.children.values():\n                j = 0\n                min_length = min(len(word[i:]), len(node.prefix))\n                # Find the common prefix\n                while j < min_length and word[i + j] == node.prefix[j]:\n                    j += 1\n                if j > 0:\n                    common_prefix_found = True\n                    break\n\n            if not common_prefix_found:\n                # Insert as a new child of current_node\n                new_node = Node(word[i:])\n                current_node.children[word[i]] = new_node\n                new_node.is_end_of_word = True\n                return\n\n            existing, additional = node.prefix[:j], node.prefix[j:]\n\n            if j == len(node.prefix):\n                # Case 3: k' is a proper prefix of k\n                i += j\n                current_node = node\n            else:\n                # Split the child node at the point of common prefix length\n                split_child = Node(additional)\n                split_child.children = node.children  # Transfer children\n\n                # Create a parent node with found prefix and attach split children\n                middle_node = Node(existing)\n                middle_node.children[additional[0]] = split_child\n                if j == len(word[i:]):\n                    middle_node.is_end_of_word = True\n                else:\n                    new_node = Node(word[i + j:])\n                    new_node.is_end_of_word = True\n                    middle_node.children[word[i + j]] = new_node\n\n                current_node.children[existing[0]] = middle_node\n                return\n\n        # Handle case 1: k is identical to some prefix in trie (but not inserted yet)\n        if not current_node.is_end_of_word:\n            current_node.is_end_of_word = True\n\n    def search(self, word):\n        current_node = self.root\n        i = 0\n\n        while i < len(word):\n            found = False\n            for node in current_node.children.values():\n                if node.prefix.startswith(word[i:]):\n                    # Case where the complete word matches a prefix of a node (or is longer)\n                    if len(node.prefix) + i == len(word):\n                        return node.is_end_of_word\n                    elif len(node.prefix) + i > len(word):\n                        return False\n                    found = True  # Complete the first part and go one level deeper\n                    current_node = node\n                    i += len(node.prefix)\n                    break\n\n            if not found:  # There can't be a match from here onwards\n                return False\n\n        return current_node.is_end_of_word\n\n# Example usage:\ntrie = CompressedTrie()\nwords = ["stackoverflow", "stackbase", "stackbased"]\nfor word in words:\n    trie.insert(word)\n\nprint(trie.search("stackoverflow"))  # True\nprint(trie.search("stackbase"))      # True\nprint(trie.search("stackbased"))     # True\nprint(trie.search("stackba"))        # False