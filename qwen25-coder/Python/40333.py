import sqlite3\nfrom datetime import datetime, timedelta\n\ndef is_login_allowed(user_id, max_attempts=5, lockout_duration_minutes=10):\n    conn = sqlite3.connect('login_attempts.db')\n    cursor = conn.cursor()\n\n    # Delete old attempts (optional, for cleanup)\n    cutoff_time = datetime.now() - timedelta(minutes=lockout_duration_minutes)\n    cursor.execute("DELETE FROM login_attempts WHERE attempt_time < ?", (cutoff_time,))\n    \n    # Count recent failed attempts\n    cursor.execute("SELECT COUNT(*) FROM login_attempts WHERE user_id=? AND attempt_time >= ?", \n                   (user_id, cutoff_time))\n    failed_attempts = cursor.fetchone()[0]\n    \n    conn.close()\n    return failed_attempts < max_attempts\n\ndef record_login_attempt(user_id, ip_address):\n    conn = sqlite3.connect('login_attempts.db')\n    cursor = conn.cursor()\n    cursor.execute("INSERT INTO login_attempts (user_id, ip_address) VALUES (?, ?)", \n                   (user_id, ip_address))\n    conn.commit()\n    conn.close()\n\n# Example usage\nip_address = '127.0.0.1'  # Get this from request data in real application\n\nif is_login_allowed('some_user'):\n    print("Login allowed.")\n    # Proceed with authentication logic here (check password, etc.)\nelse:\n    print("Account temporarily locked due to too many failed attempts.")\n\nrecord_login_attempt('some_user', ip_address)