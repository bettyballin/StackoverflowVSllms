def distribute_votes(Ta, Tb, distribution_a):\n    # Calculate the total of the distribution_a\n    total_a = sum(distribution_a)\n    \n    # Normalize the distribution_a to get the ratio\n    normalized_ratios = [x / total_a for x in distribution_a]\n    \n    # Distribute Tb based on these ratios\n    distributed_b = [Tb * r for r in normalized_ratios]\n    \n    # Round the values and adjust to make the sum exactly Tb\n    rounded_distributed_b = [round(x) for x in distributed_b]\n    remainder = Tb - sum(rounded_distributed_b)\n    \n    # Adjust the rounded numbers by adding/removing 1 to match Tb exactly\n    while remainder != 0:\n        for i in range(len(distributed_b)):\n            if remainder > 0 and rounded_distributed_b[i] < distributed_b[i]:\n                rounded_distributed_b[i] += 1\n                remainder -= 1\n            elif remainder < 0 and rounded_distributed_b[i] > distributed_b[i]:\n                rounded_distributed_b[i] -= 1\n                remainder += 1\n            if remainder == 0:\n                break\n    \n    # Filter out zeros (if M < N, some constituencies might get zero votes)\n    result = [x for x in rounded_distributed_b if x > 0]\n    \n    return result\n\n# Example usage for the "Ideal" case\nTa = 20\nTb = 10\ndistribution_a = [8, 6, 4, 2]\n\nb_votes = distribute_votes(Ta, Tb, distribution_a)\nprint(b_votes)  # Output: [4, 3, 2, 1]