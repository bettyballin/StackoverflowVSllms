import socket\nimport struct\nimport time\n\ndef send_time_sync_packets(host, port, num_pings=5):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.settimeout(2)  # Timeout for receive\n		\n        for i in range(num_pings):\n            # Send timestamped packet\n            send_time = time.time()\n            seq_num = struct.pack('!I', i + 1)\n            data = struct.pack('!d', send_time) + seq_num\n			\n            sock.sendto(data, (host, port))\n			\n            try:\n                rec_data, addr = sock.recvfrom(1024)\n                server_send_time, _ = struct.unpack('!dI', rec_data[:12])\n                receive_time = time.time()\n				\n                # Calculate round-trip delay and offset\n                rtt = (receive_time - send_time) / 2.0\n                offset = server_send_time + rtt - send_time\n				\n                print(f"Ping {i+1}: RTT={rtt:.6f}s, Offset={offset:.6f}s")\n				\n            except socket.timeout:\n                print(f"Ping {i+1}: no response")\n        \n    finally:\n        sock.close()\n\ndef server_listen(port):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    sock.bind(('', port))\n    \n    while True:\n        data, addr = sock.recvfrom(1024)\n        recv_time_server = time.time()\n        server_send_time = struct.unpack('!d', data[:8])[0]\n        \n        # Pack and send with timestamp the packet back\n        response_data = struct.pack('!d', recv_time_server) + data[8:]\n        sock.sendto(response_data, addr)\n\n# Example usage:\n# Run 'server_listen(12345)' on one machine.\n# Then run 'send_time_sync_packets("<SERVER_IP>", 12345)' on the other machine.