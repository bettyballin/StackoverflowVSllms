def is_safe(v, pos, path, graph):\n    # Check if this vertex is an adjacent vertex of the previously added vertex.\n    if graph[path[pos - 1]][v] == 0:\n        return False\n\n    # Check if the vertex has already been included.\n    for i in range(pos):\n        if path[i] == v:\n            return False\n\n    return True\n\ndef hamiltonian_util(graph, path, pos):\n    # base case: If all vertices are included in the path\n    if pos == len(graph):\n        # Last vertex must be adjacent to first vertex in path for a Hamiltonian cycle\n        if graph[path[pos - 1]][path[0]] == 1:\n            return True\n        else:\n            return False\n\n    # Try different vertices as a next candidate in Hamiltonian Path.\n    for v in range(1, len(graph)):\n        if is_safe(v, pos, path, graph):\n            path[pos] = v\n\n            if hamiltonian_util(graph, path, pos + 1) == True:\n                return True\n\n            # Remove current vertex if it doesn't lead to a solution\n            path[pos] = -1\n\n    return False\n\ndef hamiltonian_path(graph):\n    path = [-1] * len(graph)\n    path[0] = 0\n\n    if hamiltonian_util(graph, path, 1) == False:\n        print("Solution does not exist")\n        return False\n    else:\n        print("Solution Exists: Following is one Hamiltonian Path ", end="")\n        for vertex in path:\n            print(vertex, " ", end="")\n        print()\n        return True\n\n# Example usage:\ngraph = [[0, 1, 0, 1, 0],\n         [1, 0, 1, 1, 1],\n         [0, 1, 0, 0, 1],\n         [1, 1, 0, 0, 1],\n         [0, 1, 1, 1, 0]]\n\nhamiltonian_path(graph)