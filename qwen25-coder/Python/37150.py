def min_drops floors, eggs):\n    # Create a table where dp[i][j] will represent the minimum number of trials needed for i eggs and j floors.\n    dp = [[0 for x in range(floors + 1)] for x in range(eggs + 1)]\n\n    # If we have one egg, we need j tries for j floors (try throwing from every floor)\n    for j in range(1, floors + 1):\n        dp[1][j] = j\n\n    # If there are no floors, then no trials needed\n    # OR if there are no eggs, then no trials needed\n    for i in range(2, eggs + 1):\n        dp[i][0] = 0\n        dp[i][1] = 1\n\n    # Fill the rest of the table using optimal substructure property\n    for e in range(2, eggs + 1):  # for each number of eggs\n        for f in range(2, floors + 1):  # for each floor\n            dp[e][f] = float('inf')  # Initialize to infinity\n            for x in range(1, f + 1):  # try every floor\n                res = 1 + max(dp[e - 1][x - 1], dp[e][f - x])\n                if res < dp[e][f]:\n                    dp[e][f] = res\n\n    # The answer for n floors and 2 eggs is in dp[2][n]\n    return dp[eggs][floors]\n\n# Example usage:\nfloors = 100\neggs = 2\nprint(f"Minimum number of drops required: {min_drops(floors, eggs)}")