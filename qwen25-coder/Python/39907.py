def minimal_coverage(intervals, a, b):\n    # Filter out intervals that do not intersect (a, b)\n    filtered_intervals = [interval for interval in intervals if interval[0] < b and a < interval[1]]\n    \n    # Sort intervals by their finishing time\n    filtered_intervals.sort(key=lambda x: x[1])\n    \n    chosen_intervals = []\n    current_endpoint = a\n    \n    while current_endpoint < b:\n        # Select the next interval that starts before the last\n        # selected interval ends and extends the coverage furthest.\n        best_interval = None\n        for interval in filtered_intervals:\n            if interval[0] <= current_endpoint and (best_interval is None or interval[1] > best_interval[1]):\n                best_interval = interval\n        \n        if best_interval is None:\n            # No further extension possible, cannot cover (a, b) fully.\n            return []\n        \n        chosen_intervals.append(best_interval)\n        current_endpoint = best_interval[1]\n    \n    return chosen_intervals\n\n# Example usage\nintervals = [(0.2, 0.5), (0.3, 0.6), (0.5, 0.8), (0.7, 1.0)]\na, b = 0.1, 1.0\nprint(minimal_coverage(intervals, a, b))