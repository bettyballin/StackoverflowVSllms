import unittest\nfrom unittest.mock import Mock, patch\n\n# Assuming you have a class `SerialCommunicator` that handles RS-422 communication\nclass SerialCommunicator:\n    def __init__(self, port):\n        self.port = port\n\n    def send_message(self, message):\n        # Logic to send serial data over the port\n        pass\n\n    def read_response(self):\n        # Logic to receive response from the port\n        pass\n\n# Test case for SerialCommunicator class\nclass TestSerialCommunicator(unittest.TestCase):\n\n    @patch('your_module.SerialPort')\n    def test_send_message(self, mock_serial_port):\n        # Create a mock instance and set its methods' return values\n        mock_instance = mock_serial_port.return_value\n        mock_instance.write = Mock()\n\n        comm = SerialCommunicator(mock_instance)\n        \n        # Expected bytes to send\n        expected_bytes = b'\x01\x02\x03'\n        comm.send_message(expected_bytes)\n\n        # Assert that write method was called with the correct bytes\n        mock_instance.write.assert_called_once_with(expected_bytes)\n\n    @patch('your_module.SerialPort')\n    def test_read_response(self, mock_serial_port):\n        mock_instance = mock_serial_port.return_value\n        # Simulate a response from the FPGA\n        mock_instance.read.return_value = b'\x04\x05'\n\n        comm = SerialCommunicator(mock_instance)\n        response = comm.read_response()\n\n        self.assertEqual(response, b'\x04\x05')\n        mock_instance.read.assert_called_once()\n\nif __name__ == '__main__':\n    unittest.main()