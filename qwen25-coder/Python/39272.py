import os\nimport hashlib\nfrom Crypto.Protocol.KDF import PBKDF2\nfrom Crypto.Cipher import AES\nfrom base64 import b64encode, b64decode\n\n# Example password and salt\npassword = "secure_password"\nsalt = os.urandom(16)  # Generate a random salt for each encryption\n\n# Derive key and IV from the password and salt\nkey = PBKDF2(password, salt, dkLen=32)  # 256-bit key for AES-256\niv = PBKDF2(password, salt + b'some_unique_suffix', dkLen=16)  # 128-bit IV\n\n# Encrypt data\ncipher = AES.new(key, AES.MODE_CBC, iv)\ndata = "Data to encrypt"\n# Padding data to be a multiple of block size (AES.block_size = 16 bytes)\npadded_data = data + (AES.block_size - len(data) % AES.block_size) * chr(AES.block_size - len(data) % AES.block_size)\nencrypted_data = cipher.encrypt(padded_data.encode())\n\n# Encode for URL safe transmission\nencoded_encrypted_data = b64encode(encrypted_data).decode()\nencoded_iv = b64encode(iv).decode()\nencoded_salt = b64encode(salt).decode()\n\n# Construct URL parameter\nurl_param = f"?data={encoded_encrypted_data}&iv={encoded_iv}&salt={encoded_salt}"\n\n# Note: In a real-world scenario, ensure proper error handling and security measures.