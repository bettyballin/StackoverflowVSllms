def find_redundant_edges(edges):\n    from collections import defaultdict\n\n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node):\n                    return True\n            elif neighbor != parent:\n                return True  # Found a cycle!\n        return False\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        if (u, v) in redundant_edges or (v, u) in redundant_edges:\n            continue  # Skip already checked edges\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {}\n    redundant_edges = set()\n    for node in graph:\n        if node not in visited:\n            visited[node] = False\n\n    # Check each edge to find cycles\n    for u, v in edges:\n        prev_visited = visited.copy()  # Snapshot before removing the edge\n        graph[u].remove(v)\n        graph[v].remove(u)\n\n        visited = {node: False for node in graph}\n        if not dfs(u, None):  # Check if the graph is still connected after removing (u, v)\n            redundant_edges.add((u, v))\n        \n        # Restore the edge\n        visited = prev_visited.copy()\n        graph[u].append(v)\n        graph[v].append(u)\n\n    return list(redundant_edges)\n\n\n# Example usage:\nedges = [('a', 'b'), ('a', 'c'), ('a', 'd'), ('a', 'e'), ('b', 'd'), ('c', 'e')]\nprint(find_redundant_edges(edges))