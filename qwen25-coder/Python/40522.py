import numpy as np\n\ndef calculate_repulsion(vector, distance, D):\n    # Simple exponential decay repulsion force\n    if distance <= D:\n        return -vector * (1 / (distance + 0.01))\n    else:\n        return np.zeros_like(vector)\n\ndef motion_planning(A, B, C, D, speed, dt):\n    position = np.array(A)\n    target_vector = np.array(B) - position\n    while np.linalg.norm(target_vector) > 0.001:  # Threshold for stopping\n        total_force = target_vector / np.linalg.norm(target_vector) * speed  # Attraction force\n\n        for obstacle in C:\n            obstacle_vector = np.array(obstacle) - position\n            distance_to_obstacle = np.linalg.norm(obstacle_vector)\n            total_force += calculate_repulsion(obstacle_vector, distance_to_obstacle, D)\n\n        movement_vector = total_force * dt\n        new_position = position + movement_vector\n\n        # Check bounds and update position\n        if all(new_position != position):  # Ensure no deadlock\n            position = new_position\n            target_vector = np.array(B) - position\n    return position\n\n# Example usage:\nA = (0, 0)\nB = (10, 10)\nC = [(3, 3), (7, 5)]\nD = 2.0\nspeed = 1.0\ndt = 0.1\n\nfinal_position = motion_planning(A, B, C, D, speed, dt)\nprint("Object reached position:", final_position)