import numpy as np\n\ndef normalize_path(path):\n    # Convert list of (x, y) tuples to numpy array for easier manipulation\n    points = np.array(path)\n    \n    # Translate the path such that its centroid is at the origin\n    centroid = np.mean(points, axis=0)\n    translated_points = points - centroid\n    \n    # Rotate the path to align it with a reference direction (e.g., along x-axis)\n    # Calculate angles and use rotation matrix to minimize variance in y direction\n    angles = np.arctan2(translated_points[:, 1], translated_points[:, 0])\n    avg_angle = np.mean(angles)\n    \n    # Create rotation matrix for undoing the average angle to align with x-axis\n    cos_avg, sin_avg = np.cos(-avg_angle), np.sin(-avg_angle)\n    rotation_matrix = np.array([[cos_avg, -sin_avg], [sin_avg, cos_avg]])\n    \n    # Apply rotation matrix to translated points\n    aligned_points = np.dot(rotation_matrix, translated_points.T).T\n    \n    # Scale the path (normalize by the length of the longest dimension)\n    scale_factor = 1 / max(aligned_points.max(axis=0) - aligned_points.min(axis=0))\n    scaled_points = aligned_points * scale_factor\n    \n    return scaled_points\n\ndef compare_paths(path1, path2):\n    normalized_path1 = normalize_path(path1)\n    normalized_path2 = normalize_path(path2)\n    \n    # Calculate some form of distance metric between the two paths\n    # Here we use the Euclidean norm for simplicity\n    return np.sum((normalized_path1 - normalized_path2) ** 2)\n\n# Example usage:\npath_a = [(0, 0), (1, 1), (2, 1)]\npath_b = [(1, 0), (1, -1), (1, -2)] # path a rotated 90 degrees\n\ndistance = compare_paths(path_a, path_b)\nprint("Normalized distance between paths:", distance)