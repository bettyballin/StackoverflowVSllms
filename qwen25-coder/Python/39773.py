from collections import defaultdict, deque\n\n# Sample data\nlinestrings = [\n    (1, ['A', 'B', 'C']),\n    (2, ['C', 'D']),\n    (3, ['B', 'A']),\n    (4, ['F', 'G', 'H']),\n    (5, ['G', 'I']),\n    (6, ['H', 'J'])\n]\n\n# Convert data into an edge dictionary\nedges = defaultdict(list)\nfor ls_id, points in linestrings:\n    for i in range(len(points) - 1):\n        edges[points[i]].append((ls_id, points[i+1]))\n        edges[points[i+1]].append((ls_id, points[i]))\n\n# Helper function to find connected components\ndef bfs(source_node):\n    queue = deque([source_node])\n    visited.add(source_node)\n    path = []\n    \n    while queue:\n        current = queue.popleft()\n        if not path or current != path[-1]:\n            path.append(current)\n\n        for ls_id, neighbor in edges[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                \n    return path\n\n# Find and merge linestrings\nvisited = set()\noptimized_linestrings = []\nfor node in edges:\n    if node not in visited:\n        connected_path = bfs(node)\n        optimized_linestrings.append(connected_path)\n\n# Print results\nfor i, opt_ls in enumerate(optimized_linestrings):\n    print(f'{i+1}: {" -> ".join(opt_ls)}')