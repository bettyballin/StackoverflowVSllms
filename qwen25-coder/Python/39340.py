from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives import hashes\nimport os\n\n# Generate a strong key using a secure random method\nbackend = default_backend()\nkey = backend.random_bytes(32)\n\n# Encrypting the data with AES-256 in CBC mode\ndef encrypt_data(data, password):\n    # Derive a key from the provided password using PBKDF2HMAC\n    salt = os.urandom(16)\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=100000,\n        backend=backend\n    )\n    key = kdf.derive(password.encode())\n\n    # Generate a random initialization vector (IV)\n    iv = os.urandom(16)\n\n    # Create cipher and encrypt the data\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)\n    encryptor = cipher.encryptor()\n    ct_data = encryptor.update(data) + encryptor.finalize()\n\n    return salt, iv, ct_data\n\n# Decrypting the data with AES-256 in CBC mode\ndef decrypt_data(salt, iv, ciphertext, password):\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=100000,\n        backend=backend\n    )\n    key = kdf.derive(password.encode())\n\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)\n    decryptor = cipher.decryptor()\n    return decryptor.update(ciphertext) + decryptor.finalize()\n\n# Create a digital signature using SHA256 to ensure integrity\ndef sign_data(data, private_key):\n    signature = private_key.sign(\n        data,\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    return signature\n\n# Verify the digital signature of the data using SHA256\ndef verify_signature(data, publicKey_pem, signature):\n    public_key = serialization.load_pem_public_key(\n       publicKey_pem,\n       backend=default_backend()\n    )\n\n    try:\n        public_key.verify(\n            signature,\n            data,\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n             ),\n            hashes.SHA256()\n        )\n        print("Signature is valid.")\n    except Exception as e:\n        print("Invalid signature", str(e))\n\n# Usage example:\ndata = b"This is the data to encrypt and sign."\n\n# Encrypting the data with a password\nsalt, iv, ciphertext = encrypt_data(data, 'my_secure_password')\n\n# Signing the ciphertext (ensure integrity of encrypted data)\nwith open('private_key.pem', 'rb') as key_file: # Load your private key from file\n    private_key = serialization.load_pem_private_key(\n        key_file.read(),\n        password=None,\n        backend=backend\n    )\n\nsignature = sign_data(ciphertext, private_key)\n\n# Verifying the signature before decryption (integrity check)\nwith open('public_key.pem', 'rb') as key_file:  # Load your public key from file\n    publicKey_pem = key_file.read()\n\nverify_signature(ciphertext, publicKey_pem, signature)\n\n# Decrypting the data with a password and correct signature validation above\ndecrypted_data = decrypt_data(salt, iv, ciphertext, 'my_secure_password')