from itertools import permutations\n\ndef normalize_circular(permutation):\n    """Return the lexicographically smallest cyclic rotation."""\n    return min([permutation[i:] + permutation[:i] for i in range(len(permutation))])\n\ndef generate_unique_permutations(n, m, e1='a', e2='b'):\n    # Generate all unique permutations\n    all_elements = [e1]*n + [e2]*m\n    perm_set = set(permutations(all_elements))\n    \n    valid_perms = []\n    visited_circular = set()\n    \n    for p in perm_set:\n        rev_p = tuple(reversed(p))  # Check mirrored\n        if p <= rev_p:  # Only consider lexicographically smaller or equal to its reverse\n            p_normalized = normalize_circular(p)\n            if p_normalized not in visited_circular:\n                valid_perms.append(p)\n                visited_circular.add(p_normalized)\n    \n    return valid_perms\n\n# Example usage\nN, M = 3, 2\nresult = generate_unique_permutations(N, M)\nfor perm in result:\n    print(''.join(perm))