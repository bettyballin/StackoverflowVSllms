def match_entries(query, entries):\n    query_lower = query.lower()\n    matches = []\n    \n    for entry in entries:\n        # Convert title and URL to lowercase for case-insensitive matching\n        title_lower = entry['title'].lower()\n        url_lower = entry['url'].lower()\n        \n        # Check if the query is part of either the title or URL\n        if query_lower in title_lower or query_lower in url_lower:\n            # Simple scoring can be based on how close to the start of string the query appears\n            score_title = -title_lower.find(query_lower)\n            score_url = -url_lower.find(query_lower)\n            \n            # Combine scores (higher is better)\n            total_score = score_title + score_url\n            \n            matches.append((total_score, entry))\n    \n    # Sort entries by score in descending order to get the best matches first\n    return sorted(matches, key=lambda x: x[0], reverse=True)\n\n# Example usage\nentries = [\n    {'url': 'https://security.stackexchange.com', 'title': 'Information Security Stack Exchange'},\n    {'url': 'http://example.com/', 'title': 'Example Domain'},\n]\n\nquery = "sec"\nmatching_entries = match_entries(query, entries)\nfor score, entry in matching_entries:\n    print(f"Matched: {entry['url']} with score: {score}")