def calculate_final_scores(previous_scores, finishing_positions):\n    """\n    Calculate final scores for players based on previous scores and their finishing positions.\n    \n    :param previous_scores: A dictionary {player_id: score} representing the previous scores of each player.\n    :param finishing_positions: A list of tuples (player_id, position) where position is 1-based index.\n    :return: A dictionary {player_id: final_score} with updated scores for each player.\n    """\n    \n    # Normalize previous scores\n    total_previous_score = sum(previous_scores.values())\n    normalized_scores = {\n        player_id: score / total_previous_score for player_id, score in previous_scores.items()\n    }\n    \n    # Calculate position-based points (assuming more negative points for lower positions)\n    num_players = len(fixing_positions)\n    position_points = {position: 2 * (num_players - position) for position in range(1, num_players + 1)}\n    \n    # Calculate final scores\n    final_scores = {}\n    for player_id, position in finishing_positions:\n        base_score = normalized_scores[player_id]\n        adjustment = position_points[position]\n        final_scores[player_id] = base_score * adjustment\n    \n    return final_scores\n\n# Example usage\nprevious_scores = {'A': 200, 'B': 100}  # Previous scores of players A and B\nfinishing_positions = [('A', 1), ('B', 2)]  # Player A finished 1st, player B finished 2nd\n\nfinal_scores = calculate_final_scores(previous_scores, finishing_positions)\nprint(final_scores)  # Output will show final scores considering both previous performance and positions