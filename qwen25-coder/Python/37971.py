from collections import deque\nimport random\n\n# Assuming we have a set of tiles represented as numbers in a list\ntile_set = [1, 2, 3, ..., 47, 48] * 4  # Simplified representation\n\ndef is_solvable(tableau):\n    # Implement your function to check if the current tableau is solvable\n    return True  # Placeholder for a proper implementation\n\ndef shuffle_and_check(solvable_tableau):\n    queue = deque()\n    queue.append((solvable_tableau, []))  # (current_state, moves_made)\n    \n    while queue:\n        current_state, moves = queue.popleft()\n        \n        # Shuffle tiles slightly and check solvability\n        shuffled_state = current_state[:]\n        random.shuffle(shuffled_state[:10])  # Shuffling first 10 tiles as an example\n        \n        if is_solvable(shuffled_state):\n            return shuffled_state\n        \n        # Add more moves or shuffling patterns here to explore different states\n    \n    return solvable_tableau  # Return original if no other solutions found\n\n# Start with a known solvable tableau (example: sorted tiles)\nknown_solvable_tableau = sorted(tile_set)\n\n# Generate a shuffled layout that is guaranteed to be solvable\nshuffled_layout = shuffle_and_check(known_solvable_tableau)\n\nprint("Shuffled but solvable Mahjong Layout:", shuffled_layout)