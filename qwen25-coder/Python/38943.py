def count_back_edges(graph, order):\n    back_edge_count = 0\n    order_index = {node: i for i, node in enumerate(order)}\n    for u in graph:\n        for v in graph[u]:\n            if order_index[u] > order_index[v]:  # Backward edge\n                back_edge_count += 1\n    return back_edge_count\n\ndef swap_nodes_and_minimize_feedback(graph, order):\n    improved = True\n    while improved:\n        improved = False\n        for i in range(len(order)):\n            for j in range(i + 1, len(order)):\n                new_order = order[:]\n                new_order[i], new_order[j] = new_order[j], new_order[i]\n                if count_back_edges(graph, new_order) < count_back_edges(graph, order):\n                    order, improved = new_order, True\n    return order\n\n# Example usage:\ngraph = {\n    'A': ['C', 'D'],\n    'B': ['A'],\n    'C': ['B'],\n    'D': [],\n}\n\ninitial_order = ['A', 'B', 'C', 'D']\noptimized_order = swap_nodes_and_minimize_feedback(graph, initial_order)\nprint("Optimized Order:", optimized_order)