from collections import deque, defaultdict\n\ndef bfs_topological_sort(graph):\n    # Compute in-degrees of all nodes\n    in_degree = {node: 0 for node in graph}\n    for u in graph:\n        for v in graph[u]:\n            in_degree[v] += 1\n    \n    # Collect all nodes with no incoming edges\n    queue = deque([node for node in in_degree if in_degree[node] == 0])\n    \n    sorted_order = []\n    \n    while queue:\n        current = queue.popleft()\n        sorted_order.append(current)\n        \n        # Reduce the in-degree of the neighbors\n        for neighbor in graph[current]:\n            in_degree[neighbor] -= 1\n            # If in-degree becomes zero, enqueue it\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check to see if all nodes were visited (graph has no cycle)\n    if len(sorted_order) == len(graph):\n        return sorted_order\n    else:\n        raise ValueError("Graph contains a cycle!")\n\n# Example usage:\nif __name__ == "__main__":\n    # Representing the graph as an adjacency list\n    graph = {\n        "A": ["C"],\n        "B": ["C", "D"],\n        "C": ["E"],\n        "D": ["F"],\n        "E": ["H"],\n        "F": ["G"],\n        "G": [],\n        "H": []\n    }\n    \n    try:\n        result = bfs_topological_sort(graph)\n        print("Topological Order:", result)\n    except ValueError as e:\n        print(e)