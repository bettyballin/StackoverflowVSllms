from Crypto.Cipher import AES\nimport os\nimport struct\n\ndef aes_ctr_permute(start, end):\n    # Check inputs\n    if start >= end:\n        raise ValueError("Start must be less than end")\n    \n    range_size = end - start\n    \n    def encrypt_counter(counter):\n        nonce = b'\x00' * 8  # Fixed nonce for simplicity; in practice, this should be randomly generated and unique for each execution.\n        ctr_bytes = struct.pack('<Q', counter) + nonce\n        cipher = AES.new(os.urandom(16), AES.MODE_ECB)  # Random key for demonstration purposes\n        return struct.unpack('<Q', cipher.encrypt(ctr_bytes)[:8])[0]\n    \n    def unbounded_permutation(counter):\n        """Generate a permutation of non-negative integers."""\n        while True:\n            e = encrypt_counter(counter)\n            counter += 1\n            if e < range_size:\n                yield e + start\n    \n    return unbounded_permutation\n\n# Usage example\nperm_gen = aes_ctr_permute(100000, 999999)\nfor _ in range(900000):  # 999999 - 100000 + 1 numbers in range\n    print(next(perm_gen))