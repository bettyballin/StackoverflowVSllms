import os\nimport tempfile\n\ndef write_list_to_file(data, file_name):\n    with open(file_name, 'wb') as f:\n        for number in data:\n            f.write(number.to_bytes(4, byteorder='big'))\n\ndef read_numbers_from_file(file_name):\n    with open(file_name, 'rb') as f:\n        while True:\n            bytes_read = f.read(4)\n            if not bytes_read:\n                break\n            yield int.from_bytes(bytes_read, byteorder='big')\n\ndef merge_sorted_files(file_names, output_file):\n    sorted_files = [read_numbers_from_file(fn) for fn in file_names]\n    iterators = [iter(f) for f in sorted_files]\n    merged_iterators = []\n\n    # Prime the iterators and handle empty streams\n    for it in iterators:\n        try:\n            next_item = next(it)\n            merged_iterators.append((next_item, it))\n        except StopIteration:\n            pass\n\n    with open(output_file, 'wb') as output:\n        while merged_iterators:\n            # Choose the smallest item\n            _, it_to_use = min(merged_iterators, key=lambda x: x[0])\n            value_to_write = next(it_to_use)\n            output.write(value_to_write.to_bytes(4, byteorder='big'))\n\n            try:\n                next_value = next(it_to_use)\n                # Replace minimum with new head of the iterator\n                for i in range(len(merged_iterators)):\n                    if merged_iterators[i][1] is it_to_use:\n                        merged_iterators.pop(i)\n                        break\n                merged_iterators.append((next_value, it_to_use))\n            except StopIteration:\n                merged_iterators.remove((value_to_write, it_to_use))\n\ndef split_into_sorted_runs(data_file_name, run_size):\n    runs = []\n    with open(data_file_name, 'rb') as f:\n        while True:\n            current_run = []\n            for _ in range(run_size):\n                bytes_read = f.read(4)\n                if not bytes_read:\n                    break\n                number = int.from_bytes(bytes_read, byteorder='big')\n                current_run.append(number)\n\n            # Sort this run and write to file\n            if len(current_run) > 0:\n                temp_file = tempfile.NamedTemporaryFile(delete=False, mode='wb')\n                temp_file.name += '.bin'\n                runs.append(temp_file.name)\n                temp_file.close()\n                current_run.sort()\n                write_list_to_file(current_run, runs[-1])\n\n    return runs\n\ndef external_merge_sort(data_file_name):\n    # Assuming each integer takes 4 bytes\n    memory_size = 2 * 1024 * 1024  # in bytes\n    run_size = memory_size // (4 * 2)  # divide by 2 to be safe; adjust as needed\n\n    runs = split_into_sorted_runs(data_file_name, run_size)\n    \n    while len(runs) > 1:\n        new_runs = []\n        while len(runs) >= 2:\n            left_run = runs.pop(0)\n            right_run = runs.pop(0)\n            merged_run = tempfile.NamedTemporaryFile(delete=False, mode='wb')\n            merged_run.name += '.bin'\n            merge_sorted_files([left_run, right_run], merged_run.name)\n            new_runs.append(merged_run.name)\n\n        # If there's one leftover run, it doesn't need to be merged\n        if runs:\n            new_runs.extend(runs)\n\n        runs = new_runs\n\n    return runs[0]  # This is the name of the final sorted file