def transitive_reduction(dag):\n    # Assuming dag is represented as an adjacency list\n    n = len(dag)\n    reachable = [[False] * n for _ in range(n)]\n\n    def dfs(node, parent=None):\n        if visited[node]:\n            return\n        visited[node] = True\n        for neighbor in dag[node]:\n            if neighbor != parent:  # Avoid parent to avoid forming cycles\n                dfs(neighbor, node)\n                reachable[node][neighbor] = True\n\n    # Initialize and perform DFS to fill the reachability matrix\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n\n    # Remove transitive edges by consulting the reachability matrix\n    for u in range(n):\n        for v in range(n):\n            for w in range(n):\n                if reachable[u][v] and reachable[v][w]:\n                    try:\n                        dag[u].remove(w)  # Remove edge u -> w if w is reachable via v\n                    except ValueError:\n                        continue\n\ndef topological_sort(dag):\n    visited = set()\n    stack = []\n\n    def dfs(node):\n        visited.add(node)\n        for neighbor in dag[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n        stack.append(node)\n\n    for i in range(len(dag)):\n        if i not in visited:\n            dfs(i)\n\n    return stack[::-1]  # Reversing the stack gives topologically sorted nodes\n\n# Example usage\ndag = {\n    0: [1, 2],\n    1: [2],\n    2: [],\n}\n\ntransitive_reduction(dag)\nsorted_nodes = topological_sort(dag)\nprint(sorted_nodes)  # Output might be [0, 1, 2] or another valid order