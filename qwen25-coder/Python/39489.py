import heapq\n\ndef merge_k_sorted_lists(lists):\n    # Create a list to store the first item from each list along with its index and origin (which list it comes from)\n    heap = []\n    for i, lst in enumerate(lists):\n        if len(lst) > 0:\n            heapq.heappush(heap, (lst[0], i, 0))  # (value, index_of_list, element_index_in_list)\n\n    merged = []\n    while heap:\n        smallest_value, list_index, element_index = heapq.heappop(heap)\n        merged.append(smallest_value)\n        \n        if element_index + 1 < len(lists[list_index]):\n            next_item = lists[list_index][element_index + 1]\n            heapq.heappush(heap, (next_item, list_index, element_index + 1))\n    \n    return merged\n\ndef locate_t_items(lists, t):\n    # This function will return the indices of the first `t` elements in the merged sorted array\n    merge_heap = []\n    for i, lst in enumerate(lists):\n        if len(lst) > 0:\n            heapq.heappush(merge_heap, (lst[0], i, 0))  # (value, index_of_list, element_index_in_list)\n\n    result_indices = []\n    current_element_count = 0\n\n    while merge_heap and current_element_count < t:\n        smallest_value, list_index, element_index = heapq.heappop(merge_heap)\n        # Logically this would be the place where you log or store the position of `smallest_value`\n        result_indices.append((list_index, element_index))  # Store from which original list and what index\n        current_element_count += 1\n\n        if element_index + 1 < len(lists[list_index]):\n            next_item = lists[list_index][element_index + 1]\n            heapq.heappush(merge_heap, (next_item, list_index, element_index + 1))\n    \n    return result_indices\n\n# Example usage:\nlists = [\n    [10, 20, 30],\n    [5, 15, 25],\n    [7, 9, 11]\n]\n\nprint(locate_t_items(lists, 4))  # Returns positions of the first 4 smallest elements