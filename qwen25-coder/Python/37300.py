class Graph:\n    def __init__(self, vertices):\n        self.matching = {}\n        self.graph = {v: [] for v in vertices}\n    \n    def add_edge(self, u, v):\n        if v not in self.graph[u]:\n            self.graph[u].append(v)\n            self.graph[v].append(u)\n    \n    def bfs_path(self, start, goal):\n        explored = set()\n        queue = [[start]]\n        \n        while queue:\n            path = queue.pop(0)\n            node = path[-1]\n            \n            if node not in explored:\n                neighbours = self.get_neighbours(node)\n                \n                for neighbour in neighbours:\n                    new_path = list(path)\n                    new_path.append(neighbour)\n                    queue.append(new_path)\n                    \n                    if neighbour == goal:\n                        return new_path\n                \n                explored.add(node)\n        return []\n    \n    def get_neighbours(self, v):\n        return self.graph[v]\n    \n    def find_augmenting_path(self, start):\n        for node in [node for node in self.graph.keys() if node not in self.matching]:\n            path = self.bfs_path(start, node)\n            if path:\n                return path\n        return []\n    \n    def augment(self, path):\n        for i in range(len(path) - 1):\n            u = path[i]\n            v = path[i+1]\n            \n            if v in self.matching and self.matching[v] == u:\n                del self.matching[u]\n                del self.matching[v]\n            else:\n                self.matching[u] = v\n                self.matching[v] = u\n\ndef edmonds_algorithm(vertices, edges):\n    graph = Graph(vertices)\n    \n    for edge in edges:\n        graph.add_edge(edge[0], edge[1])\n    \n    for node in vertices:\n        if node not in graph.matching:\n            path = graph.find_augmenting_path(node)\n            while path:\n                graph.augment(path)\n                path = graph.find_augmenting_path(node)\n    \n    return graph.matching\n\n# Example usage\nvertices = ['ABC', 'DEF', 'GHI']  # Natural keys from different sources\nedges = [('ABC', 'DEF'), ('DEF', 'GHI')]  # Links based on entity matching assumptions\n\nmatching_result = edmonds_algorithm(vertices, edges)\n\n# Print the result showing how natural keys should be linked under a single surrogate key\nfor key in sorted(matching_result.keys()):\n    print(f"Surrogate Key: {key}, Mapped Keys: {key} -> {matching_result[key]}")