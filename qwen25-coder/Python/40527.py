def select_n_best_features(prob_vector, n):\n    if n > len(prob_vector):\n        raise ValueError("n must be less than or equal to the length of the probability vector")\n    \n    # Initialize variables\n    max_sum = float('-inf')\n    start_index = 0\n    \n    # Calculate the sum of the first 'n' elements\n    current_sum = sum(prob_vector[:n])\n    \n    # Set this as the maximum sum initially\n    if current_sum > max_sum:\n        max_sum = current_sum\n        best_start = 0\n    \n    # Sliding window approach to find the subvector with the maximum sum\n    for i in range(n, len(prob_vector)):\n        # Slide the window to the right by subtracting the element that is left behind and adding the new element\n        current_sum += prob_vector[i] - prob_vector[i-n]\n        \n        # Update max_sum and best_start if current_sum is greater\n        if current_sum > max_sum:\n            max_sum = current_sum\n            best_start = i - n + 1\n    \n    # Return the subvector with the maximum sum\n    return prob_vector[best_start:best_start+n]\n\n# Example usage\nprob_vector = [0.2, 0.2, 0.01, 0.01, 0.001, 0.001]\nn = 3\nselected_features = select_n_best_features(prob_vector, n)\nprint("Selected features:", selected_features)