import random\n\ndef corrupt_and_check(data):\n    # Simulate corruption of one byte in the data\n    index = random.randint(0, len(data) - 1)\n    original_byte = data[index]\n    corrupted_byte = (original_byte + random.randint(1, 254)) % 256\n    corrupted_data = data[:index] + bytes([corrupted_byte]) + data[index+1:]\n    \n    # Calculate the checksum for the original and corrupted data\n    original_checksum = sum(data) % 256\n    corrupted_checksum = sum(corrupted_data) % 256\n    \n    # Return True if the corrupted data has the same checksum as the original\n    return original_checksum == corrupted_checksum\n\ndef simulate_error_rate(size=10, iterations=100000):\n    errors = 0\n    for _ in range(iterations):\n        # Generate random data of specified size\n        data = bytes([random.randint(0, 255) for _ in range(size)])\n        if corrupt_and_check(data):\n            errors += 1\n    error_rate = errors / iterations\n    return error_rate\n\n# Simulate with default settings\nsimulated_error_rate = simulate_error_rate()\nprint(f"Simulated Error Rate: {simulated_error_rate}")