def count_combinations(groups, constraints):\n    # Helper function to check if a configuration violates any constraints\n    def is_valid(config):\n        for i1, j1, i2, j2 in constraints:\n            if config[i1] == j1 and config[i2] == j2:\n                return False\n        return True\n\n    # Recursive backtracking function to explore all configurations\n    def backtrack(group_index, current_config):\n        if group_index == len(groups):\n            # If all groups are configured, check if it's valid\n            return 1 if is_valid(current_config) else 0\n        \n        count = 0\n        for option in range(len(groups[group_index])):\n            current_config.append(option)\n            count += backtrack(group_index + 1, current_config)\n            current_config.pop()\n        \n        return count\n\n    # Start backtracking from the first group with an empty configuration\n    return backtrack(0, [])\n\n# Example usage\ngroups = [\n    ['x1', 'x2', 'x3', 'x4', 'x5'],\n    ['y1', 'y2', 'y3'],\n    ['z1', 'z2', 'z3', 'z4']\n]\n\nconstraints = [\n    (0, 0, 1, 1),  # If x1 in group 1 is selected, then y2 in group 2 can't be selected\n    (0, 0, 2, 3),  # If x1 in group 1 is selected, then z4 in group 3 can't be selected\n    (1, 1, 2, 1)   # If y2 in group 2 is selected, then z2 in group 3 can't be selected\n]\n\nprint(count_combinations(groups, constraints))