def find_recurring_decimal(a, b):\n    # Dictionary to store seen remainders and their respective positions\n    seen_remainders = {}\n    \n    # Get the integer quotient (non-repeating part)\n    quotient = str(a // b) + "."\n    \n    # Calculate the remainder\n    remainder = a % b\n    \n    # Position index for the decimal part\n    index = 0\n    \n    while remainder != 0:\n        # If the remainder is already seen, we've found a repeating cycle\n        if remainder in seen_remainders:\n            start_index = seen_remainders[remainder]\n            non_repeating = quotient[:start_index]\n            repeating = quotient[start_index:]\n            return f"{non_repeating}({repeating})"\n        \n        # Store the index of this remainder\n        seen_remainders[remainder] = len(quotient)\n        \n        # Perform long division\n        remainder *= 10\n        digit = remainder // b\n        quotient += str(digit)\n        remainder %= b\n        \n        index += 1\n    \n    # If no repeating part is found, return the non-repeating part only\n    return quotient.rstrip('.')\n\n# Example usage:\nprint(find_recurring_decimal(1, 3))  # Output: "0.(3)"\nprint(find_recurring_decimal(4, 7))  # Output: "0.(571428)"