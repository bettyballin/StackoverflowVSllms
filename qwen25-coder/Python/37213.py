def mgu(e1, e2, subs={}):\n    # Apply existing substitutions to e1 and e2\n    e1 = apply_substitutions(e1, subs)\n    e2 = apply_substitutions(e2, subs)\n\n    if e1 == e2:\n        return subs  # Trivial solution\n\n    elif isinstance(e1, Var) and not occurs_in(e1.name, e2):\n        # Unify variable e1 with term e2\n        return {**subs, e1.name: e2}\n\n    elif isinstance(e2, Var) and not occurs_in(e2.name, e1):\n        # Unify variable e2 with term e1\n        return {**subs, e2.name: e1}\n\n    elif is_application(e1) and is_application(e2):\n        # Both terms are function applications; unify recursively\n        f1, args1 = split_application(e1)\n        f2, args2 = split_application(e2)\n\n        if f1 != f2 or len(args1) != len(args2):\n            raise UnificationFailure("Terms cannot be unified")\n\n        for a1, a2 in zip(args1, args2):\n            subs = mgu(a1, a2, subs)\n\n        return subs\n\n    else:\n        raise UnificationFailure("Terms cannot be unified")\n\ndef apply_substitutions(term, subs):\n    # Applies substitutions to variables in term\n    if isinstance(term, Var) and term.name in subs:\n        return apply_substitutions(subs[term.name], subs)\n    elif is_application(term):\n        f, args = split_application(term)\n        return build_application(f, [apply_substitutions(a, subs) for a in args])\n    else:\n        return term\n\ndef occurs_in(var_name, term):\n    # Checks if variable name appears anywhere within the term\n    if isinstance(term, Var):\n        return term.name == var_name\n    elif is_application(term):\n        return any(occurs_in(var_name, t) for t in split_application(term)[1])\n    else:\n        return False\n\nclass UnificationFailure(Exception):\n    pass\n\nclass Var:\n    def __init__(self, name):\n        self.name = name\n\ndef is_variable(x):\n    return isinstance(x, Var)\n\ndef is_application(term):\n    # Check if the term is a function application\n    return not isinstance(term, Var) and callable(term)\n\ndef split_application(apply_term):\n    # Split a function application into (function, [args])\n    raise NotImplementedError("Implementation depends on how terms are represented.")\n\ndef build_application(func, args):\n    # Build a function application from func and its arguments args\n    raise NotImplementedError("Implementation depends on how terms are represented.")