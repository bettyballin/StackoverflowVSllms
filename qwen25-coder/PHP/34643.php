// Define a Processor Interface\ninterface ItemProcessor {\n    public function shouldProcess($item): bool;\n    public function process($item);\n}\n\n// Implement for Foo Items\nclass FooItemProcessor implements ItemProcessor {\n    public function shouldProcess($item): bool {\n        return $item['type'] === 'foo';\n    }\n\n    public function process($item) {\n        // Processing logic specific to foo items\n    }\n}\n\n// Implement for Bar Items\nclass BarItemProcessor implements ItemProcessor {\n    public function shouldProcess($item): bool {\n        return $item['type'] === 'bar';\n    }\n\n    public function process($item) {\n        // Processing logic specific to bar items\n    }\n}\n\n// Class that handles the iteration and processing based on the processor\nclass ItemIterator {\n    private $items;\n    private $processor;\n\n    public function __construct(array $items, ItemProcessor $processor) {\n        $this->items = $items;\n        $this->processor = $processor;\n    }\n\n    public function iterate() {\n        foreach ($this->items as $item) {\n            if ($this->processor->shouldProcess($item)) {\n                $this->processor->process($item);\n            }\n        }\n    }\n}\n\n// Usage\n$fooProcessor = new FooItemProcessor();\n$barProcessor = new BarItemProcessor();\n\n$fooIterator = new ItemIterator($array1, $fooProcessor);\n$fooIterator->iterate();\n\n$barIterator = new ItemIterator($array2, $barProcessor);\n$barIterator->iterate();