class ConnectionPool {\n    private $pool = [];\n    private $host;\n    private $port;\n\n    public function __construct($host, $port) {\n        $this->host = $host;\n        $this->port = $port;\n    }\n\n    public function getConnection() {\n        foreach ($this->pool as $index => $connection) {\n            if (is_resource($connection)) {\n                return $connection; // Return a reusable connection\n            } else {\n                unset($this->pool[$index]); // Clean up invalid connections\n            }\n        }\n        return $this->createNewConnection(); // No reusable connection, create one\n    }\n\n    private function createNewConnection() {\n        $context = stream_context_create(['socket' => ['so_keepalive' => true]]);\n        $connection = @stream_socket_client($this->host . ':' . $this->port, $errno, $errstr, 30, STREAM_CLIENT_CONNECT | STREAM_CLIENT_PERSISTENT, $context);\n        \n        if (!$connection) {\n            throw new Exception("Failed to connect: [$errno] $errstr");\n        }\n        $this->pool[] = $connection;\n        return $connection;\n    }\n\n    public function releaseConnection($connection) {\n        // Optionally you can implement logic here to keep the connection open\n        // For simplicity, we'll just let PHP close it when script execution ends\n    }\n\n    public function closeAllConnections() {\n        foreach ($this->pool as $connection) {\n            fclose($connection);\n        }\n        $this->pool = [];\n    }\n}\n\n// Usage example:\n$host = '127.0.0.1';\n$port = 8080;\n$pool = new ConnectionPool($host, $port);\n\ntry {\n    $conn = $pool->getConnection();\n    fwrite($conn, "Your request data here\n");\n    $result = fread($conn, 8192);\n    echo $result;\n} catch (Exception $e) {\n    echo 'Caught exception: ',  $e->getMessage(), "\n";\n} finally {\n    // Optionally release the connection back to the pool\n}