<?php\n\n// Create pipes for input/output communication between parent and child\n$descriptorspec = array(\n   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from\n   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to\n   2 => array("pipe", "w")   // stderr is another pipe that the child will write to\n);\n\n$pid = pcntl_fork();\n\nif ($pid == -1) {\n    die('could not fork');\n} else if ($pid) {\n    // We are the parent\n\n    // Close the child's stdin, stdout, and stderr\n    fclose($descriptorspec[0]);\n    fclose($descriptorspec[1]);\n    fclose($descriptorspec[2]);\n\n    $status = null;\n    do {\n        // Check on the status of the child process.\n        $pid_status = pcntl_waitpid($pid, $status);\n\n        if (pcntl_wifexited($status)) {\n            echo "Child exited with status: ".pcntl_wexitstatus($status)."\n";\n        } elseif (pcntl_wifsignaled($status)) {\n            echo sprintf("Child was killed by signal %d\n", pcntl_wtermsig($status));\n        }\n    } while ($pid_status == -1 && $errno == EINTR);\n\n} else {\n    // We are the child\n\n    fclose($descriptorspec[0]); // Close unused stdin channel\n\n    // Execute another PHP script and capture its output\n    $result = proc_open('/path/to/php/script', $descriptorspec, $pipes);\n    if (is_resource($result)) {\n        // Read the standard output from the child process\n        echo stream_get_contents($pipes[1]);\n\n        // Read the standard error from the child process\n        echo stream_get_contents($pipes[2]);\n\n        fclose($pipes[1]);\n        fclose($pipes[2]);\n        proc_close($result);\n    }\n\n    exit(0);\n}\n?>