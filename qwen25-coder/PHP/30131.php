<?php\n\nfunction findOptimalCombination($customPackage, $predefinedPackages) {\n    $bestSolution = null;\n    $minExtraItems = PHP_INT_MAX;\n\n    // Function to check if all items in $subset are contained in $set\n    function isSubset(array $subset, array $set): bool {\n        return count(array_diff($subset, $set)) === 0;\n    }\n\n    // Backtracking function to explore combinations\n    function backtrack(array $currentSolution, array $remainingItems, array $packages) use (&$bestSolution, &$minExtraItems) {\n        global $customPackage;\n\n        if (empty($remainingItems)) {\n            // Calculate number of extra items\n            $packagesUsed = count(array_filter($currentSolution));\n            $itemsUsed = 10 - count($packagesUsed);\n            $extraItems = count($remainingItems);\n\n            if ($extraItems < $minExtraItems || \n                ($extraItems === $minExtraItems && $packagesUsed < count(array_filter($bestSolution)))) {\n                $bestSolution = $currentSolution;\n                $minExtraItems = $extraItems;\n            }\n            return;\n        }\n\n        foreach (array_keys($packages) as $packageIndex) {\n            if (!in_array(true, $currentSolution[$packageIndex], true)) { // Avoid reusing the same package\n                if (isSubset(array_values(array_flip($packages[$packageIndex])), $remainingItems)) {\n                    $newRemaining = array_diff_key($remainingItems, array_flip($packages[$packageIndex]));\n                    $newCurrentSolution = $currentSolution;\n                    $newCurrentSolution[$packageIndex] = true;\n\n                    backtrack($newCurrentSolution, $newRemaining, $packages);\n                }\n            }\n        }\n\n        // Try including remaining items as individual\n        foreach (array_keys($remainingItems) as $itemIndex) {\n            $newCurrentSolution = $currentSolution;\n            $newCurrentSolution['individual'][] = array_keys($remainingItems)[$itemIndex];\n            unset($remainingItems[$itemIndex]);\n\n            backtrack($newCurrentSolution, $remainingItems, $packages);\n        }\n    }\n\n    // Convert custom package and predefined packages to a workable format\n    $customPackage = array_flip($customPackage);\n    foreach ($predefinedPackages as &$package) {\n        $package = array_flip($package);\n    }\n\n    backtrack([], $customPackage, $predefinedPackages);\n\n    return $bestSolution;\n}\n\n// Example usage:\n$customPackage = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'];\n$predefinedPackages = [\n    ['A', 'B', 'C', 'D', 'E'],\n    ['A', 'B', 'C'],\n    ['D', 'E', 'F']\n];\n\n$result = findOptimalCombination($customPackage, $predefinedPackages);\nprint_r($result);