$archivalie_id = filter_input(INPUT_GET, 'archivalie_id', FILTER_SANITIZE_NUMBER_INT);\n\nif ($archivalie_id === null || $archivalie_id < 1) {\n    die("Invalid archivalie_id");\n}\n\n// Prepare the SQL statement to prevent SQL injection.\n$query = "\n    SELECT \n        a.*, \n        COALESCE(ip.description, 'No data') AS internal_project,\n        COALESCE(o.description, 'No data') AS origin,\n        TO_CHAR(COALESCE(ad.origin_date, NOW()), 'YYYY') AS origin_date  \n    FROM archivalie AS a \n    LEFT JOIN archivalie_dating AS ad ON a.id = ad.archivalie_id                \n    LEFT JOIN internal_project AS ip ON a.internal_project_id = ip.id\n    LEFT JOIN origin AS o ON a.origin_id = o.id               \n    WHERE a.id = $1";\n\n// Use prepared statements to execute the query safely.\n$result = pg_prepare($db, "archivalie_query", $query);\n$stmt_result = pg_execute($db, "archivalie_query", array($archivalie_id));\n\nwhile ($row = pg_fetch_object($stmt_result)) {\n    // No need for separate checks, handled by COALESCE in SQL\n    echo "Internal Project: {$row->internal_project}<br>";\n    echo "Incoming Date: {$row->incoming_date}<br>";\n    echo "Origin: {$row->origin}<br>";\n}