<?php\n\n// Function to compute QR decomposition using Gram-Schmidt process\nfunction qr_decomposition($A) {\n    $Q = [];\n    $R = [];\n    $m = count($A);\n    $n = count($A[0]);\n\n    // Initialize Q and R matrices\n    for ($i = 0; $i < $m; $i++) {\n        $Q[$i] = array_fill(0, $n, 0);\n    }\n    for ($i = 0; $i < $n; $i++) {\n        $R[$i] = array_fill(0, $n, 0);\n    }\n\n    // Compute Q and R\n    for ($j = 0; $j < $n; $j++) {\n        $Q[$j][$j] = 1;\n        $v = [];\n        for ($i = 0; $i < $m; $i++) {\n            $v[] = $A[$i][$j];\n        }\n\n        for ($k = 0; $k <= $j - 1; $k++) {\n            $sum = 0;\n            for ($i = 0; $i < $m; $i++) {\n                $sum += $v[$i] * $Q[$i][$k];\n            }\n            $R[$k][$j] = $sum;\n            for ($i = 0; $i < $m; $i++) {\n                $v[$i] -= $sum * $Q[$i][$k];\n            }\n        }\n\n        $norm = norm($v);\n        $R[$j][$j] = $norm;\n        if (!is_zero($norm)) {\n            for ($i = 0; $i < $m; $i++) {\n                $Q[$i][$j] = $v[$i] / $norm;\n            }\n        }\n    }\n\n    return [$Q, $R];\n}\n\n// Function to compute the norm of a vector\nfunction norm($vector) {\n    return sqrt(array_sum(array_map(function ($x) {\n        return $x * $x;\n    }, $vector)));\n}\n\n// Function to check if a number is zero\nfunction is_zero($number, $epsilon = 1e-8) {\n    return abs($number) < $epsilon;\n}\n\n// Function to compute SVD using the QR algorithm\nfunction svd_decomposition($A) {\n    $U = [];\n    $S = [];\n    $Vt = [];\n\n    // Initial matrix A\n    $m = count($A);\n    $n = count($A[0]);\n\n    // Orthogonalization of columns of A via QR decomposition\n    list($Q, $R) = qr_decomposition($A);\n\n    // Iterate to find singular values and vectors\n    for ($i = 0; $i < 100; $i++) { // 100 iterations max\n        list($Qhat, $Thetak) = qr_decomposition(transpose($R));\n        list($Phat, $Tk) = qr_decomposition($Qhat);\n        $R = transpose($Tk) * Thetak;\n        $U = $U ? ($U * Phat) : $Phat;\n        $Vt = $Vt ? (transpose($Qhat) * $Vt) : transpose($Qhat);\n    }\n\n    // Extract singular values and vectors\n    foreach ($R as $i => $row) {\n        for ($j = 0; $j < count($row); $j++) {\n            if ($i == $j) {\n                $S[] = abs($row[$j]);\n            } else {\n                $U[$i][$j] *= sign($U[$i][$j]); // Make singular vectors have unit norm\n                $Vt[$i][$j] *= sign($Vt[$i][$j]);\n            }\n        }\n    }\n\n    return [$U, $S, transpose($Vt)];\n}\n\n// Helper function to transpose a matrix\nfunction transpose(array $matrix): array {\n    return array_map(null, ...$matrix);\n}\n\n// Example usage:\n$A = [\n    [1.0, 2.0],\n    [3.0, 4.0]\n];\n\nlist($U, $S, $Vt) = svd_decomposition($A);\n\necho "U:\n";\nprint_r($U);\necho "\nS:\n";\nprint_r($S);\necho "\nV^T:\n";\nprint_r($Vt);\n\n?>