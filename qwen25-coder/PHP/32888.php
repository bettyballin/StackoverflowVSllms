class foo {\n    protected $bar = array();\n\n    public function &getBar() { // Note: The return type needs to be specified as &\n        return $this->bar;\n    }\n}\n\nclass foo2 {\n    private $blip;\n\n    public function __construct() {\n        $fooInstance = new foo();\n        $this->blip = &$fooInstance->getBar(); // Use assignment by reference\n    }\n\n    public function modifyBlip() {\n        $this->blip[] = 'test';\n    }\n}\n\n$f2 = new foo2();\n$f2->modifyBlip();\n\n// Attempting to access $bar from outside the class through the reference\n$refBar =& $f2->blip;\nprint_r($refBar); // This will not work as expected due to encapsulation.\n\n// To see the results, we can add a method in foo2 to print it:\nclass foo2 {\n    private $blip;\n\n    public function __construct() {\n        $fooInstance = new foo();\n        $this->blip = &$fooInstance->getBar(); // Use assignment by reference\n    }\n\n    public function modifyBlip() {\n        $this->blip[] = 'test';\n    }\n\n    public function printBlip() {\n        print_r($this->blip);\n    }\n}\n\n$f2 = new foo2();\n$f2->modifyBlip();\n$f2->printBlip(); // This will output: Array ( [0] => test )