function http_digest_parse($txt) {\n    $needed_parts = array('nonce'=>1, 'nc'=>1, 'cnonce'=>1, 'qop'=>1, 'realm'=>1);\n    $data = array();\n    $keys = implode('|', array_keys($needed_parts));\n\n    preg_match_all('@(' . $keys . ')=(?:([\'"])([^\2]+?)\2|([^\s,]+))@', $txt, $matches, PREG_SET_ORDER);\n\n    foreach ($matches as $m) {\n        $data[$m[1]] = $m[3] ? $m[3] : $m[4];\n        unset($needed_parts[$m[1]]);\n    }\n\n    return $needed_parts ? false : $data;\n}\n\nfunction create_http_digest_response($username, $password, $realm, $method, $uri, $opaque) {\n    // Generate a random cnonce (client nonce)\n    $cnonce = md5(microtime());\n\n    // Generate nc value\n    static $nc = 1; // This should ideally persist across requests\n\n    // If qop is auth-int, also MD5 the entity body here.\n    $ha1 = md5("$username:$realm:$password");\n    $ha2 = md5($method . ":" . $uri); // No entity body involved\n\n    $digest_response = md5("$ha1:" . \n        $this->www_auth['nonce'] . ":" .\n        sprintf("%08d", $nc)  . ":" .\n        $cnonce . ":auth:" .\n        $ha2\n    );\n\n    return "Digest username=\"$username\", realm=\"$realm\",".\n           "nonce=\"" . $this->www_auth['nonce'] . "\"," .\n           "uri=\"$uri\"," .\n           "qop=auth, nc=" . sprintf("%08x", $nc) . "," .\n           "cnonce=\"$cnonce\"," .\n           ($opaque ? ", opaque=\"" . $opaque . "\"" : "") . \n           ", response=\"$digest_response\"";\n}\n\n// Usage:\n$www_authenticate_header = 'WWW-Authenticate: Digest realm="some_realm", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093"';\n$parsed = http_digest_parse($www_authenticate_header);\n\n$response = create_http_digest_response(\n    'user', \n    'pass', \n    $parsed['realm'], \n    'GET', // Method of the request (e.g., GET, POST)\n    '/protected_resource', // The URI being accessed\n    isset($parsed['opaque']) ? $parsed['opaque'] : null // Optional opaque value if present\n);\n\n// $response now contains the Authorization header you can use in your HTTP requests