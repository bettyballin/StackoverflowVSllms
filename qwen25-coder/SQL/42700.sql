WITH EventDurations AS (\n    SELECT \n        id,\n        date,\n        event,\n        CASE WHEN event = 'Service Delayed' THEN 1 ELSE 0 END AS is_delay_start,\n        CASE WHEN event = 'Service Reactivated' THEN 1 ELSE 0 END AS is_delay_end\n    FROM \n        event_table\n),\nDelaySequences AS (\n    SELECT \n        id,\n        date,\n        event,\n        SUM(is_delay_start) OVER (PARTITION BY id ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) - \n        SUM(is_delay_end) OVER (PARTITION BY id ORDER BY date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS delay_seq\n    FROM \n        EventDurations\n),\nActivePeriods AS (\n    SELECT \n        id,\n        CASE \n            WHEN LAG(event, 1, 'Service Request') OVER (PARTITION BY id ORDER BY date) = 'Service Reactivated' THEN 0\n            ELSE 1 - COALESCE(SUM(is_delay_start), 0)\n        END AS is_active_period,\n        event,\n        DATEDIFF(SECOND, LAG(date, 1, date) OVER (PARTITION BY id ORDER BY date), date) AS time_diff\n    FROM \n        DelaySequences\n),\nFilteredEvents AS (\n    SELECT \n        id,\n        SUM(CASE WHEN is_active_period = 1 THEN time_diff ELSE 0 END) AS total_time_seconds\n    FROM \n        ActivePeriods\n    WHERE \n        event NOT IN ('Service Delayed', 'Service Reactivated') -- Ensuring we don't count non-active periods\n    GROUP BY \n        id\n)\nSELECT \n    id,\n    CONCAT(FLOOR(total_time_seconds / 60), ' minutes') AS time\nFROM \n    FilteredEvents;