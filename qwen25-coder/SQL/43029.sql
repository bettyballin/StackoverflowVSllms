DECLARE @Columns NVARCHAR(MAX) = N'';\nDECLARE @FetchClause NVARCHAR(MAX) = N'';\nDECLARE @SQL NVARCHAR(MAX) = N'';\n\n-- Assuming your table or joined tables are named MyTable\nSELECT \n    @Columns += QUOTENAME(name) + ',',\n    @FetchClause += '@Var' + CAST(ROW_NUMBER() OVER (ORDER BY column_id) AS VARCHAR(3)) + ' ' + system_type_name + OUTPUT,\n    @SQL += '@Var' + CAST(ROW_NUMBER() OVER (ORDER BY column_id) AS VARCHAR(3)) + ' ' + system_type_name + N','\nFROM sys.columns\nWHERE object_id = OBJECT_ID('MyTable')\nAND is_computed = 0 AND is_identity = 0;\n\n-- Remove trailing commas\nSET @Columns = LEFT(@Columns, LEN(@Columns) - 1);\nSET @FetchClause = LEFT(@FetchClause, LEN(@FetchClause) - 17); -- Adjust this based on ' OUTPUT' length\nSET @SQL = 'DECLARE ' + LEFT(@SQL, LEN(@SQL) - 1) + ';';\n\n-- Construct the full SQL statement for the cursor\nSET @SQL += N'\nDECLARE cur CURSOR FOR SELECT ' + @Columns + ' FROM MyTable;\nOPEN cur;\nFETCH NEXT FROM cur INTO ' + @FetchClause + ';\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    -- Your processing code goes here\n    FETCH NEXT FROM cur INTO ' + @FetchClause + ';\nEND\nCLOSE cur;\nDEALLOCATE cur;\n\n-- Example output - remove when no longer needed\nSELECT ' + @FetchClause + ';\n';\n\n-- Execute the dynamic SQL\nEXEC sp_executesql @SQL;