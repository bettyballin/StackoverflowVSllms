WITH AllTables AS (\n    SELECT OBJECT_SCHEMA_NAME(object_id) + '.' + name AS TableName\n    FROM sys.tables\n),\nForeignKeys AS (\n    SELECT \n        OBJECT_SCHEMA_NAME(fk.parent_object_id) + '.' + OBJECT_NAME(fk.parent_object_id) AS TableName,\n        COLUMN_NAME(fc.parent_column_id, fc.parent_object_id) AS ColumnName,\n        OBJECT_SCHEMA_NAME(fk.referenced_object_id) + '.' + OBJECT_NAME(fk.referenced_object_id) AS ReferenceTableName,\n        COLUMN_NAME(fc.referenced_column_id, fc.referenced_object_id) AS ReferenceColumnName\n    FROM sys.foreign_keys fk\n    INNER JOIN sys.foreign_key_columns fc ON fk.OBJECT_ID = fc.constraint_object_id\n),\nReferencingTables AS (\n    SELECT TableName AS RootTable, TableName, 0 AS Depth\n    FROM ForeignKeys\n    UNION ALL\n    SELECT rt.RootTable, fk.TableName, rt.Depth + 1\n    FROM ReferencingTables rt\n    JOIN ForeignKeys fk ON rt.TableName = fk.ReferenceTableName\n)\nSELECT DISTINCT t.TableName,\n       CASE\n           WHEN ntn.TableName IS NOT NULL THEN 1000 -- Tables not part of a relationship\n           WHEN ort.TableName IS NOT NULL THEN 2000 -- Only referenced tables\n           WHEN otr.RootTable <> otr.TableName THEN 3000 -- Part of a relationship, ordered by depth in recursion\n           ELSE 4000 -- Only referencing tables\n       END AS Sorting,\n       CASE \n           WHEN rt.TableName = RootTable THEN Depth * 10\n           ELSE NULL\n       END AS DependencySorting\nFROM AllTables t\nLEFT JOIN (SELECT TableName FROM ReferencingTables WHERE RootTable <> TableName) ntn ON t.TableName = ntn.TableName -- NotReferencedOrReferencing\nLEFT JOIN (SELECT DISTINCT ReferenceTableName AS TableName FROM ForeignKeys) ort ON t.TableName = ort.TableName -- OnlyReferenced\nLEFT JOIN ReferencingTables rt ON rt.RootTable = t.TableName -- ReferencedAndReferencing, including depth information\nWHERE \n    ntn.TableName IS NOT NULL OR\n    ort.TableName IS NOT NULL OR\n    rt.RootTable = rt.TableName\nORDER BY Sorting, DependencySorting;