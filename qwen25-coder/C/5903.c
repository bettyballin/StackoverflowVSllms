#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];\n    pid_t cpid;\n    char buffer[1024];\n\n    if (pipe(pipefd) == -1) { // Create a pipe\n        perror("pipe");\n        exit(EXIT_FAILURE);\n    }\n\n    cpid = fork(); // Fork a new process\n    if (cpid == -1) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (cpid == 0) { // Child process\n        close(pipefd[0]);          // Close unused read end of pipe\n        dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to the pipe's write end\n\n        execlp("ls", "ls", "-l", "/nonexistent_directory", (char *) NULL);\n        perror("execlp");           // Exec only returns on error\n        _exit(EXIT_FAILURE);\n    } else { // Parent process\n        close(pipefd[1]);          // Close unused write end of pipe\n\n        ssize_t bytesRead;\n        while ((bytesRead = read(pipefd[0], buffer, sizeof(buffer)-1)) > 0) {\n            buffer[bytesRead] = '\0'; // Null-terminate the string\n            printf("Output from child process: %s", buffer);\n        }\n\n        int status;\n        waitpid(cpid, &status, 0); // Wait for the child to terminate\n\n        if (WIFEXITED(status)) {\n            printf("Child exited with status %d\n", WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf("Child terminated by signal %d\n", WTERMSIG(status));\n        }\n\n        close(pipefd[0]);          // Close read end of pipe\n    }\n\n    return 0;\n}