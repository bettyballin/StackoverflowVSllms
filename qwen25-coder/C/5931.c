#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* newNode(int data) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->data = data;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\nvoid printBranches(int branchLen, int nodeSpaceLen, int startLen, int isLeft) {\n    for (int i = 0; i < startLen; i++) {\n        printf(" ");\n    }\n    if (branchLen > 1) {\n        for (int i = 0; i < branchLen - 1; i++) {\n            if (i == 0) {\n                printf(isLeft ? "/" : " ");\n            } else {\n                printf(" ");\n            }\n            for (int j = 0; j < nodeSpaceLen + 2; j++) {\n                printf(" ");\n            }\n            printf(isLeft ? "\\" : " ");\n        }\n    }\n}\n\nvoid printNodeValue(int treeWidth, const char* valStr, int fillLength) {\n    int centerPos = treeWidth / 2 - (int)(strlen(valStr)) / 2;\n    for (int i = 0; i < centerPos + fillLength; i++) {\n        printf(" ");\n    }\n    printf("%s", valStr);\n}\n\nvoid printWhitespaces(int count) {\n    for (int i = 0; i < count; i++) {\n        printf(" ");\n    }\n}\n\nvoid printNodes(int branchLen, int nodeSpaceLen, int startLen, int nodesInThisLevel, const Node** nodes) {\n    int ceilIndex = (nodesInThisLevel + 1) >> 1;\n    for (int index = 0; index < ceilIndex; index++) {\n        if ((index == 0 && !isLeftEmpty(index, nodes)) || (!isRightEmpty(index - 1, nodes))) {\n            printWhitespaces(startLen - branchLen);\n        } else {\n            printWhitespaces(startLen - branchLen * 2 + 2);\n        }\n        printBranches(branchLen, nodeSpaceLen, startLen > branchLen ? branchLen : startLen, index == 0);\n    }\n\n    printf("\n");\n\n    for (int index = 0; index < ceilIndex; index++) {\n        if (nodes[index] != NULL) {\n            fillWithSpacesIfNull(index * 2 - 1, nodesInThisLevel, nodes);\n            printNodeValue(branchLen + 2, (char*)malloc(3*sizeof(char)), nodeSpaceLen);\n            free((void*)(nodes[index]->data));\n            printWhitespaces(4);\n            fillWithSpacesIfNull(index * 2, nodesInThisLevel, nodes);\n\n        } else if (index < ceilIndex - 1 && nodes[index + 1] != NULL) {\n            printWhitespaces(nodeSpaceLen + 2);\n        }\n    }\n\n    printf("\n");\n    for (int index = 0; index < ceilIndex; index++) {\n        printBranches(branchLen, nodeSpaceLen, startLen > branchLen ? branchLen : startLen, index >= ceilIndex - 1);\n    }\n\n}\n\nvoid fillWithSpacesIfNull(int index, int nodesInThisLevel, const Node** nodes) {\n    if (index >= nodesInThisLevel || nodes[index] == NULL) {\n        printWhitespaces(4);\n    } else {\n        char valStr[256];\n        sprintf(valStr, "%d", nodes[index]->data);\n        printNodeValue(branchLen + 2, valStr, nodeSpaceLen);\n    }\n}\n\nint isLeftEmpty(int index, const Node** nodes) {\n    if (index * 2 + 1 >= nodesInThisLevel || nodesIndex * 2 + 1] == NULL) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint isRightEmpty(int index, const Node** nodes) {\n    if ((index * 2 + 2) >= nodesInThisLevel || nodes[index * 2 + 2] == NULL) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nvoid prettyPrintTree(Node* root) {\n    int h = calculateHeight(root);\n    int fullWidth = ((int)(pow(2, h)) - 1);\n\n    if (root != NULL) {\n        const Node** levelNodes = malloc(fullWidth * sizeof(Node*));\n        memset((void*)levelNodes, (int)NULL, sizeof(levelNodes) / sizeof(levelNodes[0]));\n        queueInit();\n        enqueue(root);\n        int count = 0;\n        while(count < fullWidth) {\n            Node* node = dequeue(); \n            levelNodes[count] = node;\n            if(node != NULL){\n                enqueue(node->left);\n                enqueue(node->right);    \n            }\n            else{\n                enqueue(NULL);\n                enqueue(NULL);\n            }\n\n            count++;\n        }\n\n        int startLen = (int)((pow(2.0,h))-1);\n        printNodeValue(startLen,  "-", nodeSpaceLen);\n\n        for(int i=1; i<=h;i++){\n            printBranches(branchLen,i,startLen-4*i,nodeSpaceLen);\n            startLen=startLen - 2;\n          }\n\n        for (int level = 1; level <= h; level++) {\n            int nodesInThisLevel = pow(2, level - 1);\n            for (int i = 0; i < nodesInThisLevel; i++) {\n                // printBranches(branchLen,i,startLen-4*i,nodeSpaceLen);\n                if (levelNodes[i] != NULL) {\n                    char valStr[256];\n                    sprintf(valStr, "%d", levelNodes[i]->data);\n                    fillWithSpacesIfNull(i * 2 - 1, nodesInThisLevel, levelNodes);\n                    printNodeValue(branchLen + 2, valStr, nodeSpaceLen);\n                } else {\n                    fillWithSpacesIfNull(i * 2 - 1, nodesInThisLevel, levelNodes);\n                    printWhitespaces(4);\n                    fillWithSpacesIfNull(i * 2, nodesInThisLevel, levelNodes);\n                }\n            }\n\n            printf("\n");\n\n            for (int i = 0; i < nodesInThisLevel; i++) {\n                // printBranches(branchLen,i,startLen-4*i,nodeSpaceLen);     \n                if (levelNodes[i] != NULL) {\n                    printWhitespaces(startLen - branchLen);\n                    char valStr[256];\n                    sprintf(valStr, "%d", levelNodes[i]->data);\n\n                    fillWithSpacesIfNull(i * 2 - 1, nodesInThisLevel, levelNodes);\n                    printNodeValue(branchLen + 2, valStr, nodeSpaceLen);\n                } else {\n                    fillWithSpacesIfNull(i * 2 - 1, nodesInThisLevel,\n                                            levelNodes);\n                    printWhitespaces(branchLen + 2);\n                    fillWithSpacesIfNull(i * 2, nodesInThisLevel, levelNodes);\n                }\n            }\n\n            printf("\n");\n            startLen = startLen / 2 - branchLen;\n        }\n\n    }\n}\n\nint main() {\n    Node* root = newNode(2);\n    root->right = newNode(3);\n    root->right->right = newNode(4);\n    root->right->right->right = newNode(5);\n    root->right->right->right->right = newNode(8);\n\n    prettyPrintTree(root);\n    return 0;\n}