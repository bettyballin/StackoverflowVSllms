#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\n#define FILE_COUNT 10\n\nvoid child_process(int fd, int index) {\n    // Simulate work by sleeping\n    sleep(2);\n    // Send progress information to parent\n    char message[10];\n    snprintf(message, sizeof(message), "%d done", index);\n    write(fd, message, strlen(message));\n}\n\nint main() {\n    int pipefds[FILE_COUNT][2]; // Two file descriptors for each child\n\n    for (int i = 0; i < FILE_COUNT; i++) {\n        if (pipe(pipefds[i]) == -1) {   // Create a pipe\n            perror("Pipe creation failed");\n            exit(EXIT_FAILURE);\n        }\n        pid_t pid = fork();\n        if (pid == 0) {                  // Child process\n            close(pipefds[i][0]);        // Close read end of the pipe\n            child_process(pipefds[i][1], i + 1); // Simulate work and send progress message\n            exit(EXIT_SUCCESS);\n        } else if (pid < 0) {\n            perror("Fork failed");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    char buffer[10];\n    for (int i = 0; i < FILE_COUNT; i++) {\n        close(pipefds[i][1]);   // Close write end of the pipe in parent\n        int bytes_read = read(pipefds[i][0], buffer, sizeof(buffer) - 1);\n        if (bytes_read > 0) {\n            buffer[bytes_read] = '\0';\n            printf("%s\n", buffer);\n        }\n    }\n\n    for (int i = 0; i < FILE_COUNT; i++) {\n        close(pipefds[i][0]);   // Close remaining read ends\n        wait(NULL);             // Wait for all children to end\n    }\n\n    return 0;\n}