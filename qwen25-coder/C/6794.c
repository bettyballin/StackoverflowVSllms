#include <windows.h>\n#include <stdio.h>\n\nint main() {\n    SECURITY_ATTRIBUTES sa;\n    HANDLE hReadPipe, hWritePipe;\n    PROCESS_INFORMATION piProcInfo;\n    STARTUPINFO siStartInfo;\n\n    // Set up security attributes.\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;   // Handle is inheritable\n    sa.lpSecurityDescriptor = NULL;\n\n    // Create the pipe to capture output from child process\n    if (!CreatePipe(&hReadPipe, &hWritePipe, &sa, 0)) {\n        fprintf(stderr, "Failed to create pipe.\n");\n        return EXIT_FAILURE;\n    }\n\n    // Configure pipes for redirection.\n    if (!SetHandleInformation(hReadPipe, HANDLE_FLAG_INHERIT, 0)) { // Don't inherit from parent\n        CloseHandle(hWritePipe);\n        CloseHandle(hReadPipe);\n        fprintf(stderr, "Failed to set handle information.\n");\n        return EXIT_FAILURE;\n    }\n\n    siStartInfo.cb = sizeof(siStartInfo);\n    ZeroMemory(&siStartInfo, sizeof(siStartInfo));\n    siStartInfo.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;\n    siStartInfo.hStdOutput = hWritePipe; // Redirect stdout\n    siStartInfo.wShowWindow = SW_HIDE;\n\n    // Execute the child process (in this case, assume we're running "child_program.exe")\n    if (!CreateProcess(\n            NULL,\n            (LPSTR)"child_program.exe",  // Command line.\n            &sa,                         // Process handle not inheritable.\n            &sa,                         // Thread handle not inheritable.\n            TRUE,                        // Set handle inheritance to TRUE\n            0,                           // No creation flags\n            NULL,                        // Use parent's environment block\n            NULL,                        // Use parent's starting directory \n            &siStartInfo,                // Pointer to STARTUPINFO structure\n            &piProcInfo))               // Pointer to PROCESS_INFORMATION structure\n    {\n        fprintf(stderr, "Failed to create process.\n");\n        CloseHandle(hWritePipe);\n        CloseHandle(hReadPipe);\n        return EXIT_FAILURE;\n    }\n\n    // Parent closes the write end of pipe to ensure that ReadFile will get an EOF.\n    CloseHandle(hWritePipe);\n\n    // Read output from child process\n    DWORD dwRead, dwTotal = 0;\n    CHAR chBuf[128];\n    while (TRUE) {\n        if (!ReadFile(hReadPipe, chBuf, sizeof(chBuf)-1, &dwRead, NULL)) break;\n\n        if (dwRead == 0) break; // End of file\n\n        chBuf[dwRead] = '\0';           // Append null character\n        dwTotal += dwRead;\n        printf("%s", chBuf);            // Print output from child process\n    }\n\n    CloseHandle(hReadPipe);\n    WaitForSingleObject(piProcInfo.hProcess, INFINITE); // Wait until child process exits.\n    CloseHandle(piProcInfo.hProcess);\n    CloseHandle(piProcInfo.hThread);\n\n    return EXIT_SUCCESS;\n}