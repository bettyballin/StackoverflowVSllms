#include <stdint.h>\n#include <limits.h>\n\n// GCC and Clang have built-in functions for saturating arithmetic\n#ifdef __GNUC__\n#define sat_add16(a, b)   (__builtin_add_overflow((a), (b), (uint16_t*)&(b)) ? UINT16_MAX : b)\n#define sat_add32(a, b)   (__builtin_add_overflow((a), (b), (uint32_t*)&(b)) ? UINT32_MAX : b)\n#else\n// Fallback implementation for Visual Studio or other compilers\nuint16_t sat_add16(uint16_t a, uint16_t b) {\n    uint16_t result;\n    if (__builtin_add_overflow(a, b, &result))\n        return UINT16_MAX;\n    return result;\n}\n\nuint32_t sat_add32(uint32_t a, uint32_t b) {\n    uint32_t result;\n    if (__builtin_add_overflow(a, b, &result))\n        return UINT32_MAX;\n    return result;\n}\n#endif\n\n// Example usage\nint main() {\n    uint16_t x = 0xF000, y = 0x1000; // Should saturate to 0xFFFF\n    uint32_t a = 0xF0000000, b = 0x10000000; // Should saturate to 0xFFFFFFFF\n\n    printf("Saturated sum (uint16_t): %X\n", sat_add16(x, y));\n    printf("Saturated sum (uint32_t): %X\n", sat_add32(a, b));\n\n    return 0;\n}