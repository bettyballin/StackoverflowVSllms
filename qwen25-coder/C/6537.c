#include <openssl/conf.h>\n#include <openssl/evp.h>\n#include <openssl/pem.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n#include <stdio.h>\n\nint create_x509_selfsigned(X509** x509, EVP_PKEY** pkey) {\n    const char* issuer = "O=MyOrganisation,L=Locality,C=US";\n    const BIGNUM* one = BN_value_one();\n    int days_valid = 365;\n\n    // Generate a RSA keypair\n    *pkey = EVP_PKEY_new();\n    if (!(*pkey)) {\n        fprintf(stderr, "Unable to create EVP_PKEY\n");\n        return 0;\n    }\n    \n    RSA* rsa_keypair = RSA_new();\n    BIGNUM* bne = BN_new();\n    int ret1 = BN_set_word(bne, RSA_F4);\n    if (ret1 != 1) {\n        fprintf(stderr, "Unable to set word to BNE\n");\n        return 0;\n    }\n    \n    ret1 = RSA_generate_key_ex(rsa_keypair, 2048, bne, NULL);\n    if (ret1 != 1) {\n        fprintf(stderr, "Unable to generate RSA key\n");\n        return 0;\n    }\n\n    // Set the generated RSA keys into a PKEY structure\n    if (!EVP_PKEY_assign_RSA(*pkey, rsa_keypair)) {\n        fprintf(stderr, "Unable to assign RSA keys to EVP_PKEY\n");\n        return 0;\n    }\n    \n    // Create a self-signed certificiate\n    *x509 = X509_new();\n    if (!(*x509)) {\n        fprintf(stderr, "Unable to create X509 struct\n");\n        return 0;\n    }\n\n    // Set version of certificate\n    X509_set_version(*x509, 2); \n\n    // Randomize a serial number\n    ASN1_INTEGER* asrl = ASN1_INTEGER_new();\n    if (!asrl || !BN_rand(asrl->data, 64, BN_RAND_TOP_ANY, BN_RAND_BOTTOM_ANY)) {\n        fprintf(stderr, "Unable to create random serial\n");\n        return 0;\n    }\n    X509_set_serialNumber(*x509, asrl);\n\n    // Set the issuer name\n    X509_NAME* name = X509_get_subject_name(*x509);\n    if (!X509_NAME_add_entry_by_txt(name, "O", MBSTRING_ASC,\n                                     (const unsigned char*) issuer , -1, -1, 0)\n        || !X509_set_issuer_name(*x509,name)) {\n        fprintf(stderr, "Unable to create subject cert\n");\n        return 0;\n    }\n\n    // Validity Not Before\n    if(!X509_gmtime_adj(X509_get_notBefore(*x509),0)){\n        fprintf(stderr, "Failed setting validity of certificate Not Before.\n");\n        return 0; \n    }\n    // Validity Not After\n    if(!X509_gmtime_adj(X509_get_notAfter(*x509),(long)60*60*24*days_valid)){\n        fprintf(stderr, "Failed setting validity of certificate Not After.\n");\n        return 0; \n    }\n\n    // Set the public key from our keypair into our certificate\n    if(!X509_set_pubkey(*x509,*pkey)) {\n        fprintf(stderr, "Error setting public key\n");\n        return 0;\n    }\n\n\n    // Add various extensions: standard extenstions\n    X509V3_CTX ctx;\n    X509V3_SET_CTX(&ctx, *x509, *x509, NULL, NULL, 0);\n    if(!X509_add_ext(*x509,\n                      X509V3_EXT_conf_nid(NULL, &ctx, NID_subject_key_identifier,\n                                            "hash"), -1)) {\n        fprintf(stderr, "Error adding subject key identifier extension\n");\n        return 0;\n\n    }\n    if(!X509_add_ext(*x509,\n                      X509V3_EXT_conf_nid(NULL, &ctx, NID_authority_key_identifier,\n                                            "keyid:always"), -1)) {\n        fprintf(stderr, "Error adding authority key identifier extension\n");\n        return 0;\n\n    }\n    if(!X509_add_ext(*x509,\n                      X509V3_EXT_conf_nid(NULL, &ctx, NID_basic_constraints,"critical, CA:FALSE"), -1)) {\n        fprintf(stderr, "Error adding basic constraints extension\n");\n        return 0;\n    }\n\n    // Self-sign the certificate\n    if(!X509_sign(*x509,*pkey,EVP_sha256())) {\n        fprintf(stderr, "Error signing cert\n");\n        return 0;\n    }\n\n    // Cleanup and free memory\n    BN_free(bne);\n    ASN1_INTEGER_free(asrl);\n\n    return 1;\n}\n\nvoid cleanup(X509* x509, EVP_PKEY *pkey) {\n    X509_free(x509);\n    if (pkey != NULL)\n        EVP_PKEY_free(pkey);\n}\n\n\nint main(int argc, char** argv) {\n    OpenSSL_add_all_algorithms();\n    ERR_load_crypto_strings();\n\n    X509* x509_cert = NULL;\n    EVP_PKEY* pkey = NULL;\n\n    if(!create_x509_selfsigned(&x509_cert, &pkey)) {\n        fprintf(stderr,"Error creating x509 cert\n");\n        return 1; \n    }\n\n    FILE *f = fopen("selfsigned_cert.pem", "w+");\n    FILE *fp = fopen("private_key.pem", "w");\n\n    PEM_write_X509(f, x509_cert);\n    fclose(f);\n\n    PEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, NULL, NULL );\n    fclose(fp);\n\n    cleanup(x509_cert, pkey);\n    CRYPTO_cleanup_all_ex_data();\n    ERR_free_strings();\n\n    return 0;\n}