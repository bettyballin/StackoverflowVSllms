#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\nvoid init_openssl();\nvoid cleanup_openssl();\nSSL_CTX* create_context();\nvoid configure_context(SSL_CTX *ctx);\n\nint main(int argc, char **argv)\n{\n    int sock;\n    struct sockaddr_in addr;\n\n    init_openssl();\n    SSL_CTX *ctx = create_context();\n\n    configure_context(ctx);\n\n    /* Set up the TCP socket */\n    listen_sock(sock);\n    bind_address(&addr, inet_addr("127.0.0.1"), 8989);\n    if (listen(sock, 5) < 0) {\n        perror("Unable to listen");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Accept connections and handle them one by one */\n    while(1) {\n        struct sockaddr_in addr;\n        uint len = sizeof(addr);\n        SSL *ssl;\n        const char reply[] = "test\n";\n\n        int client = accept(sock, (struct sockaddr*)&addr, &len);\n\n        ssl = SSL_new(ctx);\n        SSL_set_fd(ssl, client);\n\n        if (SSL_accept(ssl) <= 0) {\n            ERR_print_errors_fp(stderr);\n        }\n        else {\n            /* Get the name of the cipher used in the connection */\n            const char *cipher = SSL_get_cipher(ssl);\n            printf("Cipher: %s\n", cipher);\n\n            /* Receive and send data here... */\n\n            SSL_shutdown(ssl);\n            close(client);\n        }\n\n        SSL_free(ssl);\n    }\n}\n\nvoid init_openssl()\n{\n    // Load the human-readable error strings for libcrypto & libssl\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n    ERR_load_ERR_strings();\n    ERR_load_crypto_strings();\n\n    // Initialize the OpenSSl library\n    if(SSL_library_init() < 0)\n        abort();\n}\n\nvoid cleanup_openssl()\n{\n    /* Clean up */\n    EVP_cleanup();\n}\n\nSSL_CTX* create_context()\n{\n    const SSL_METHOD *method;\n    SSL_CTX *ctx;\n\n    method = TLS_server_method();\n\n    ctx = SSL_CTX_new(method);\n    if (!ctx) {\n        perror("Unable to create SSL context");\n        ERR_print_errors_fp(stderr);\n        exit(EXIT_FAILURE);\n    }\n\n    return ctx;\n}\n\nvoid configure_context(SSL_CTX *ctx)\n{\n    /* Set the key and cert */\n    if (SSL_CTX_use_certificate_file(ctx, "cert.pem", SSL_FILETYPE_PEM) <= 0) {\n        ERR_print_errors_fp(stderr);\n        exit(EXIT_FAILURE);\n    }\n\n    if (SSL_CTX_use_PrivateKey_file(ctx, "key.pem", SSL_FILETYPE_PEM) <= 0 ) {\n        ERR_print_errors_fp(stderr);\n        exit(EXIT_FAILURE);\n    }\n}\n\nint listen_sock(int *sock)\n{\n    struct sockaddr_in addr;\n\n    *sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*sock < 0) {\n        perror("Unable to create socket");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = INADDR_ANY;\n    addr.sin_port = htons(8989);\n\n    if (bind(*sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {\n        perror("Unable to bind");\n        exit(EXIT_FAILURE);\n    }\n\n    return *sock;\n}\n\nvoid bind_address(struct sockaddr_in* addr, unsigned long int address, int port)\n{\n    memset(addr, 0, sizeof(*addr));\n    addr->sin_family = AF_INET;\n    addr->sin_addr.s_addr = htonl(address);\n    addr->sin_port = htons(port);\n}