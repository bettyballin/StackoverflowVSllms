#include <zlib.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define CHECK_ERR(err, msg) { \\n    if (err != Z_OK) { \\n        fprintf(stderr, "%s error: %d\n", msg, err); \\n        exit(1); \\n    } \\n}\n\nvoid concat_gzip_files(const char* input_files[], int num_files, const char* output_file) {\n    unsigned long total_size = 0;\n    uLong crc = crc32(0L, Z_NULL, 0);\n    \n    // Temporarily store the concatenated deflate data\n    Bytef *deflate_data;\n    size_t deflate_data_capacity = 1024; // Start with a reasonable size\n    deflate_data = (Bytef*)malloc(deflate_data_capacity);\n    CHECK_ERR(deflate_data == NULL ? Z_MEM_ERROR : Z_OK, "deflate_data allocation");\n    \n    for(int i = 0; i < num_files; i++) {\n        gzFile in_gz = gzopen(input_files[i], "rb");\n        CHECK_ERR(in_gz == NULL, "gzopen input file");\n\n        // Skip GZip header (10 bytes)\n        char buffer[10];\n        gzread(in_gz, buffer, sizeof(buffer));\n\n        Bytef byte;\n        while(gzread(in_gz, &byte, 1) != 0) {\n            // Check if we run out of space and need to re-allocate\n            if(total_size >= deflate_data_capacity) {\n                deflate_data_capacity *= 2;\n                deflate_data = (Bytef*)realloc(deflate_data, deflate_data_capacity);\n                CHECK_ERR(deflate_data == NULL ? Z_MEM_ERROR : Z_OK, "deflate_data reallocation");\n            }\n\n            deflate_data[total_size++] = byte;\n            crc = crc32(crc, &byte, 1); // Update CRC with the new byte\n        }\n        \n        gzclose(in_gz);\n    }\n\n    // Open output GZip file\n    FILE *out_file = fopen(output_file, "wb");\n    CHECK_ERR(out_file == NULL, "fopen output file");\n\n    // Write GZip header (minimal version)\n    {\n        Bytef gzip_header[10] = { 0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xff };\n        fwrite(gzip_header, 1, sizeof(gzip_header), out_file);\n    }\n\n    fwrite(deflate_data, 1, total_size, out_file);\n\n    // Write GZip trailer\n    {\n        uLong length = htonl(total_size); // Size of uncompressed data as little-endian\n        uLong checksum = htonl(crc);     // CRC32 checksum as little-endian\n\n        fwrite(&checksum, 1, sizeof(checksum), out_file);\n        fwrite(&length, 1, sizeof(length), out_file);\n    }\n    \n    fclose(out_file);\n    free(deflate_data);\n}\n\nint main(int argc, char* argv[]) {\n    if(argc < 4) {\n        fprintf(stderr, "Usage: %s output.gz input1.gz [input2.gz ...]\n", argv[0]);\n        return 1;\n    }\n\n    concat_gzip_files((const char**)&argv[2], argc-3, argv[1]);\n\n    return 0;\n}