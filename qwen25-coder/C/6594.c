#include <windows.h>\n#include <stdio.h>\n\nint main() {\n    SECURITY_ATTRIBUTES sa;\n    HANDLE hPipeRead, hPipeWrite;\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    char buffer[1024];\n    DWORD bytesRead;\n\n    // Setup security attributes for the pipe.\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;  // Pipe handles are inheritable\n    sa.lpSecurityDescriptor = NULL;\n\n    // Create a pipe to get the child process' output \n    if (!CreatePipe(&hPipeRead, &hPipeWrite, &sa, 0)) {\n        fprintf(stderr, "CreatePipe Failed\n");\n        return -1;\n    }\n\n    // Ensure the read handle of the pipe is not inherited\n    SetHandleInformation(hPipeRead, HANDLE_FLAG_INHERIT, 0);\n\n    // Prepare STARTUPINFO structure\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags |= STARTF_USESTDHANDLES;\n    si.hStdInput = NULL;\n    si.hStdOutput = hPipeWrite;\n    si.hStdError = hPipeWrite;\n\n    // Launch the process\n    if (!CreateProcess(NULL,   // No module name (use command line)\n                       "your_command_here",  // Command line\n                       NULL,           // Process handle not inheritable\n                       NULL,           // Thread handle not inheritable\n                       TRUE,          // Set handle inheritance to TRUE\n                       0,              // No creation flags \n                       NULL,           // Use parent's environment block\n                       NULL,           // Use parent's starting directory \n                       &si,            // Pointer to STARTUPINFO structure\n                       &pi)) {         // Pointer to PROCESS_INFORMATION structure\n\n        fprintf(stderr, "CreateProcess failed (%d).\n", GetLastError());\n        return -1;\n    }\n\n    // Close the write end of the pipe so that reading can be done from the \n    // other end.\n    CloseHandle(hPipeWrite);\n\n    // Read output from the child process's pipe for STDOUT\n    while (ReadFile(hPipeRead, buffer, sizeof(buffer)-1, &bytesRead, NULL) != 0 && bytesRead > 0) {\n        buffer[bytesRead] = '\0';  // Ensure string is null-terminated\n        printf("%s", buffer);      // Print the data read from the pipe\n    }\n\n    // Close process and thread handles\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    // Close handle to the pipe for reading\n    CloseHandle(hPipeRead);\n\n    return 0;\n}