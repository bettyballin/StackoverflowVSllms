#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <curl/curl.h>\n\nsize_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp) {\n    size_t realsize = size * nmemb;\n    struct MemoryStruct *mem = (struct MemoryStruct *)userp;\n\n    char *ptr = realloc(mem->memory, mem->size + realsize + 1);\n    if(ptr == NULL) {\n        /* out of memory! */\n        printf("not enough memory (realloc returned NULL)\n");\n        return 0;\n    }\n\n    mem->memory = ptr;\n    memcpy(&(mem->memory[mem->size]), contents, realsize);\n    mem->size += realsize;\n    mem->memory[mem->size] = 0;\n\n    return realsize;\n}\n\nint main(void) {\n    CURL *curl_handle;\n    CURLcode res;\n\n    struct MemoryStruct chunk;\n\n    chunk.memory = malloc(1);  /* will be grown as needed by the realloc above */\n    chunk.size = 0;    /* no data at this point */\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n\n    /* init the curl session */\n    curl_handle = curl_easy_init();\n\n    /* specify URL to get */\n    curl_easy_setopt(curl_handle, CURLOPT_URL, "http://example.com");\n\n    /* send all data to this function  */\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteCallback);\n\n    /* we pass our 'chunk' struct to the callback function */\n    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);\n\n    res = curl_easy_perform(curl_handle);\n\n    /* check for errors */\n    if(res != CURLE_OK) {\n        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));\n    } else {\n        printf("%s\n", chunk.memory);\n    }\n\n    /* cleanup curl stuff */\n    curl_easy_cleanup(curl_handle);\n\n    free(chunk.memory);\n\n    curl_global_cleanup();\n\n    return 0;\n}\n\nstruct MemoryStruct {\n    char *memory;\n    size_t size;\n};