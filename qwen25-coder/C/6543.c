#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <errno.h>\n#include <fcntl.h>\n\nint pipefd[2]; // pipe to communicate between signal handler and main loop\n\nvoid sigchld_handler(int signo) {\n    if (write(pipefd[1], "x", 1) != 1) { // write dummy byte\n        perror("pipe write failed");\n        exit(EXIT_FAILURE);\n    }\n}\n\n// Function to handle child exits\nvoid handle_exited_children() {\n    char buf;\n    while (read(pipefd[0], &buf, 1) == 1) {\n        int status;\n        pid_t pid;\n        while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n            printf("parent caught SIGCHLD from %d\n", (int)pid);\n            // Remove pid from children list if necessary\n            // children.remove(pid); // Implement your function to remove pid\n        }\n    }\n}\n\nint main() {\n    if (pipe(pipefd) == -1) { // create pipe\n        perror("pipe");\n        exit(EXIT_FAILURE);\n    }\n\n    // Make the read end non-blocking\n    int flags = fcntl(pipefd[0], F_GETFL, 0);\n    if (flags == -1 || fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK) == -1) {\n        perror("fcntl");\n        exit(EXIT_FAILURE);\n    }\n\n    // Set up the signal handler\n    struct sigaction sa;\n    sa.sa_handler = sigchld_handler;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART; // restart functions like read\n    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n        perror("sigaction");\n        exit(EXIT_FAILURE);\n    }\n\n    for (;;) {\n        if (is_time_to_make_babies()) {\n\n            pid_t pid = fork();\n            if (pid == -1) {\n                perror("fork");\n                exit(EXIT_FAILURE);\n            } else if (pid == 0) {\n                // child stuff\n                printf("child started\n");\n                exit(EXIT_SUCCESS);\n            } else {\n                // parent stuff\n                printf("parent forked new child %d\n", (int)pid);\n                children.add(pid); // Add your function to add pid\n            }\n\n        }\n        handle_exited_children(); // Handle any exited children\n\n        // Main loop logic here...\n    }\n\n    close(pipefd[0]);\n    close(pipefd[1]);\n    return 0;\n}