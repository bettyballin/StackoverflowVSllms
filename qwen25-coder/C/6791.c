#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/inotify.h>\n\n#define EVENT_SIZE  ( sizeof (struct inotify_event) )\n#define BUF_LEN     ( 1024 * ( EVENT_SIZE + 16 ) )\n\nvoid watch_file(const char* path) {\n    int fd = inotify_init();\n    if (fd == -1) {\n        perror("inotify_init");\n        exit(EXIT_FAILURE);\n    }\n\n    int wd = inotify_add_watch(fd, path, IN_MODIFY);\n    if (wd == -1) {\n        perror("inotify_add_watch");\n        close(fd);\n        exit(EXIT_FAILURE);\n    }\n\n    char buffer[BUF_LEN];\n    int length = read(fd, buffer, BUF_LEN);\n    if (length < 0) {\n        perror("read");\n        close(fd);\n        inotify_rm_watch(fd, wd);\n        exit(EXIT_FAILURE);\n    }\n\n    while (1) {\n        int i = 0;\n        while (i < length) {\n            struct inotify_event* event = (struct inotify_event*)&buffer[i];\n            if (event->mask & IN_MODIFY && !(event->mask & IN_ISDIR)) {\n                printf("%s was modified.\n", path);\n                // Here you can trigger your file parsing and GUI update\n            }\n            i += EVENT_SIZE + event->len;\n        }\n\n        length = read(fd, buffer, BUF_LEN);\n        if (length == -1) {\n            perror("read");\n            break;\n        }\n    }\n\n    inotify_rm_watch(fd, wd);\n    close(fd);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, "Usage: %s <path-to-file>\n", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    watch_file(argv[1]);\n    return 0;\n}