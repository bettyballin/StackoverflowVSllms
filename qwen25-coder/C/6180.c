#include <stdint.h>\n#include <stdbool.h>\n\n#define UART_BUFFER_SIZE 128\n#define SPI_PAGE_SIZE 256\n\nvolatile uint8_t uartBuffer[UART_BUFFER_SIZE];\nvolatile uint8_t uartReadIndex = 0;\nvolatile uint8_t uartWriteIndex = 0;\n\nuint8_t spiPageBuffer[SPI_PAGE_SIZE];\nuint8_t pageBytesReceived = 0;\nbool writeInProgress = false;\n\nvoid UART_RX_IRQHandler(void) {\n    // Read incoming byte\n    uint8_t byte = UART_READ_BYTE(); // Assume this function reads a byte from the UART buffer\n    uint8_t nextIndex = (uartWriteIndex + 1) % UART_BUFFER_SIZE;\n    \n    if (nextIndex != uartReadIndex) { // Prevent overwrite\n        uartBuffer[uartWriteIndex] = byte;\n        uartWriteIndex = nextIndex;\n    }\n}\n\nvoid SPI_TX_IRQHandler(void) {\n    if (writeInProgress) {\n        // Check for TX buffer empty and send from spiPageBuffer\n        while (!SPI_IS_TX_BUFFER_EMPTY()) ; // Wait until the tx buffer is empty\n        SPI_TRANSFER(spiPageBuffer[pageBytesReceived++]);\n        \n        if (pageBytesReceived == SPI_PAGE_SIZE) {\n            writeInProgress = false;\n            // Trigger flash page write completion check\n        }\n    }\n}\n\nvoid dataHandler(void) {\n    while (uartReadIndex != uartWriteIndex) { // UART to Page Buffer Transfer\n        spiPageBuffer[pageBytesReceived] = uartBuffer[uartReadIndex];\n        uartReadIndex = (uartReadIndex + 1) % UART_BUFFER_SIZE;\n        \n        if (++pageBytesReceived == SPI_PAGE_SIZE && !writeInProgress) {\n            startWriteProcess(); // Function that initiates writing to the flash\n            pageBytesReceived = 0;\n        }\n    }\n}\n\nvoid startWriteProcess(void) {\n    writeInProgress = true;\n    // Trigger initial byte transfer interrupt or DMA if available\n}