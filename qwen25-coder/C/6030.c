#include <winsock2.h>\n#include <iphlpapi.h>\n#include <stdio.h>\n\n#pragma comment(lib, "ws2_32.lib")\n#pragma comment(lib, "Iphlpapi.lib")\n\n#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))\n#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))\n\nvoid PrintTcpTable(PMIB_TCPTABLE_OWNER_PID pTcpTable, DWORD dwSize)\n{\n    for (DWORD row = 0; row < pTcpTable->dwNumEntries; row++)\n    {\n        PMIB_TCPROW_OWNER_PID pRow = &pTcpTable->table[row];\n        printf("Local Address: %s:%d, Remote Address: %s:%d, State: %ld, PID: %lu\n",\n               inet_ntoa(*(struct in_addr*)&(pRow->dwLocalAddr)),\n               ntohs(pRow->dwLocalPort),\n               inet_ntoa(*(struct in_addr*)&(pRow->dwRemoteAddr)),\n               ntohs(pRow->dwRemotePort),\n               pRow->dwState,\n               pRow->dwOwningPid);\n    }\n}\n\nvoid PrintUdpTable(PMIB_UDPTABLE_OWNER_PID pUdpTable, DWORD dwSize)\n{\n    for (DWORD row = 0; row < pUdpTable->dwNumEntries; row++)\n    {\n        PMIB_UDPROW_OWNER_PID pRow = &pUdpTable->table[row];\n        printf("Local Address: %s:%d, PID: %lu\n",\n               inet_ntoa(*(struct in_addr*)&(pRow->dwLocalAddr)),\n               ntohs(pRow->dwLocalPort),\n               pRow->dwOwningPid);\n    }\n}\n\nint main()\n{\n    DWORD bufferSize = 0;\n    DWORD status = NO_ERROR;\n\n    // TCP Table\n    status = GetExtendedTcpTable(NULL, &bufferSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);\n\n    if (status == ERROR_INSUFFICIENT_BUFFER)\n    {\n        PMIB_TCPTABLE_OWNER_PID pTcpTable = (PMIB_TCPTABLE_OWNER_PID)MALLOC(bufferSize);\n        if (pTcpTable == NULL)\n        {\n            printf("Memory allocation failed for TCP table.\n");\n            return 1;\n        }\n\n        status = GetExtendedTcpTable(pTcpTable, &bufferSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);\n\n        if (status == NO_ERROR)\n        {\n            PrintTcpTable(pTcpTable, bufferSize);\n        }\n        else\n        {\n            printf("GetExtendedTcpTable failed with error: %ld\n", status);\n        }\n\n        FREE(pTcpTable);\n    }\n    \n    // UDP Table\n    status = GetExtendedUdpTable(NULL, &bufferSize, TRUE, AF_INET, UDP_TABLE_OWNER_PID, 0);\n\n    if (status == ERROR_INSUFFICIENT_BUFFER)\n    {\n        PMIB_UDPTABLE_OWNER_PID pUdpTable = (PMIB_UDPTABLE_OWNER_PID)MALLOC(bufferSize);\n        if (pUdpTable == NULL)\n        {\n            printf("Memory allocation failed for UDP table.\n");\n            return 1;\n        }\n\n        status = GetExtendedUdpTable(pUdpTable, &bufferSize, TRUE, AF_INET, UDP_TABLE_OWNER_PID, 0);\n\n        if (status == NO_ERROR)\n        {\n            PrintUdpTable(pUdpTable, bufferSize);\n        }\n        else\n        {\n            printf("GetExtendedUdpTable failed with error: %ld\n", status);\n        }\n\n        FREE(pUdpTable);\n    }\n\n    return 0;\n}