#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\npid_t *children;\nint num_children = 0;\n\nvoid cleanup() {\n    for (int i = 0; i < num_children; ++i) {\n        kill(children[i], SIGTERM);\n    }\n    free(children);\n}\n\nvoid handle_sigterm(int sig) {\n    printf("Terminating program due to signal %d\n", sig);\n    cleanup();\n    exit(EXIT_FAILURE);\n}\n\nint main() {\n    int n = 3; // Number of child processes\n    children = malloc(n * sizeof(pid_t));\n\n    for (int i = 0; i < n; ++i) {\n        pid_t pid = fork();\n        if (pid == -1) {\n            perror("fork");\n            cleanup();\n            exit(EXIT_FAILURE);\n        } else if (pid == 0) {\n            // Child process\n            printf("Child %d running\n", getpid());\n            sleep(10); // Simulate work\n            return 0;\n        } else {\n            children[num_children++] = pid;\n        }\n    }\n\n    // Set up signal handler for SIGTERM and other signals if needed\n    struct sigaction act;\n    act.sa_handler = handle_sigterm;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n\n    if (sigaction(SIGTERM, &act, NULL) == -1 || \n        sigaction(SIGHUP, &act, NULL) == -1 ||\n        sigaction(SIGINT, &act, NULL) == -1) {\n        perror("sigaction");\n        cleanup();\n        exit(EXIT_FAILURE);\n    }\n\n    // Parent process waits for children\n    int status;\n    while (wait(&status) > 0);\n\n    cleanup();\n    return 0;\n}