#include <openssl/ssl.h>\n#include <openssl/err.h>\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nSSL_CTX *init_server_ctx() {\n    const SSL_METHOD *method;\n    SSL_CTX *ctx;\n\n    method = TLS_server_method();\n    if ((ctx = SSL_CTX_new(method)) == NULL)\n        ERR_print_errors_fp(stderr);\n    return ctx;\n}\n\nvoid cleanup(SSL_CTX *ctx) {\n    SSL_CTX_free(ctx);\n    EVP_cleanup();\n}\n\nint main() {\n    int serverfd;\n    struct sockaddr_in servaddr, cliaddr;\n\n    // Initialize the OpenSSL library\n    SSL_library_init();\n    SSL_load_error_strings();\n\n    if ((serverfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n        perror("socket failed");\n        return 1;\n    }\n\n    bzero(&servaddr, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n    servaddr.sin_port = htons(4321); // Port\n\n    bind(serverfd, (const struct sockaddr*)&servaddr, sizeof(servaddr));\n\n    listen(serverfd, 5);\n\n    SSL_CTX *ctx = init_server_ctx();\n    if (!SSL_CTX_use_certificate_file(ctx, "cert.pem", SSL_FILETYPE_PEM)\n            || !SSL_CTX_use_PrivateKey_file(ctx, "key.pem", SSL_FILETYPE_PEM)) {\n        ERR_print_errors_fp(stderr);\n        return -1;\n    }\n\n    int client_len = sizeof(cliaddr);\n    while (true) {\n        int clientfd = accept(serverfd, (struct sockaddr*)&cliaddr, (socklen_t*)&client_len);\n\n        SSL *ssl = SSL_new(ctx);\n        SSL_set_fd(ssl, clientfd);\n\n        if (SSL_accept(ssl) <= 0) {\n            ERR_print_errors_fp(stderr);\n            continue;\n        }\n\n        // Handle client using ssl\n        int bytes;\n        char buf[1024];\n        while ((bytes = SSL_read(ssl, buf, sizeof(buf))) > 0)\n            write(clientfd, buf, bytes);\n\n        SSL_free(ssl);\n        close(clientfd);\n    }\n\n    cleanup(ctx);\n    shutdown(serverfd, SHUT_RDWR);  // All further send and recv operations are disabled\n    close(serverfd);\n    return 0;\n}