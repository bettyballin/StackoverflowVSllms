#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <wait.h>\n#include <readline/readline.h>\n#include <string.h>\n\n#define NUMPIPES 1 // For two commands\n\nint main(int argc, char *argv[]) {\n    char *bBuffer, *sPtr, *aPtr = NULL;\n    char *pipeComms[NUMPIPES + 1];\n    int fdPipe[2], pCount, aCount, i, status;\n    pid_t pid;\n\n    while(1) {\n        bBuffer = readline("Shell> ");\n\n        if(!strcasecmp(bBuffer, "exit")) {\n            free(bBuffer);\n            return 0;\n        }\n\n        sPtr = bBuffer;\n        pCount = -1;\n\n        do {\n            aPtr = strsep(&sPtr, "|");\n            pipeComms[++pCount] = strdup(aPtr); // Duplicate the string to avoid issues with readline's buffer\n        } while(aPtr);\n\n        if(pipe(fdPipe) == -1) {\n            perror("pipe");\n            exit(1);\n        }\n\n        for(i = 0; i < pCount; i++) {\n            aCount = 0;\n\n            cmdArgs[aCount] = strtok(pipeComms[i], " ");\n            while ((cmdArgs[++aCount] = strtok(NULL, " ")));\n\n            pid = fork();\n\n            if(pid == -1) {\n                perror("fork");\n                exit(1);\n            } else if(pid == 0) { // Child process\n                if(i == 0) { // First command\n                    dup2(fdPipe[1], STDOUT_FILENO);\n                } else if (i == pCount-1) { // Last command\n                    dup2(fdPipe[0], STDIN_FILENO);\n                }\n\n                close(fdPipe[0]);\n                close(fdPipe[1]);\n\n                execvp(cmdArgs[0], cmdArgs);\n                perror("execvp");\n                exit(1);\n            }\n        }\n\n        // Parent process closes its copies of pipes and waits for children to complete\n        close(fdPipe[0]);\n        close(fdPipe[1]);\n        \n        for(i = 0; i < pCount; i++) {\n            waitpid(-1, &status, 0);\n            if(WIFEXITED(status)) {\n                fprintf(stderr, "[%d] TERMINATED (Status: %d)\n", pid, WEXITSTATUS(status));\n            }\n        }\n\n        free(bBuffer); // Free the readline allocated buffer\n        for(i = 0; i <= pCount; i++) {\n            free(pipeComms[i]); // Free duplicated strings\n        }\n    }\n\n    return 0;\n}