#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n\n#pragma comment(lib, "iphlpapi.lib")\n#pragma comment(lib, "ws2_32.lib")\n\n// Function to calculate checksum (IPv4)\nunsigned short in_cksum(unsigned short *ptr, int nbytes) {\n    register long sum;\n    u_short oddbyte;\n    register u_short answer;\n\n    sum = 0;\n    while(nbytes > 1) {\n        sum += *ptr++;\n        nbytes -= 2;\n    }\n    if(nbytes == 1) {\n        oddbyte = 0;\n        *((u_char *)&oddbyte)=*(u_char*)ptr;\n        sum += oddbyte;\n    }\n\n    sum = (sum>>16)+(sum & 0xffff);\n    sum = sum + (sum>>16);\n    answer = ~sum;\n\n    return(answer);\n}\n\nint main() {\n    WSADATA wsaData;\n    SOCKET sock4_raw = INVALID_SOCKET;\n    int result, proto_type;\n\n    char sendbuf[40];\n    struct iphdr *ipH = (struct iphdr *)sendbuf; // IP header\n    struct tcphdr *tcpH = (struct tcphdr *)(sendbuf + sizeof(struct iphdr)); // TCP header\n\n    // Initialize Winsock\n    result = WSAStartup(MAKEWORD(2, 0), &wsaData);\n    if(result != 0) {\n        printf("WSAStartup failed with error: %d\n", result);\n        return 1;\n    }\n\n    sock4_raw = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);\n    if(sock4_raw == INVALID_SOCKET){\n        fprintf(stderr,"Error Creating Raw Socket: %ld\n", WSAGetLastError());\n        WSACleanup();\n        exit(1);\n    }\n\n    struct sockaddr_in server;\n    memset(&server, 0, sizeof(server));\n    server.sin_family = AF_INET;\n    inet_pton(AF_INET, "192.168.1.152", &server.sin_addr.s_addr); // dest IP\n\n    ipH->ip_hl = 5;         /* No options - header length = 5 * 4 bytes */\n    ipH->ip_v = 4;          /* Version is IPv4 */\n    ipH->ip_tos = 0;        /* Type of service */\n    ipH->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr);\n    ipH->id = htons(54321); /* ID sequence number (not important here) */\n    ipH->frag_off = 0;\n    ipH->ttl = 64;          /* Default TTL */\n    ipH->protocol = IPPROTO_TCP;  // TCP Protocol\n    ipH->check = in_cksum((unsigned short *)ipH, sizeof(struct iphdr));\n    inet_pton(AF_INET,"192.168.1.151", &ipH->saddr); // src IP\n    inet_pton(AF_INET,"192.168.1.152", &ipH->daddr); // dest IP\n\n    tcpH->source = htons(1234);\n    tcpH->dest = htons(80);\n    tcpH->seq = 0;\n    tcpH->ack_seq = 0;\n    tcpH->res1 = 0;\n    tcpH->doff = sizeof(struct tcphdr) / 4;  /* TCP header size in DWORDS */\n    tcpH->fin=0;\n    tcpH->syn=1;\n    tcpH->rst=0;\n    tcpH->psh=0;\n    tcpH->ack=0;\n    tcpH->urg=0;\n    tcpH->window = htons (5840); /* maximum allowed window size */\n    tcpH->check = 0; // Calculate checksum\n    tcpH->urg_ptr = 0;\n\n    // Calculate TCP checksum (requires pseudo-header and actual header with zeroed checksum field)\n    struct pseudoheader psh;\n    psh.saddr.src_addr = ipH->saddr;\n    psh.daddr.dst_addr = ipH->daddr;\n    psh.zero = 0;\n    psh.protocol = IPPROTO_TCP;\n    psh.tcp_length = htons(sizeof(struct tcphdr));\n\n    memcpy(&sendbuf[sizeof(struct iphdr)+sizeof(struct tcphdr)], "Hello", 5);\n    ipH->tot_len = sizeof(struct iphdr) + sizeof(struct tcphdr) + 5;\n\n    int phsize = sizeof(psh) + sizeof(struct tcphdr) + 5;\n    char pseu[phsize];\n    memcpy(pseu, &psh, sizeof(struct pseudoheader));\n    memcpy(pseu+sizeof(struct pseudoheader), tcpH, sizeof(struct tcphdr)+5);\n\n    tcpH->check = in_cksum((unsigned short *)pseu, phsize);\n\n    sendto(sock4_raw, sendbuf, ipH->tot_len, 0, (SOCKADDR *)&server, sizeof(server));\n\n    closesocket(sock4_raw);\n    WSACleanup();\n}\n\nstruct pseudoheader {\n    u_int32_t src_addr;\n    u_int32_t dst_addr;\n    u_char zero;\n    u_char protocol;\n    u_short tcp_length;\n};