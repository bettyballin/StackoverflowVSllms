#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <pthread.h>\n\n#define BUFFER_SIZE 1024\n\nFILE *memStream = NULL;\nint pipefd[2];\nvolatile sig_atomic_t running = 1;\n\nvoid* writer_thread(void* arg) {\n    char buffer[BUFFER_SIZE];\n    ssize_t bytesRead;\n    \n    while (running) {\n        bytesRead = read(pipefd[0], buffer, BUFFER_SIZE - 1);\n        if (bytesRead > 0) {\n            buffer[bytesRead] = '\0';\n            fprintf(stdout, "%s", buffer); // Write to stdout or a file\n        }\n        usleep(100000); // Sleep for 100ms before checking again\n    }\n    \n    return NULL;\n}\n\nvoid setup_buffering() {\n    pipe(pipefd);\n    memStream = fdopen(pipefd[1], "w");\n    setbuf(memStream, NULL); // Set unbuffered mode\n    \n    pthread_t thread_id;\n    pthread_create(&thread_id, NULL, writer_thread, NULL);\n    \n    dup2(fileno(memStream), 1); // Redirect stdout to the pipe\n}\n\nvoid cleanup() {\n    running = 0; // Signal the writer thread to stop\n    fclose(memStream);\n    close(pipefd[0]);\n    close(pipefd[1]);\n}\n\nint main() {\n    setup_buffering();\n    \n    printf("This should be buffered and written by a dedicated thread.\n");\n    // Simulate work with sleep or other processing\n    \n    cleanup(); // Ensure the writer thread finishes cleanly\n    return 0;\n}