#include <pthread.h>\n#include <stdbool.h>\n\ntypedef struct {\n    struct my_data data[MAX_QUEUE_LEN];\n    atomic_int head;\n    atomic_int tail;\n    pthread_mutex_t mutex;\n    pthread_cond_t cond_not_empty;\n} my_queue_t;\n\nmy_queue_t queue;\n\nvoid consumer() {\n    while (1) {\n        pthread_mutex_lock(&queue.mutex);\n        while (atomic_load(&queue.tail) == atomic_load(&queue.head)) {\n            pthread_cond_wait(&queue.cond_not_empty, &queue.mutex);\n        }\n        // Process the item at queue.data[queue.tail % MAX_QUEUE_LEN]\n        // Increment the tail and possibly other cleanup\n        atomic_store(&queue.tail, (atomic_load(&queue.tail) + 1) % MAX_QUEUE_LEN);\n        pthread_mutex_unlock(&queue.mutex);\n    }\n}\n\nvoid producer() {\n    while (1) {\n        if ((atomic_load(&queue.head) - atomic_load(&queue.tail)) < MAX_QUEUE_LEN - 1) {\n            pthread_mutex_lock(&queue.mutex);\n            // Produce an item and place it at queue.data[queue.head % MAX_QUEUE_LEN]\n            // Increment the head after placing the item\n            atomic_store(&queue.head, (atomic_load(&queue.head) + 1) % MAX_QUEUE_LEN);\n            pthread_cond_signal(&queue.cond_not_empty);\n            pthread_mutex_unlock(&queue.mutex);\n        }\n        usleep(1);  // Simulate work or yield\n    }\n}