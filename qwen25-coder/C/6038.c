#include <pthread.h>\n#include <stdio.h>\n\nvolatile int data_available = 0; // Define a global variable to act as the condition\npthread_mutex_t lock_it = PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t write_it = PTHREAD_COND_INITIALIZER;\n\nvoid* send_segments(void *v) {\n    while (1) {\n        pthread_mutex_lock(&lock_it);\n        \n        while (!data_available) {  // Wait until data is available\n            printf("s1\n");\n            printf("s2\n");\n            pthread_cond_wait(&write_it, &lock_it);  // Will unlock the mutex and wait for signal\n        }\n\n        printf("s3\n");\n        printf("s4\n");\n        printf("s5\n");\n\n        data_available = 0;  // Reset condition variable\n        pthread_mutex_unlock(&lock_it);\n    }\n    return NULL;\n}\n\nvoid* recv_acks(void *v) {\n    while (1) {\n        pthread_mutex_lock(&lock_it);\n\n        if (!data_available) {  // Optional check to avoid redundant signals\n            printf("r1\n");\n            data_available = 1;  // Set condition variable\n            pthread_cond_signal(&write_it);  // Signal the waiting thread\n        }\n        printf("r2\n");\n\n        pthread_mutex_unlock(&lock_it);\n    }\n    return NULL;\n}\n\nint main(int argc, char** argv) {\n    pthread_t t_send_segments, t_recv_acks;\n\n    pthread_create(&t_send_segments, NULL, send_segments, (void*)NULL);\n    pthread_create(&t_recv_acks,     NULL, recv_acks,     (void*)NULL);\n\n    pthread_join(t_recv_acks,     (void**)NULL);  // Note: This line will hang because the loop in recv_acks is infinite\n\n    pthread_mutex_destroy(&lock_it);\n    pthread_cond_destroy(&write_it);\n\n    return 0;\n}