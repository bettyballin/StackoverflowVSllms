#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n    int fd[2], i, aux, std0, std1;\n    \n    if (argc < 2) {\n        fprintf(stderr, "Usage: %s cmd1 | cmd2 | ... | cmd_n\n", argv[0]);\n        exit(1);\n    }\n    \n    do {\n        std0 = dup(0); // backup stdin\n        std1 = dup(1); // backup stdout\n\n        for (i = 1; i < argc; i++) {\n            if (i > 1) {\n                dup2(aux, 0);  // set previous pipe end as stdin\n                close(aux);\n            }\n        \n            if (i < argc - 1) {\n                if (pipe(fd) == -1) {  // create new pipe for intermediate command\n                    perror("Pipe error");\n                    goto cleanup;\n                }\n\n                aux = fd[0];\n                dup2(fd[1], 1);  // set write end to stdout\n                close(fd[1]);\n            } else {\n                dup2(std1, 1);  // restore stdout for last command\n                close(std1);\n            }\n        \n            if (!fork()) {  // child process executes the command\n                execlp(argv[i], argv[i], (char *)NULL);\n                perror("Exec error");\n                exit(0);\n            } else {\n                if (i > 1)\n                    close(fd[0]);\n                if (i < argc - 1)\n                    close(fd[1]);\n            }\n        }\n\n        for (int j = 1; j < argc; j++) {  // wait for all child processes to finish\n            wait(NULL);\n        }\n    \n        dup2(std0, 0);  // restore stdin after commands execution\n        close(std0);\n    } while (0);  // Changed from infinite loop to single pass\n\n    return 0;\ncleanup:\n    close(std0);\n    close(std1);\n    exit(EXIT_FAILURE);\n}