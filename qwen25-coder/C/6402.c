#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main() {\n    int pipefd[2];\n    pid_t cpid;\n    char buffer[1024];\n    char *command = "ls -l";  // Replace with your command\n\n    if (pipe(pipefd) == -1) {\n        perror("pipe");\n        exit(EXIT_FAILURE);\n    }\n\n    cpid = fork();\n    if (cpid == -1) {\n        perror("fork");\n        exit(EXIT_FAILURE);\n    }\n\n    if (cpid == 0) { // Child reads from pipe\n        close(pipefd[0]);          // Close unused read end\n\n        dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to pipe write end\n\n        close(pipefd[1]);          // Don't need write end anymore\n\n        execlp("/bin/sh", "/bin/sh", "-c", command, NULL);\n        perror("execlp");           // If exec fails\n        exit(EXIT_FAILURE);\n\n    } else {                     // Parent writes to pipe\n        int status;\n        close(pipefd[1]);          // Close unused write end\n\n        while (read(pipefd[0], buffer, sizeof(buffer) - 1) != 0) {\n            printf("%s", buffer); // Print output from command\n            memset(buffer, 0, sizeof(buffer)); // Clear buffer for next read\n        }\n\n        close(pipefd[0]);          // Close the remaining file desriptor\n        waitpid(cpid, &status, 0);\n        if (WIFEXITED(status)) {\n            printf("Command exited normally with status %d\n", WEXITSTATUS(status));\n        } else {\n            printf("Command did not exit normally\n");\n        }\n    }\n\n    return EXIT_SUCCESS;\n}