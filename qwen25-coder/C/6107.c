#include <openssl/evp.h>\n#include <string>\n#include <iostream>\n\nvoid aes_cfb_encrypt(const unsigned char *plaintext, int plaintext_len,\n                    const unsigned char *key, const unsigned char *iv,\n                    unsigned char *ciphertext) {\n    EVP_CIPHER_CTX *ctx;\n\n    int len;\n    int ciphertext_len;\n\n    /* Create and initialize the context */\n    if(!(ctx = EVP_CIPHER_CTX_new()))\n        handleErrors();\n\n    /*\n     * Initialise the encryption operation. IMPORTANT - ensure you use a key\n     * and IV size appropriate for your cipher\n     * In this example we are using 256 bit AES (i.e. a 256 bit key). The\n     * IV size for *most* modes is the same as the block size. For AES this\n     * is 128 bits\n     */\n    if(1 != EVP_EncryptInit_ex(ctx, EVP_aes_256_cfb(), NULL, key, iv))\n        handleErrors();\n\n    /*\n     * Provide the message to be encrypted, and obtain the encrypted output.\n     * EVP_EncryptUpdate can be called multiple times if necessary\n     */\n    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len))\n        handleErrors();\n    ciphertext_len = len;\n\n    /*\n     * Finalise the encryption. Normally plaintext is padded to block length\n     * and would require a call to EVP_EncryptFinal() but in this case we've\n     * used CFB mode which does not need padding.\n     */\n    if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len))\n        handleErrors();\n    ciphertext_len += len;\n\n    /* Clean up */\n    EVP_CIPHER_CTX_free(ctx);\n\n}\n\nvoid handleErrors(void) {\n    ERR_print_errors_fp(stderr);\n    abort();\n}\n\nint main (void)\n{\n    /* A 256 bit key */\n    unsigned char *key = (unsigned char *)"01234567890123456789012345678901";\n\n    /* A 128 bit IV */\n    unsigned char *iv = (unsigned char *)"0123456789012345";\n\n    /* Message to be encrypted */\n    unsigned char *plaintext =\n        (unsigned char *)"The quick brown fox jumps over the lazy dog";\n\n    /*\n     * Buffer for ciphertext. Ensure the buffer is long enough for the\n     * ciphertext which may be longer than the plaintext, depending on the\n     * algorithm and mode.\n     */\n    int ciphertext_len;\n    unsigned char ciphertext[128];\n\n    aes_cfb_encrypt (plaintext, strlen((char *)plaintext), key, iv,\n                     ciphertext);\n\n    printf("Ciphertext is:\n");\n    BIO_dump_fp(stdout, (const char*)ciphertext, ciphertext_len);\n\n    return 0;\n}