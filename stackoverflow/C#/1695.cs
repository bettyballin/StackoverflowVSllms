using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nusing System.Diagnostics;\n\nnamespace DoNotCloseMe\n{\n    class Program\n    {\n\n        const string _title = "DO NOT CLOSE - Important Program";\n\n        static void Main(string[] args)\n        {\n\n            Console.Title = _title;\n\n            IntPtr hMenu = Process.GetCurrentProcess().MainWindowHandle;\n            IntPtr hSystemMenu = GetSystemMenu(hMenu, false);\n\n            EnableMenuItem(hSystemMenu, SC_CLOSE, MF_GRAYED);\n            RemoveMenu(hSystemMenu, SC_CLOSE, MF_BYCOMMAND);\n\n            WriteConsoleHeader();\n\n            //This function only seems to be called once.\n            //After calling MainLoop() below, CTRL-C && CTRL-BREAK cause Console.ReadLine() to return NULL \n            Console.CancelKeyPress += (sender, e) =>\n            {\n                Console.WriteLine("Clean-up code invoked in CancelKeyPress handler.");\n                Console.WriteLine("Key Pressed: {0}", e.SpecialKey.ToString());\n                System.Threading.Thread.Sleep(1000);\n                MainLoop();\n                // The application terminates directly after executing this delegate.\n            };\n\n            MainLoop();\n\n        }\n\n        private static void MainLoop()\n        {\n            while (true)\n            {\n                WriteConsoleHeader();\n                string x = Console.ReadLine();\n                if (!String.IsNullOrEmpty(x))\n                {\n                    switch (x.ToUpperInvariant())\n                    {\n                        case "EXIT":\n                        case "QUIT":\n                            System.Environment.Exit(0);\n                            break;\n                        default:\n                            StartLongRunningTaskOnSeparateThread(x);\n                            break;\n                    }\n\n                }\n            }\n        }\n\n        private static void StartLongRunningTaskOnSeparateThread(string command)\n        {\n            var bg = new System.ComponentModel.BackgroundWorker();\n            bg.WorkerReportsProgress = false;\n            bg.WorkerSupportsCancellation = false;\n\n            bg.DoWork += (sender, args) =>\n            {\n                var sleepTime = (new Random()).Next(5000);\n                System.Threading.Thread.Sleep(sleepTime);\n            };\n\n\n            bg.RunWorkerCompleted += (sender, args) =>\n            {\n                Console.WriteLine("Commmand Complete: {0}", command);\n            };\n\n            bg.RunWorkerAsync();\n\n        }\n\n        private static void WriteConsoleHeader()\n        {\n            Console.Clear();\n            Console.WriteLine(new string('*', Console.WindowWidth - 1));\n            Console.WriteLine(_title);\n            Console.WriteLine(new string('*', Console.WindowWidth - 1));\n            Console.WriteLine("Please do not close this program.");\n            Console.WriteLine("It is maintaining the space/time continuum.");\n            Console.WriteLine("If you close it, Q will not be happy and you will be assimilated.");\n            Console.WriteLine(new string('*', Console.WindowWidth - 1));\n            Console.WriteLine("Development Mode: Use \"EXIT\" or \"QUIT\" to exit application.");\n            Console.WriteLine(new string('*', Console.WindowWidth - 1));\n        }\n\n        #region "Unmanaged"\n\n        [DllImport("user32.dll")]\n        static extern bool EnableMenuItem(IntPtr hMenu, uint uIDEnableItem, uint uEnable);\n\n        [DllImport("user32.dll")]\n        static extern IntPtr GetSystemMenu(IntPtr hWnd, bool bRevert);\n\n        [DllImport("user32.dll")]\n        static extern IntPtr RemoveMenu(IntPtr hMenu, uint nPosition, uint wFlags);\n\n        internal const uint SC_CLOSE = 0xF060;\n        internal const uint MF_GRAYED = 0x00000001;\n        internal const uint MF_BYCOMMAND = 0x00000000;\n\n        #endregion\n    }\n}