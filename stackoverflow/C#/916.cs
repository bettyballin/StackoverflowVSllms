public class BinarySearcher<T>\n{\n    // Possibly passed to the call to BinarySort.\n    private class ComparisonComparer : Comparer<T>\n    {\n        Comparison<T> comparison;\n\n        internal static IComparer<T> Create(Comparison<T> comparison)\n        {\n            // If comparison is null, return the default comparer for T.\n            if (comparison == null)\n            {\n                // Return the default.\n                return Comparer<T>.Default;\n            }\n\n            // Return a new implementation.\n            return new ComparisonComparer(comparison);\n        }\n\n        private ComparisonComparer(Comparison<T> comparison)\n        {\n            this.comparison = comparison;\n        }\n\n        public override int Compare(T x, T y)\n        {\n            return comparison(x, y);\n        }\n    }\n\n    // The elements.\n    T[] elements;\n\n    // The IComparable implementation.\n    IComparer<T> comparer;\n\n    // Do not assume sorting.\n    public BinarySearcher(IEnumerable<T> elements) : \n        this(elements, false, (IComparer<T>) null) { }\n\n    // Use default comparer.\n    public BinarySearcher(IEnumerable<T> elements, bool sorted) :\n        this(elements, sorted, (IComparer<T>) null) { }\n\n    // Assume no sorting.\n    public BinarySearcher(IEnumerable<T> elements, \n        Comparison<T> comparer) :\n            this(elements, false, \n                ComparisonComparer.Create(comparer)) { }\n\n    // Convert to IComparable<T>.\n    public BinarySearcher(IEnumerable<T> elements, bool sorted, \n        Comparison<T> comparer) :\n            this(elements, sorted, \n                ComparisonComparer.Create(comparer)) { }\n\n    // No sorting.\n    public BinarySearcher(IEnumerable<T> elements, \n        IComparer<T> comparer) :\n            this(elements, false, comparer) { }\n\n    // Convert to array.\n    public BinarySearcher(IEnumerable<T> elements, bool sorted, \n        IComparer<T> comparer) :\n            this(elements.ToArray(), sorted, comparer) { }\n\n    // Assume no sorting.\n    public BinarySearcher(T[] elements) : this(elements, false) { }\n\n    // Pass null for default comparer.\n    public BinarySearcher(T[] elements, bool sorted) : \n        this(elements, sorted, (IComparer<T>) null) { }\n\n    // Assume not sorted.\n    public BinarySearcher(T[] elements, Comparison<T> comparer) :\n        this(elements, false, ComparisonComparer.Create(comparer)) { }\n\n    // Create IComparable<T> from Comparable<T>.\n    public BinarySearcher(T[] elements, bool sorted, \n        Comparison<T> comparer) :\n            this(elements, sorted, ComparisonComparer.Create(comparer)) { }\n\n    // Assume the elements are not sorted.\n    public BinarySearcher(T[] elements, IComparer<T> comparer) : \n        this(elements, false, comparer) { }\n\n    public BinarySearcher(T[] elements, bool sorted, \n        IComparer<T> comparer)\n    {\n        // If the comparer is null, create the default one.\n        if (comparer == null)\n        {\n            // Set to the default one.\n            comparer = Comparer<T>.Default;\n        }\n\n        // Set the comparer.\n        this.comparer = comparer;\n\n        // Set the elements.  If they are sorted already, don't bother, \n        // otherwise, sort.\n        if (!sorted)\n        {\n            // Sort.\n            Array.Sort(elements, this.comparer);\n        }\n\n        // Set the elements.\n        this.elements = elements;\n    }\n\n    public IEnumerable<T> Between(T from, T to)\n    {\n        // Find the index for the beginning.\n        int index = Array.BinarySearch(this.elements, from, comparer);\n\n        // Was the item found?\n        bool found = (index >= 0);\n\n        // If the item was not found, take the bitwise \n        // compliment to find out where it would be.\n        if (!found)\n        {\n            // Take the bitwise compliment.\n            index = ~index;\n        }\n\n        // If the item was found, cycle backwards from\n        // the index while there are elements that are the same.\n        if (found)\n        {\n            // Cycle backwards.\n            for (; index >= 0 && \n                comparer.Compare(from, elements[index]) == 0; \n                --index) ;\n\n            // Add one to the index, since this is on the element \n            // that didn't match the comparison.\n            index++;\n        }\n\n        // Go forward now.\n        for ( ; index < elements.Length; index++)\n        {\n            // Return while the comparison is true.\n            if (comparer.Compare(elements[index], to) <= 0)\n            {\n                // Return the element.\n                yield return elements[index];\n            }\n            else\n            {\n                // Break\n                yield break;\n            }\n        }\n    }\n}