using System;\nusing System.Collections.Generic;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Net.Security;\nusing System.Web;\nusing System.Web.Handlers;\nusing System.IO;\nusing System.Security.Cryptography;\nusing System.Security.Cryptography.X509Certificates;\n\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        public static string API_KEY = "YOUR_API_KEY_GOES_HERE! INCLUDE DASHES!";\n        public static string SECRET_ACCESS_KEY = "YOUR_SECRET_KEY_GOES_HERE!";\n\n        static void Main(string[] args)\n        {\n            Console.WriteLine("BLAST - \r\n\r\n");\n            BlastTcpPost();\n\n            Console.WriteLine("SEND - \r\n\r\n");\n            SendTcpPost();\n        }\n\n        /// <summary>\n        /// Send a BLAST to all users in your ZEEP account.\n        /// </summary>\n        public static void BlastTcpPost()\n        {\n            SendSMS(\n                "https://api.zeepmobile.com/messaging/2008-07-14/blast_message",    // URL for Send_Message \n                "You are on blast",                                                 // Message to send\n                string.Empty                                                        // No UserId to send.\n                );\n        }\n\n        /// <summary>\n        /// Send a single message to a user in your ZEEP account.\n        /// </summary>\n        public static void SendTcpPost()\n        {\n            // Note:- 22 I use for the UserId is just a user I have signed up. Yours may be different and you \n            // might want to pass that in as a parameter.\n\n            SendSMS(\n                "https://api.zeepmobile.com/messaging/2008-07-14/send_message",     // URL for Send_Message\n                "You are a user...good job!",                                       // Message to send\n                "22"                                                                // User Id in your system.\n                );\n\n        }\n\n        /// <summary>\n        /// Uses a TCPClient and SSLStream to perform a POST.\n        /// </summary>\n        /// <param name="requestUrl">URL that the POST must be directed to.</param>\n        /// <param name="body">Message that is to be sent.</param>\n        /// <param name="user">UserId in your Zeep System. Only required if your sending a Single Message to a User. \n        /// Otherwise, just send a string.Empty.</param>\n        /// <returns>Response from the server. (although it will write the response to console)</returns>\n        public static string SendSMS(string requestUrl, string body, string user)\n        {\n            string parameters = "";\n            string requestHeaders = "";\n            string responseData = "";\n\n            // FORMAT must be Sun, 06 Nov 1994 08:49:37 GMT\n            string http_date = DateTime.UtcNow.ToString("r");\n\n            // Clean the text to send\n            body = HttpUtility.UrlEncode(body, System.Text.Encoding.UTF8);\n\n            if (user.Length > 0) parameters += "user_id=" + user + "&";\n            if (body.Length > 0) parameters += "body=" + body;\n\n\n            // String that will be converted into a signature.\n            string canonicalString = API_KEY + http_date + parameters;\n\n\n            //------------START HASH COMPUTATION---------------------\n            // Compute the Base64 HMACSHA1 value\n            HMACSHA1 hmacsha1 = new HMACSHA1(SECRET_ACCESS_KEY.ToByteArray());\n\n            // Compute the hash of the input file.\n            byte[] hashValue = hmacsha1.ComputeHash(canonicalString.ToByteArray());\n\n            String b64Mac = hashValue.ToBase64String();\n            String authentication = String.Format("Zeep {0}:{1}", API_KEY, b64Mac);\n            //-----------END HASH COMPUTATION------------------------\n\n\n            string auth = String.Format("Zeep {0}:{1}", API_KEY, b64Mac);\n\n\n            System.Uri uri = new Uri(requestUrl);\n            System.Net.Sockets.TcpClient client = new System.Net.Sockets.TcpClient(uri.Host, uri.Port);\n            string requestMethod = "POST " + uri.LocalPath + " HTTP/1.1\r\n";\n\n            // Set Headers for the POST message\n            requestHeaders += "Host: api.zeepmobile.com\r\n";\n            requestHeaders += "Authorization: " + auth + "\r\n";\n            requestHeaders += "Date: " + DateTime.UtcNow.ToString("r") + "\r\n";\n            requestHeaders += "Content-Type: application/x-www-form-urlencoded\r\n";\n            requestHeaders += "Content-Length: " + parameters.ToByteArray().Length + "\r\n";\n            requestHeaders += "\r\n";\n\n\n            // Get the data to be sent as a byte array.\n            Byte[] data = System.Text.Encoding.UTF8.GetBytes(requestMethod + requestHeaders + parameters + "\r\n");\n            // Send the message to the connected TcpServer.\n            NetworkStream stream = client.GetStream();\n\n\n            // SSL Authentication is used because the Server requires https.\n            System.Net.Security.SslStream sslStream = new System.Net.Security.SslStream(\n                stream,\n                false,\n                new System.Net.Security.RemoteCertificateValidationCallback(ValidateServerCertificate));\n            sslStream.AuthenticateAsClient(uri.Host);\n\n            // Send the data over the SSL stream.\n            sslStream.Write(data, 0, data.Length);\n            sslStream.Flush();\n\n\n            // Receive the TcpServer.response.\n            for (int i = 0; i < 100; i++)\n            {\n                if (stream.DataAvailable)\n                {\n                    break;\n                }\n                System.Threading.Thread.Sleep(100);\n            }\n\n            Byte[] bytes = new byte[1024];\n            System.Text.StringBuilder sb = new System.Text.StringBuilder();\n            while (stream.DataAvailable)\n            {\n                int count = sslStream.Read(bytes, 0, 1024);\n                if (count == 0)\n                {\n                    break;\n                }\n                sb.Append(System.Text.Encoding.UTF8.GetString(bytes, 0, count));\n            }\n\n            responseData = sb.ToString();\n            Console.WriteLine(responseData);\n            // Close everything.\n            client.Close();\n\n            return responseData;\n        }\n\n\n\n        // The following method is invoked by the RemoteCertificateValidationDelegate.\n        // We want to make sure the SSL has no Policy errors and is safe.\n        public static bool ValidateServerCertificate(\n              object sender,\n              X509Certificate certificate,\n              X509Chain chain,\n              SslPolicyErrors sslPolicyErrors)\n        {\n            // Somehow the cert always has PolicyErrors so I am returning true regardless.\n            return true;\n            //if (sslPolicyErrors == SslPolicyErrors.None)\n            //    return true;\n\n            //Console.WriteLine("Certificate error: {0}", sslPolicyErrors);\n\n            //// Do not allow this client to communicate with unauthenticated servers.\n            //return false;\n        }\n    }\n\n    public static class Extensions\n    {\n        public static byte[] ToByteArray(this string input)\n        {\n            UTF8Encoding encoding = new UTF8Encoding();\n            return encoding.GetBytes(input);\n        }\n\n        public static string ToBase64String(this byte[] input)\n        {\n            return Convert.ToBase64String(input);\n        }\n    }\n}