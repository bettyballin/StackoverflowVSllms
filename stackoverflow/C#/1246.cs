internal void DoTheThing()\n{\n    try\n    {\n        DoSomethingThatMayCauseAnException();\n    }\n    catch (System.IO.IOException ioexc1)\n    {\n        // Check if we can call GetHRForException, \n        // which makes unmanaged code calls.\n        var p = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);\n        if (p.IsUnrestricted())\n        {\n            uint hresult = _HRForException(ioexc1);\n            if (hresult == 0x80070021)  // ERROR_LOCK_VIOLATION\n                TakeActionOnLockViolation();  // maybe notify the user\n            else\n                throw new Exception("Cannot handle", ioexc1);\n        }\n        else\n        {\n            // The permission is restricted. Therefore, we cannot call\n            // GetHRForException, and cannot do the subtle handling of\n            // ERROR_LOCK_VIOLATION.  Just bail.\n            throw new Exception("Cannot handle", ioexc1);\n        }\n    }\n}\n\n// This method must remain separate, and must not be marked with a LinkDemand for\n// UnmanagedCode.\n//\n// Marshal.GetHRForException() is needed to do special exception handling for\n// the read.  But, that method requires UnmanagedCode permissions, and is marked\n// with LinkDemand for UnmanagedCode.  In an ASP.NET medium trust environment,\n// where UnmanagedCode is restricted, will generate a SecurityException at the\n// time of JIT of the method that calls a method that is marked with LinkDemand\n// for UnmanagedCode. The SecurityException, if it is restricted, will occur\n// when this method is JITed.\n//\n// The Marshal.GetHRForException() is factored out of DoTheThing in order to\n// avoid the SecurityException at JIT compile time. Because _HRForException is\n// called only when the UnmanagedCode is allowed, .NET never\n// JIT-compiles this method when UnmanagedCode is disallowed, and thus never\n// generates the JIT-compile time exception.\n//\nprivate static uint _HRForException(System.Exception ex1)\n{\n    return unchecked((uint)System.Runtime.InteropServices.Marshal.GetHRForException(ex1));\n}