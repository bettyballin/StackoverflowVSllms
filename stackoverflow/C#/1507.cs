/// <summary>\n/// The set of characters that are unreserved in RFC 2396 but are NOT unreserved in RFC 3986.\n/// </summary>\nprivate static readonly string[] UriRfc3986CharsToEscape = new[] { "!", "*", "'", "(", ")" };\n\n/// <summary>\n/// Escapes a string according to the URI data string rules given in RFC 3986.\n/// </summary>\n/// <param name="value">The value to escape.</param>\n/// <returns>The escaped value.</returns>\n/// <remarks>\n/// The <see cref="Uri.EscapeDataString"/> method is <i>supposed</i> to take on\n/// RFC 3986 behavior if certain elements are present in a .config file.  Even if this\n/// actually worked (which in my experiments it <i>doesn't</i>), we can't rely on every\n/// host actually having this configuration element present.\n/// </remarks>\ninternal static string EscapeUriDataStringRfc3986(string value) {\n    // Start with RFC 2396 escaping by calling the .NET method to do the work.\n    // This MAY sometimes exhibit RFC 3986 behavior (according to the documentation).\n    // If it does, the escaping we do that follows it will be a no-op since the\n    // characters we search for to replace can't possibly exist in the string.\n    StringBuilder escaped = new StringBuilder(Uri.EscapeDataString(value));\n\n    // Upgrade the escaping to RFC 3986, if necessary.\n    for (int i = 0; i < UriRfc3986CharsToEscape.Length; i++) {\n        escaped.Replace(UriRfc3986CharsToEscape[i], Uri.HexEscape(UriRfc3986CharsToEscape[i][0]));\n    }\n\n    // Return the fully-RFC3986-escaped string.\n    return escaped.ToString();\n}