// Add the following two using-directives to LINQPad:\n// System.Drawing\n// System.Drawing.Imaging\n\nstatic Bitmap _Dummy = new Bitmap(16, 16, PixelFormat.Format24bppRgb);\nstatic Font _Font = new Font("Arial", 12);\n\nvoid Main()\n{\n    var elementsAsString = "A 2 ^ 2 A * B * - B 2 ^ + A B - / 2 ^";\n    var elements = elementsAsString.Split(' ');\n\n    var stack = new Stack<Node>();\n    foreach (var element in elements)\n        if (IsOperator(element))\n        {\n            Node rightOperand = stack.Pop();\n            Node leftOperand = stack.Pop();\n            stack.Push(new Node(element, leftOperand, rightOperand));\n        }\n        else\n            stack.Push(new Node(element));\n\n    Visualize(stack.Pop());\n}\n\nvoid Visualize(Node node)\n{\n    node.ToBitmap().Dump();\n}\n\nclass Node\n{\n    public Node(string value)\n        : this(value, null, null)\n    {\n    }\n\n    public Node(string value, Node left, Node right)\n    {\n        Value = value;\n        Left = left;\n        Right = right;\n    }\n\n    public string Value;\n    public Node Left;\n    public Node Right;\n\n    public Bitmap ToBitmap()\n    {\n        Size valueSize;\n        using (Graphics g = Graphics.FromImage(_Dummy))\n        {\n            var tempSize = g.MeasureString(Value, _Font);\n            valueSize = new Size((int)tempSize.Width + 4, (int)tempSize.Height + 4);\n        }\n\n        Bitmap bitmap;\n        Color valueColor = Color.LightPink;\n        if (Left == null && Right == null)\n        {\n            bitmap = new Bitmap(valueSize.Width, valueSize.Height);\n            valueColor = Color.LightGreen;\n        }\n        else\n        {\n            using (var leftBitmap = Left.ToBitmap())\n            using (var rightBitmap = Right.ToBitmap())\n            {\n                int subNodeHeight = Math.Max(leftBitmap.Height, rightBitmap.Height);\n                bitmap = new Bitmap(\n                    leftBitmap.Width + rightBitmap.Width + valueSize.Width,\n                    valueSize.Height + 32 + subNodeHeight);\n\n                using (var g = Graphics.FromImage(bitmap))\n                {\n                    int baseY  = valueSize.Height + 32;\n\n                    int leftTop = baseY; // + (subNodeHeight - leftBitmap.Height) / 2;\n                    g.DrawImage(leftBitmap, 0, leftTop);\n\n                    int rightTop = baseY; // + (subNodeHeight - rightBitmap.Height) / 2;\n                    g.DrawImage(rightBitmap, bitmap.Width - rightBitmap.Width, rightTop);\n\n                    g.DrawLine(Pens.Black, bitmap.Width / 2 - 4, valueSize.Height, leftBitmap.Width / 2, leftTop);\n                    g.DrawLine(Pens.Black, bitmap.Width / 2 + 4, valueSize.Height, bitmap.Width - rightBitmap.Width / 2, rightTop);\n                }\n            }\n        }\n\n        using (var g = Graphics.FromImage(bitmap))\n        {\n            float x = (bitmap.Width - valueSize.Width) / 2;\n            using (var b = new SolidBrush(valueColor))\n                g.FillRectangle(b, x, 0, valueSize.Width - 1, valueSize.Height - 1);\n            g.DrawRectangle(Pens.Black, x, 0, valueSize.Width - 1, valueSize.Height - 1);\n            g.DrawString(Value, _Font, Brushes.Black, x + 1, 2);\n        }\n\n        return bitmap;\n    }\n}\n\nbool IsOperator(string s)\n{\n    switch (s)\n    {\n        case "*":\n        case "/":\n        case "^":\n        case "+":\n        case "-":\n            return true;\n\n        default:\n            return false;\n    }\n}