static readonly byte[] apiCertHash = { 0xZZ, 0xYY, ....};\n\n/// <summary>\n/// Somewhere in your application's startup/init sequence...\n/// </summary>\nvoid InitPhase()\n{\n    // Override automatic validation of SSL server certificates.\n    ServicePointManager.ServerCertificateValidationCallback =\n           ValidateServerCertficate;\n}\n\n/// <summary>\n/// Validates the SSL server certificate.\n/// </summary>\n/// <param name="sender">An object that contains state information for this\n/// validation.</param>\n/// <param name="cert">The certificate used to authenticate the remote party.</param>\n/// <param name="chain">The chain of certificate authorities associated with the\n/// remote certificate.</param>\n/// <param name="sslPolicyErrors">One or more errors associated with the remote\n/// certificate.</param>\n/// <returns>Returns a boolean value that determines whether the specified\n/// certificate is accepted for authentication; true to accept or false to\n/// reject.</returns>\nprivate static bool ValidateServerCertficate(\n        object sender,\n        X509Certificate cert,\n        X509Chain chain,\n        SslPolicyErrors sslPolicyErrors)\n{\n    if (sslPolicyErrors == SslPolicyErrors.None)\n    {\n        // Good certificate.\n        return true;\n    }\n\n    log.DebugFormat("SSL certificate error: {0}", sslPolicyErrors);\n\n    bool certMatch = false; // Assume failure\n    byte[] certHash = cert.GetCertHash();\n    if (certHash.Length == apiCertHash.Length)\n    {\n        certMatch = true; // Now assume success.\n        for (int idx = 0; idx < certHash.Length; idx++)\n        {\n            if (certHash[idx] != apiCertHash[idx])\n            {\n                certMatch = false; // No match\n                break;\n            }\n        }\n    }\n\n    // Return true => allow unauthenticated server,\n    //        false => disallow unauthenticated server.\n    return certMatch;\n}