public static void MinimizeMemory()\n{\n    GC.Collect(GC.MaxGeneration);\n    GC.WaitForPendingFinalizers();\n    SetProcessWorkingSetSize(\n        Process.GetCurrentProcess().Handle,\n        (UIntPtr)0xFFFFFFFF,\n        (UIntPtr)0xFFFFFFFF);\n\n    IntPtr heap = GetProcessHeap();\n\n    if (HeapLock(heap))\n    {\n        try\n        {\n            if (HeapCompact(heap, 0) == 0)\n            {\n                // error condition ignored\n            }\n        }\n        finally\n        {\n            HeapUnlock(heap);\n        }\n    }\n}\n\n[DllImport("kernel32.dll")]\n[return: MarshalAs(UnmanagedType.Bool)]\ninternal static extern bool SetProcessWorkingSetSize(\n    IntPtr process,\n    UIntPtr minimumWorkingSetSize,\n    UIntPtr maximumWorkingSetSize);\n\n[DllImport("kernel32.dll", SetLastError = true)]\ninternal static extern IntPtr GetProcessHeap();\n\n[DllImport("kernel32.dll")]\n[return: MarshalAs(UnmanagedType.Bool)]\ninternal static extern bool HeapLock(IntPtr heap);\n\n[DllImport("kernel32.dll")]\ninternal static extern uint HeapCompact(IntPtr heap, uint flags);\n\n[DllImport("kernel32.dll")]\n[return: MarshalAs(UnmanagedType.Bool)]\ninternal static extern bool HeapUnlock(IntPtr heap);