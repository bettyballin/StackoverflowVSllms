public abstract class MultipartRangeHandler : IHttpHandler\n{\n    protected const String HEADER_RANGE = "range";\n    protected const String HEADER_CONTENT_TYPE = "Content-Type";\n    protected const String HEADER_CONTENT_LENGTH = "Content-Length: ";\n    protected const String HEADER_CONTENT_DISPOSITION = "Content-Disposition";\n    protected const String HEADER_CONTENT_RANGE = "Content-Range";\n    protected const String HEADER_BOUNDARY_DELIMETER = "--";\n    protected const String HEADER_STATUS_PARTIAL_CONTENT = "Partial Content";\n\n    private const char COMMA = ',';\n    private const char EQUALS = '=';\n    private const char NEW_LINE = '\n';\n\n    protected const String QS_OBJECT_ID = "cid";\n\n    public void ProcessRequest(HttpContext context)\n    {\n        if (StringUtils.isNullOrEmpty(context.Request.QueryString[QS_OBJECT_ID]))\n        {\n            sendResponse(400, "400 Bad Request", "No resource was specified in the query string to retrieve.", context);\n        }\n        else\n        {\n            ContentItem contentItem = getContentItem(context.Request.QueryString[QS_OBJECT_ID]);\n\n            if (contentItem != null)\n            {\n                context.Response.Clear();\n                context.Response.ClearHeaders();\n                context.Response.ClearContent();\n\n                if (context.Request.Headers[HEADER_RANGE] != null)\n                {\n\n                    string range = context.Request.Headers[HEADER_RANGE];\n                    range = range.Substring(range.LastIndexOf(EQUALS) + 1);\n                    bool isMultipartRange = range.Contains(COMMA.ToString());\n\n                    if (!isMultipartRange)\n                    {\n                        addHeader(context.Response, HEADER_CONTENT_TYPE, contentItem.MimeType);\n                        addHeader(context.Response, HEADER_CONTENT_DISPOSITION, "inline; filename=\"" + contentItem.Filename + "\"");\n\n                        string[] startEnd = range.Split('-');\n\n                        long startPos;\n\n                        long.TryParse(startEnd[0], out startPos);\n\n                        long endPos;\n                        int fileSize = contentItem.FileBytes.Length;\n\n                        if (startEnd.GetUpperBound(0) >= 1 && startEnd[1] != String.Empty)\n                        {\n                            long.TryParse(startEnd[1], out endPos);\n                        }\n                        else\n                        {\n                            endPos = fileSize - startPos;\n                        }\n\n                        if (endPos > fileSize)\n                        {\n                            endPos = fileSize - startPos;\n                        }\n\n                        context.Response.StatusCode = 206;\n                        context.Response.StatusDescription = HEADER_STATUS_PARTIAL_CONTENT;\n                        addHeader(context.Response, HEADER_CONTENT_RANGE, "bytes " + startPos + "-" + endPos + "/" + fileSize);\n\n                        context.Response.BinaryWrite(ByteUtils.subByte(contentItem.FileBytes, (int)startPos, (int)(endPos - startPos) + 1));\n                    }\n                    else\n                    {\n\n                        string boundary = "waynehartmanansmach";\n                        addHeader(context.Response, HEADER_CONTENT_TYPE, "multipart/byteranges; boundary=" + boundary);\n\n                        List<string[]> ranges = new List<string[]>();\n                        string[] multiRange = range.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);\n                        foreach (string mr in multiRange)\n                        {\n                            ranges.Add(mr.Split(new string[] { "-" }, StringSplitOptions.RemoveEmptyEntries));\n                        }\n\n                        //  process the list of ranges\n                        foreach (string[] rangeArray in ranges.ToArray())\n                        {\n                            context.Response.Write(HEADER_BOUNDARY_DELIMETER + boundary + NEW_LINE);\n                            context.Response.Write(HEADER_CONTENT_TYPE + ": " + contentItem.MimeType + NEW_LINE);\n                            context.Response.Write(HEADER_CONTENT_RANGE + ": bytes " + rangeArray[0] + "-" + rangeArray[1] + "/" + contentItem.FileBytes + NEW_LINE + NEW_LINE);\n                            long startPos = long.Parse(rangeArray[0]);\n                            long endPos = long.Parse(rangeArray[1]);\n\n                            context.Response.BinaryWrite(ByteUtils.subByte(contentItem.FileBytes, (int)startPos, (int)(endPos - startPos) + 1));\n\n                            context.Response.Write(NEW_LINE);\n                            context.Response.Flush();\n                        }\n\n                        context.Response.Write(HEADER_BOUNDARY_DELIMETER + boundary + HEADER_BOUNDARY_DELIMETER + NEW_LINE + NEW_LINE);\n                    }\n                }\n                else\n                {\n                    context.Response.ContentType = contentItem.MimeType;\n                    addHeader(context.Response, HEADER_CONTENT_DISPOSITION, "attachment; filename=\"" + contentItem.Filename + "\"");\n                    addHeader(context.Response, HEADER_CONTENT_LENGTH, contentItem.FileBytes.Length.ToString());\n\n                    context.Response.OutputStream.Write(contentItem.FileBytes, 0, contentItem.FileBytes.Length);\n                }\n            }\n            else\n            {\n                sendResponse(404, "404 Not Found", "The resource requested does not exist.", context);                    \n            }\n        }\n    }\n\n    private void sendResponse(int statusCode, String status, String statusMessage, HttpContext context)\n    {\n        System.Text.StringBuilder data = new System.Text.StringBuilder();\n\n        data.AppendLine("<html><body>");\n        data.AppendLine("<h1>"+status+"</h1>");\n        data.AppendLine("<p>"+statusMessage+"</p>");\n        data.AppendLine("</body></html>");\n\n        byte[] headerData = System.Text.Encoding.ASCII.GetBytes(data.ToString());\n\n        context.Response.ContentType = "text/html";\n        context.Response.StatusCode = statusCode;\n        context.Response.Status = status;\n\n        addHeader(context.Response, HEADER_CONTENT_LENGTH, headerData.Length.ToString());\n\n        //context.Response.AddHeader("Content-Length: ", headerData.Length.ToString());\n        context.Response.OutputStream.Write(headerData, 0, headerData.Length);\n        context.Response.End();\n    }\n\n    protected void addHeader(HttpResponse response, String key, String value)\n    {\n        response.AddHeader(key, value);\n    }\n\n    protected abstract com.waynehartman.util.web.handlers.multipartrange.ContentItem getContentItem(String objectID);\n\n    public bool IsReusable\n    {\n        get { return true; }\n    }\n}