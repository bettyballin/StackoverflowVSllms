public static class PermutationGenerator\n{\n    private static class Permutation<T>\n    {\n        public static IEnumerable<T> Choices { get; set; }\n    }\n\n    static PermutationGenerator()\n    {\n        Permutation<int>.Choices = new List<int> { -1, 0, 1 }.AsReadOnly();\n        Permutation<string>.Choices = new List<string> { null, "", "Hello World" }.AsReadOnly();\n    }\n\n    public static IEnumerable<T> GetPermutations<T>()\n    {\n        if (Permutation<T>.Choices == null) {\n            var props = typeof(T).GetProperties().Where(p => p.CanWrite);\n            Permutation<T>.Choices = new List<T>(GeneratePermutations<T>(() => Activator.CreateInstance<T>(), props)).AsReadOnly();\n        }\n        return Permutation<T>.Choices;\n    }\n\n    private static IEnumerable GetPermutations(Type t) {\n        var method = typeof(PermutationGenerator).GetMethod("GetPermutations", new Type[] {}).MakeGenericMethod(t);\n        return (IEnumerable)(method.Invoke(null,new object[] {}));\n    }\n\n    private delegate T Generator<T>();\n\n    private static IEnumerable<T> GeneratePermutations<T>(Generator<T> generator, IEnumerable<PropertyInfo> props)\n    {\n        if (!props.Any())\n        {\n            yield return generator();\n        }\n        else\n        {\n            var prop = props.First();\n            var rest = props.Skip(1);\n\n            foreach (var propVal in GetPermutations(prop.PropertyType))\n            {\n                Generator<T> gen = () =>\n                {\n                    var obj = generator();\n                    prop.SetValue(obj, propVal, null);\n                    return (T)obj;\n                };\n                foreach (var result in GeneratePermutations(gen, rest))\n                {\n                    yield return result;\n                }\n            }\n        }\n    }\n}