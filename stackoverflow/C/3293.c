HKEY hKey;\nLONG lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Perl", 0, KEY_READ, &hKey);\nbool bExistsAndSuccess (lRes == ERROR_SUCCESS);\nbool bDoesNotExistsSpecifically (lRes == ERROR_FILE_NOT_FOUND);\nstd::wstring strValueOfBinDir;\nstd::wstring strKeyDefaultValue;\nGetStringRegKey(hKey, L"BinDir", strValueOfBinDir, L"bad");\nGetStringRegKey(hKey, L"", strKeyDefaultValue, L"bad");\n\nLONG GetDWORDRegKey(HKEY hKey, const std::wstring &strValueName, DWORD &nValue, DWORD nDefaultValue)\n{\n    nValue = nDefaultValue;\n    DWORD dwBufferSize(sizeof(DWORD));\n    DWORD nResult(0);\n    LONG nError = ::RegQueryValueExW(hKey,\n        strValueName.c_str(),\n        0,\n        NULL,\n        reinterpret_cast<LPBYTE>(&nResult),\n        &dwBufferSize);\n    if (ERROR_SUCCESS == nError)\n    {\n        nValue = nResult;\n    }\n    return nError;\n}\n\n\nLONG GetBoolRegKey(HKEY hKey, const std::wstring &strValueName, bool &bValue, bool bDefaultValue)\n{\n    DWORD nDefValue((bDefaultValue) ? 1 : 0);\n    DWORD nResult(nDefValue);\n    LONG nError = GetDWORDRegKey(hKey, strValueName.c_str(), nResult, nDefValue);\n    if (ERROR_SUCCESS == nError)\n    {\n        bValue = (nResult != 0) ? true : false;\n    }\n    return nError;\n}\n\n\nLONG GetStringRegKey(HKEY hKey, const std::wstring &strValueName, std::wstring &strValue, const std::wstring &strDefaultValue)\n{\n    strValue = strDefaultValue;\n    WCHAR szBuffer[512];\n    DWORD dwBufferSize = sizeof(szBuffer);\n    ULONG nError;\n    nError = RegQueryValueExW(hKey, strValueName.c_str(), 0, NULL, (LPBYTE)szBuffer, &dwBufferSize);\n    if (ERROR_SUCCESS == nError)\n    {\n        strValue = szBuffer;\n    }\n    return nError;\n}