// compacted syntax for brevity...\ntemplate <typename T1, typename T2>\nstruct concat_iterator\n{\npublic:\n   typedef std::forward_iterator_tag iterator_category;\n   typedef typename iterator_traits<T1>::value_type value_type;\n   typedef *value_type pointer; \n   typedef &value_type reference;\n\n   concat_iterator( T1 b1, T1 e1, T2 b2, T2 e2 ) \n      : seq1( b1 ), seq1end( e1 ), seq2( b2 ), seq2end( e2 );\n   iterator& operator++() {\n      if ( seq1 != seq1end ) ++seq1;\n      else ++seq2;\n      return this;\n   }\n   reference operator*() {\n      if ( seq1 != seq1end ) return *seq1;\n      else return *seq2;\n   }\n   pointer operator->() {\n      if ( seq1 != seq1end ) return &(*seq1);\n      else return &(*seq2);\n   }\n   bool operator==( concat_iterator const & rhs ) {\n      return seq1==rhs.seq1 && seq1end==rhs.seq2 \n          && seq2==rhs.seq2 && seq2end==rhs.seq2end;\n   }\n   bool operator!=( contact_iterator const & rhs ) {\n      return !(*this == rhs);\n   }\nprivate:\n   T1 seq1;\n   T1 seq1end;\n   T2 seq2;\n   T2 seq2end;\n};\n\ntemplate <typename T1, typename T2>\nconcat_iterator<T1,T2> concat_begin( T1 b1, T1 e1, T2 b2, T2 e2 )\n{\n   return concat_iterator<T1,T2>(b1,e1,b2,e2);\n}\ntemplate <typename T1, typename T2>\nconcat_iterator<T1,T2> concat_end( T1 b1, T1 e1, T2 b2, T2 e2 )\n{\n   return concat_iterator<T1,T2>(e1,e1,e2,e2);\n}