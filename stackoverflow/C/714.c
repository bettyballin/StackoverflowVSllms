int Columns;\nchar * Array[] = {"A", "B", "C", "D", "E", "F", "G"};\n\nint main (\n    int argc,\n    char ** argv\n) {\n    // Lets thest this with all Column sizes from 1 to 7\n    for (Columns = 1; Columns <= 7; Columns++) {\n\n        printf("Output when Columns is set to %d\n", Columns);\n\n        // This is hacky C for quickly get the number of entries\n        // in a static array, where size is known at compile time\n        int arraySize = sizeof(Array) / sizeof(Array[0]);\n\n        // How many rows we will have\n        int rows = arraySize / Columns;\n\n        // Below code is the same as (arraySize % Columns != 0), but\n        // it's almost always faster\n        if (Columns * rows != arraySize) {\n            // We might have lost one row by implicit rounding\n            // performed for integer division\n            rows++;\n        }\n\n        // Now we create a matrix large enough for rows * Columns\n        // references. Note that this array could be larger than arraySize!\n        char ** matrix = malloc(sizeof(char *) * rows * Columns);\n\n        // Something you only need in C, C# and Java do this automatically:\n        // Set all elements in the matrix to NULL(null) references\n        memset(matrix, 0, sizeof(char *) * rows * Columns );\n\n        // We fill up the matrix from top to bottom and then from\n        // left to right; the order how we fill it up is very important\n        int matrixX;\n        int matrixY;\n        int index = 0;\n        for (matrixX = 0; matrixX < Columns; matrixX++) {\n            for (matrixY = 0; matrixY < rows; matrixY++) {\n                // In case we just have enough elements left to only\n                // fill up the first row of the matrix and we are not\n                // in this first row, do nothing.\n                if (arraySize + matrixX + 1 - (index + Columns) == 0 &&\n                        matrixY != 0) {\n                    continue;\n                }\n\n                // We just copy the next element normally\n                matrix[matrixY + matrixX * rows] = Array[index];\n                index++;\n                //arraySize--;\n            }\n        }\n\n        // Print the matrix exactly like you'd expect a matrix to be\n        // printed to screen, that is from left to right and top to bottom;\n        // Note: That is not the order how we have written it,\n        // watch the order of the for-loops!\n        for (matrixY = 0; matrixY < rows; matrixY++) {\n            for (matrixX = 0; matrixX < Columns; matrixX++) {\n                // Skip over unset references\n                if (matrix[matrixY + matrixX * rows] == NULL)\n                    continue;\n\n                printf("%s", matrix[matrixY + matrixX * rows]);\n            }\n            // Next row in output\n            printf("\n");\n        }\n        printf("\n");\n\n        // Free up unused memory\n        free(matrix);\n    }   \n    return 0;\n}