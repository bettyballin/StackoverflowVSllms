!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!Code originally from /http://www.openasthra.com/c-tidbits/printing-binary-trees-in-ascii/\n!!! Just saved it, cause the website is down.\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nPrinting Binary Trees in Ascii\n\nHere we are not going to discuss what binary trees are (please refer this, if you are looking for binary search trees), or their operations but printing them in ascii.\n\nThe below routine prints tree in ascii for a given Tree representation which contains list of nodes, and node structure is this\n\n    struct Tree \n    {\n      Tree * left, * right;\n      int element;\n    };\n\nThis pic illustrates what the below routine does on canvas..\nascii tree\n\nHere is the printing routine..\n\n    b5855d39a6b8a2735ddcaa04a404c125001 \n\nAuxiliary routines..\n\n    //This function prints the given level of the given tree, assuming\n    //that the node has the given x cordinate.\n    void print_level(asciinode *node, int x, int level) \n    {\n      int i, isleft;\n      if (node == NULL) return;\n      isleft = (node->parent_dir == -1);\n      if (level == 0) \n      {\n        for (i=0; i<(x-print_next-((node->lablen-isleft)/2)); i++) \n        {\n          printf(" ");\n        }\n        print_next += i;\n        printf("%s", node->label);\n        print_next += node->lablen;\n      } \n      else if (node->edge_length >= level) \n      {\n        if (node->left != NULL) \n        {\n          for (i=0; i<(x-print_next-(level)); i++) \n          {\n            printf(" ");\n          }\n          print_next += i;\n          printf("/");\n          print_next++;\n        }\n        if (node->right != NULL) \n        {\n          for (i=0; i<(x-print_next+(level)); i++) \n          {\n            printf(" ");\n          }\n          print_next += i;\n          printf("\\");\n          print_next++;\n        }\n      } \n      else \n      {\n        print_level(node->left, \n                    x-node->edge_length-1, \n                    level-node->edge_length-1);\n        print_level(node->right, \n                    x+node->edge_length+1, \n                    level-node->edge_length-1);\n      }\n    }\n\n\n    //This function fills in the edge_length and \n    //height fields of the specified tree\n    void compute_edge_lengths(asciinode *node) \n    {\n      int h, hmin, i, delta;\n      if (node == NULL) return;\n      compute_edge_lengths(node->left);\n      compute_edge_lengths(node->right);\n\n      /* first fill in the edge_length of node */\n      if (node->right == NULL && node->left == NULL) \n      {\n        node->edge_length = 0;\n      } \n      else \n      {\n        if (node->left != NULL) \n        {\n          for (i=0; i<node->left->height && i < MAX_HEIGHT; i++) \n          {\n            rprofile[i] = -INFINITY;\n          }\n          compute_rprofile(node->left, 0, 0);\n          hmin = node->left->height;\n        } \n        else \n        {\n          hmin = 0;\n        }\n        if (node->right != NULL) \n        {\n          for (i=0; i<node->right->height && i < MAX_HEIGHT; i++) \n          {\n            lprofile[i] = INFINITY;\n          }\n          compute_lprofile(node->right, 0, 0);\n          hmin = MIN(node->right->height, hmin);\n        } \n        else \n        {\n          hmin = 0;\n        }\n        delta = 4;\n        for (i=0; i<hmin; i++) \n        {\n          delta = MAX(delta, gap + 1 + rprofile[i] - lprofile[i]);\n        }\n\n        //If the node has two children of height 1, then we allow the\n        //two leaves to be within 1, instead of 2 \n        if (((node->left != NULL && node->left->height == 1) ||\n              (node->right != NULL && node->right->height == 1))&&delta>4) \n        {\n          delta--;\n        }\n\n        node->edge_length = ((delta+1)/2) - 1;\n      }\n\n      //now fill in the height of node\n      h = 1;\n      if (node->left != NULL) \n      {\n        h = MAX(node->left->height + node->edge_length + 1, h);\n      }\n      if (node->right != NULL) \n      {\n        h = MAX(node->right->height + node->edge_length + 1, h);\n      }\n      node->height = h;\n    }\n\n    asciinode * build_ascii_tree_recursive(Tree * t) \n    {\n      asciinode * node;\n\n      if (t == NULL) return NULL;\n\n      node = malloc(sizeof(asciinode));\n      node->left = build_ascii_tree_recursive(t->left);\n      node->right = build_ascii_tree_recursive(t->right);\n\n      if (node->left != NULL) \n      {\n        node->left->parent_dir = -1;\n      }\n\n      if (node->right != NULL) \n      {\n        node->right->parent_dir = 1;\n      }\n\n      sprintf(node->label, "%d", t->element);\n      node->lablen = strlen(node->label);\n\n      return node;\n    }\n\n\n    //Copy the tree into the ascii node structre\n    asciinode * build_ascii_tree(Tree * t) \n    {\n      asciinode *node;\n      if (t == NULL) return NULL;\n      node = build_ascii_tree_recursive(t);\n      node->parent_dir = 0;\n      return node;\n    }\n\n    //Free all the nodes of the given tree\n    void free_ascii_tree(asciinode *node) \n    {\n      if (node == NULL) return;\n      free_ascii_tree(node->left);\n      free_ascii_tree(node->right);\n      free(node);\n    }\n\n    //The following function fills in the lprofile array for the given tree.\n    //It assumes that the center of the label of the root of this tree\n    //is located at a position (x,y).  It assumes that the edge_length\n    //fields have been computed for this tree.\n    void compute_lprofile(asciinode *node, int x, int y) \n    {\n      int i, isleft;\n      if (node == NULL) return;\n      isleft = (node->parent_dir == -1);\n      lprofile[y] = MIN(lprofile[y], x-((node->lablen-isleft)/2));\n      if (node->left != NULL) \n      {\n        for (i=1; i <= node->edge_length && y+i < MAX_HEIGHT; i++) \n        {\n          lprofile[y+i] = MIN(lprofile[y+i], x-i);\n        }\n      }\n      compute_lprofile(node->left, x-node->edge_length-1, y+node->edge_length+1);\n      compute_lprofile(node->right, x+node->edge_length+1, y+node->edge_length+1);\n    }\n\n    void compute_rprofile(asciinode *node, int x, int y) \n    {\n      int i, notleft;\n      if (node == NULL) return;\n      notleft = (node->parent_dir != -1);\n      rprofile[y] = MAX(rprofile[y], x+((node->lablen-notleft)/2));\n      if (node->right != NULL) \n      {\n        for (i=1; i <= node->edge_length && y+i < MAX_HEIGHT; i++) \n        {\n          rprofile[y+i] = MAX(rprofile[y+i], x+i);\n        }\n      }\n      compute_rprofile(node->left, x-node->edge_length-1, y+node->edge_length+1);\n      compute_rprofile(node->right, x+node->edge_length+1, y+node->edge_length+1);\n    }\n\nHere is the asciii tree structureâ€¦\n\n    struct asciinode_struct\n    {\n      asciinode * left, * right;\n\n      //length of the edge from this node to its children\n      int edge_length; \n\n      int height;      \n\n      int lablen;\n\n      //-1=I am left, 0=I am root, 1=right   \n      int parent_dir;   \n\n      //max supported unit32 in dec, 10 digits max\n      char label[11];  \n    };