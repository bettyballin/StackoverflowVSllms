#pragma once\n#include <tchar.h>\n#include <windows.h>\n#include <sstream>\n#include <boost/noncopyable.hpp>\n\nnamespace scope_timer {\n    class time_collector : boost::noncopyable {\n        __int64 total;\n        LARGE_INTEGER start;\n        size_t times;\n        const TCHAR* name;\n\n        double cpu_frequency()\n        { // cache the CPU frequency, which doesn't change.\n            static double ret = 0; // store as double so devision later on is floating point and not truncating\n            if (ret == 0) {\n                LARGE_INTEGER freq;\n                QueryPerformanceFrequency(&freq);\n                ret = static_cast<double>(freq.QuadPart);\n            }\n            return ret;\n        }\n        bool in_use;\n\n    public:\n        time_collector(const TCHAR* n)\n            : times(0)\n            , name(n)\n            , total(0)\n            , start(LARGE_INTEGER())\n            , in_use(false)\n        {\n        }\n\n        ~time_collector()\n        {\n            std::basic_ostringstream<TCHAR> msg;\n            msg << _T("scope_timer> ") <<  name << _T(" called: ");\n\n            double seconds = total / cpu_frequency();\n            double average = seconds / times;\n\n            msg << times << _T(" times total time: ") << seconds << _T(" seconds  ")\n                << _T(" (avg ") << average <<_T(")\n");\n            OutputDebugString(msg.str().c_str());\n        }\n\n        void add_time(__int64 ticks)\n        {\n            total += ticks;\n            ++times;\n            in_use = false;\n        }\n\n        bool aquire()\n        {\n            if (in_use)\n                return false;\n            in_use = true;\n            return true;\n        }\n    };\n\n    class one_time : boost::noncopyable {\n        LARGE_INTEGER start;\n        time_collector* collector;\n    public:\n        one_time(time_collector& tc)\n        {\n            if (tc.aquire()) {\n                collector = &tc;\n                QueryPerformanceCounter(&start);\n            }\n            else\n                collector = 0;\n        }\n\n        ~one_time()\n        {\n            if (collector) {\n                LARGE_INTEGER end;\n                QueryPerformanceCounter(&end);\n                collector->add_time(end.QuadPart - start.QuadPart);\n            }\n        }\n    };\n}\n\n// Usage TIME_THIS_SCOPE(XX); where XX is a C variable name (can begin with a number)\n#define TIME_THIS_SCOPE(name) \\n    static scope_timer::time_collector st_time_collector_##name(_T(#name)); \\n    scope_timer::one_time st_one_time_##name(st_time_collector_##name)