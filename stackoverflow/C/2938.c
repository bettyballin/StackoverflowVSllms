/* rawcopy -- pure C, system calls only, copy argv[1] to argv[2] */\n\n/* This is a test program which simply copies from file to file using\n * only system calls (section 2 of the manual.)\n *\n * Compile:\n *\n *      gcc -Wall -DBUFSIZ=1024 -o rawcopy rawcopy.c\n *\n * If DIRTY is defined, then errors are interpreted with perror(3).\n * This is ifdef'd so that the CLEAN version is free of stdio.  For\n * convenience I'm using BUFSIZ from stdio.h; to compile CLEAN just\n * use the value from your stdio.h in place of 1024 above.\n *\n * Compile DIRTY:\n *\n *      gcc -DDIRTY -Wall -o rawcopy rawcopy.c\n *\n */\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#if defined(DIRTY)\n#   if defined(BUFSIZ)\n#       error "Don't define your own BUFSIZ when DIRTY"\n#   endif\n#   include <stdio.h>\n#   define PERROR perror(argv[0])\n#else\n#   define CLEAN\n#   define PERROR\n#   if ! defined(BUFSIZ)\n#       error "You must define your own BUFSIZ with -DBUFSIZ=<number>"\n#   endif\n#endif\n\nchar * buffer[BUFSIZ];          /* by definition stdio BUFSIZ should\n                                   be optimal size for read/write */\n\nextern int errno ;              /* I/O errors */\n\nint main(int argc, char * argv[]) {\n    int fdi, fdo ;              /* Input/output file descriptors */\n    ssize_t len ;               /* length to read/write */\n    if(argc != 3){\n        PERROR;\n        exit(errno);\n    }\n\n    /* Open the files, returning perror errno as the exit value if fails. */\n    if((fdi = open(argv[1],O_RDONLY)) == -1){\n        PERROR;\n        exit(errno);\n    }\n    if((fdo = open(argv[2], O_WRONLY|O_CREAT)) == -1){\n        PERROR;\n        exit(errno);\n    }\n\n    /* copy BUFSIZ bytes (or total read on last block) fast as you\n       can. */\n    while((len = read(fdi, (void *) buffer, BUFSIZ)) > -1){\n        if(len == -1){\n            PERROR;\n            exit(errno);\n        }\n        if(write(fdo, (void*)buffer, len) == -1){\n            PERROR;\n            exit(errno);\n        }\n    }\n    /* close and fsync the files */\n    if(fsync(fdo) ==-1){\n        PERROR;\n        exit(errno);\n    }\n    if(close(fdo) == -1){\n        PERROR;\n        exit(errno);\n    }\n    if(close(fdi) == -1){\n        PERROR;\n        exit(errno);\n    }\n\n    /* if it survived to here, all worked. */\n    exit(0);\n}