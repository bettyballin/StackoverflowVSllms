#define KmPerDegree         111.12000071117\n#define DegreesPerKm        (1.0/KmPerDegree)\n#define PI                  M_PI\n#define TwoPI               (M_PI+M_PI)\n#define HalfPI              M_PI_2\n#define RadiansPerDegree    (PI/180.0)\n#define DegreesPerRadian    (180.0/PI)\n#define copysign(x,y)       (((y)<0.0)?-fabs(x):fabs(x))\n#define NGT1(x)             (fabs(x)>1.0?copysign(1.0,x):(x))\n#define ArcCos(x)           (fabs(x)>1?quiet_nan():acos(x))\n#define hav(x)              ((1.0-cos(x))*0.5)              /* haversine */\n#define ahav(x)             (ArcCos(NGT1(1.0-((x)*2.0))))   /* arc haversine */\n#define sec(x)              (1.0/cos(x))                    /* secant */\n#define csc(x)              (1.0/sin(x))                    /* cosecant */\n\n/*\n**  GreatCirclePos() --\n**\n**  Compute ending position from course and great-circle distance.\n**\n**  Given a starting latitude (decimal), the initial great-circle\n**  course and a distance along the course track, compute the ending\n**  position (decimal latitude and longitude).\n**  This is the inverse function to GreatCircleDist).\n*/\nvoid\nGreatCirclePos(dist, course, slt, slg, xlt, xlg)\n    double  dist;   /* -> great-circle distance (km) */\n    double  course; /* -> initial great-circle course (degrees) */\n    double  slt;    /* -> starting decimal latitude (-S) */\n    double  slg;    /* -> starting decimal longitude(-W) */\n    double  *xlt;   /* <- ending decimal latitude (-S) */\n    double  *xlg;   /* <- ending decimal longitude(-W) */\n{\n    double  c, d, dLo, L1, L2, coL1, coL2, l;\n\n    if (dist > KmPerDegree*180.0) {\n        course -= 180.0;\n        if (course < 0.0) course += 360.0;\n        dist    = KmPerDegree*360.0-dist;\n    }\n    if (course > 180.0) course -= 360.0;\n    c    = course*RadiansPerDegree;\n    d    = dist*DegreesPerKm*RadiansPerDegree;\n    L1   = slt*RadiansPerDegree;\n    slg *= RadiansPerDegree;\n    coL1 = (90.0-slt)*RadiansPerDegree;\n    coL2 = ahav(hav(c)/(sec(L1)*csc(d))+hav(d-coL1));\n    L2   = HalfPI-coL2;\n    l    = L2-L1;\n    if ((dLo=(cos(L1)*cos(L2))) != 0.0)\n        dLo  = ahav((hav(d)-hav(l))/dLo);\n    if (c < 0.0) dLo = -dLo;\n    slg += dLo;\n    if (slg < -PI)\n        slg += TwoPI;\n    else if (slg > PI)\n        slg -= TwoPI;\n\n    *xlt = L2*DegreesPerRadian;\n    *xlg = slg*DegreesPerRadian;\n\n} /* GreatCirclePos() */