// Need to link with Iphlpapi.lib and Ws2_32.lib\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include <iphlpapi.h>\n#include <stdio.h>\n\n#pragma comment(lib, "iphlpapi.lib")\n#pragma comment(lib, "ws2_32.lib")\n\n#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))\n#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))\n\n/* Note: could also use malloc() and free() */\n\nint main()\n{\n\n    // Declare and initialize variables\n    PMIB_TCPTABLE pTcpTable;\n    DWORD dwSize = 0;\n    DWORD dwRetVal = 0;\n\n    char szLocalAddr[128];\n    char szRemoteAddr[128];\n\n    struct in_addr IpAddr;\n\n    int i;\n\n    pTcpTable = (MIB_TCPTABLE *) MALLOC(sizeof (MIB_TCPTABLE));\n    if (pTcpTable == NULL) {\n        printf("Error allocating memory\n");\n        return 1;\n    }\n\n    dwSize = sizeof (MIB_TCPTABLE);\n// Make an initial call to GetTcpTable to\n// get the necessary size into the dwSize variable\n    if ((dwRetVal = GetTcpTable(pTcpTable, &dwSize, TRUE)) ==\n        ERROR_INSUFFICIENT_BUFFER) {\n        FREE(pTcpTable);\n        pTcpTable = (MIB_TCPTABLE *) MALLOC(dwSize);\n        if (pTcpTable == NULL) {\n            printf("Error allocating memory\n");\n            return 1;\n        }\n    }\n// Make a second call to GetTcpTable to get\n// the actual data we require\n    if ((dwRetVal = GetTcpTable(pTcpTable, &dwSize, TRUE)) == NO_ERROR) {\n        printf("\tNumber of entries: %d\n", (int) pTcpTable->dwNumEntries);\n        for (i = 0; i < (int) pTcpTable->dwNumEntries; i++) {\n            IpAddr.S_un.S_addr = (u_long) pTcpTable->table[i].dwLocalAddr;\n            strcpy_s(szLocalAddr, sizeof (szLocalAddr), inet_ntoa(IpAddr));\n            IpAddr.S_un.S_addr = (u_long) pTcpTable->table[i].dwRemoteAddr;\n            strcpy_s(szRemoteAddr, sizeof (szRemoteAddr), inet_ntoa(IpAddr));\n\n            printf("\n\tTCP[%d] State: %ld - ", i,\n                   pTcpTable->table[i].dwState);\n            switch (pTcpTable->table[i].dwState) {\n            case MIB_TCP_STATE_CLOSED:\n                printf("CLOSED\n");\n                break;\n            case MIB_TCP_STATE_LISTEN:\n                printf("LISTEN\n");\n                break;\n            case MIB_TCP_STATE_SYN_SENT:\n                printf("SYN-SENT\n");\n                break;\n            case MIB_TCP_STATE_SYN_RCVD:\n                printf("SYN-RECEIVED\n");\n                break;\n            case MIB_TCP_STATE_ESTAB:\n                printf("ESTABLISHED\n");\n                break;\n            case MIB_TCP_STATE_FIN_WAIT1:\n                printf("FIN-WAIT-1\n");\n                break;\n            case MIB_TCP_STATE_FIN_WAIT2:\n                printf("FIN-WAIT-2 \n");\n                break;\n            case MIB_TCP_STATE_CLOSE_WAIT:\n                printf("CLOSE-WAIT\n");\n                break;\n            case MIB_TCP_STATE_CLOSING:\n                printf("CLOSING\n");\n                break;\n            case MIB_TCP_STATE_LAST_ACK:\n                printf("LAST-ACK\n");\n                break;\n            case MIB_TCP_STATE_TIME_WAIT:\n                printf("TIME-WAIT\n");\n                break;\n            case MIB_TCP_STATE_DELETE_TCB:\n                printf("DELETE-TCB\n");\n                break;\n            default:\n                printf("UNKNOWN dwState value\n");\n                break;\n            }\n            printf("\tTCP[%d] Local Addr: %s\n", i, szLocalAddr);\n            printf("\tTCP[%d] Local Port: %d \n", i,\n                   ntohs((u_short)pTcpTable->table[i].dwLocalPort));\n            printf("\tTCP[%d] Remote Addr: %s\n", i, szRemoteAddr);\n            printf("\tTCP[%d] Remote Port: %d\n", i,\n                   ntohs((u_short)pTcpTable->table[i].dwRemotePort));\n        }\n    } else {\n        printf("\tGetTcpTable failed with %d\n", dwRetVal);\n        FREE(pTcpTable);\n        return 1;\n    }\n\n    return 0;    \n}