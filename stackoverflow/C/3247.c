#include <sys/ptrace.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <linux/user.h>\n#include <sys/syscall.h>   /* For SYS_write etc */\nint main()\n{   pid_t child;\n    long orig_eax, eax;\n    long params[3];\n    int status;\n    int insyscall = 0;\n    child = fork();\n    if(child == 0) {\n        ptrace(PTRACE_TRACEME, 0, NULL, NULL);\n        execl("/bin/ls", "ls", NULL);\n    }\n    else {\n       while(1) {\n          wait(&status);\n          if(WIFEXITED(status))\n              break;\n          orig_eax = ptrace(PTRACE_PEEKUSER,\n                     child, 4 * ORIG_EAX, NULL);\n          if(orig_eax == SYS_write) {\n             if(insyscall == 0) {\n                /* Syscall entry */\n                insyscall = 1;\n                params[0] = ptrace(PTRACE_PEEKUSER,\n                                   child, 4 * EBX,\n                                   NULL);\n                params[1] = ptrace(PTRACE_PEEKUSER,\n                                   child, 4 * ECX,\n                                   NULL);\n                params[2] = ptrace(PTRACE_PEEKUSER,\n                                   child, 4 * EDX,\n                                   NULL);\n                printf("Write called with "\n                       "%ld, %ld, %ld\n",\n                       params[0], params[1],\n                       params[2]);\n                }\n          else { /* Syscall exit */\n                eax = ptrace(PTRACE_PEEKUSER,\n                             child, 4 * EAX, NULL);\n                    printf("Write returned "\n                           "with %ld\n", eax);\n                    insyscall = 0;\n                }\n            }\n            ptrace(PTRACE_SYSCALL,\n                   child, NULL, NULL);\n        }\n    }\n    return 0;\n}