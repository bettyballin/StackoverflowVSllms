Imports System.Math\n\nPublic Class TotientSerialCalculator\n    'Implements an extremely efficient Serial Totient(phi) calculator   '\n    '  This implements an optimized windowed Sieve of Eratosthenes.  The'\n    ' window size is set at Sqrt(N) both to optimize collecting and     '\n    ' applying all of the Primes below Sqrt(N), and to minimize         '\n    ' window-turning overhead.                                          '\n    '                                                                   '\n    ' CPU complexity is O( N * Log(Log(N)) ), which is virtually linear.'\n    '                                                                   '\n    ' MEM Complexity is O( Sqrt(N) ).                                   '\n    '                                                                   '\n    ' This is probalby the ideal combination, as any attempt to further '\n    'reduce memory will almost certainly result in disproportionate increases'\n    'in CPU complexity, and vice-versa.                                 '\n\n    Structure NumberFactors\n        Dim UnFactored As Long  'the part of the number that still needs to be factored'\n        Dim Phi As Long 'the totient value progressively calculated'\n        '               (equals total numbers less than N that are CoPrime to N)'\n        'MEM = 8 bytes each'\n    End Structure\n\n    Private ReportInterval As Long\n    Private PrevLast As Long     'the last value in the previous window'\n    Private FirstValue As Long   'the first value in this windows range'\n    Private WindowSize As Long\n    Private LastValue As Long    'the last value in this windows range'\n    Private NextFirst As Long    'the first value in the next window'\n\n    'Array that stores all of the NumberFactors in the current window.'\n    ' this is the primary memory consumption for the class and it'\n    ' is 16 * Sqrt(N) Bytes, which is O(Sqrt(N)).'\n    Public Numbers() As NumberFactors\n    ' For N=10^12 (1 trilion), this will be 16MB, which should be bearable anywhere.'\n    '(note that the Primes() array is a secondary memory consumer'\n    '  at O(pi(Sqrt(N)), which will be within 10x of O(Sqrt(N)))'\n\n    Public Event EmitTotientPair(ByVal k As Long, ByVal Phi As Long)\n\n    '===== The Routine To Call: ========================'\n    Public Sub EmitTotientPairsToN(ByVal N As Long)\n        'Routine to Emit Totient pairs {k, Phi(k)} for k = 1 to N'\n        '   2009-07-14, RBarryYoung, Created.'\n        Dim i As Long\n        Dim k As Long   'the current number being factored'\n        Dim p As Long   'the current prime factor'\n\n        'Establish the Window frame:'\n        '   note: WindowSize is the critical value that controls both memory'\n        '    usage and CPU consumption and must be SQRT(N) for it to work optimally.'\n        WindowSize = Ceiling(Sqrt(CDbl(N)))\n        ReDim Numbers(0 To WindowSize - 1)\n\n        'Initialize the first window:'\n        MapWindow(1)\n        Dim IsFirstWindow As Boolean = True\n\n        'adjust this to control how often results are show'\n        ReportInterval = N / 100\n\n        'Allocate the primes array to hold the primes list:'\n        '  Only primes <= SQRT(N) are needed for factoring'\n        '  PiMax(X) is a Max estimate of the number of primes <= X'\n        Dim Primes() As Long, PrimeIndex As Long, NextPrime As Long\n        'init the primes list and its pointers'\n        ReDim Primes(0 To PiMax(WindowSize) - 1)\n        Primes(0) = 2   '"prime" the primes list with the first prime'\n        NextPrime = 1\n\n        'Map (and Remap) the window with Sqrt(N) numbers, Sqrt(N) times to'\n        ' sequentially map all of the numbers <= N.'\n        Do\n            'Sieve the primes across the current window'\n            PrimeIndex = 0\n            'note: cant use enumerator for the loop below because NextPrime'\n            ' changes during the first window as new primes <= SQRT(N) are accumulated'\n            Do While PrimeIndex < NextPrime\n                'get the next prime in the list'\n                p = Primes(PrimeIndex)\n                'find the first multiple of (p) in the current window range'\n                k = PrevLast + p - (PrevLast Mod p)\n\n                Do\n                    With Numbers(k - FirstValue)\n                        .UnFactored = .UnFactored \ p   'always works the first time'\n                        .Phi = .Phi * (p - 1)           'Phi = PRODUCT( (Pi-1)*Pi^(Ei-1) )'\n                        'The loop test that follows is probably the central CPU overhead'\n                        ' I believe that it is O(N*Log(Log(N)), which is virtually O(N)'\n                        ' ( for instance at N = 10^12, Log(Log(N)) = 3.3 )'\n                        Do While (.UnFactored Mod p) = 0\n                            .UnFactored = .UnFactored \ p\n                            .Phi = .Phi * p\n                        Loop\n                    End With\n\n                    'skip ahead to the next multiple of p: '\n                    '(this is what makes it so fast, never have to try prime factors that dont apply)'\n                    k += p\n                    'repeat until we step out of the current window:'\n                Loop While k < NextFirst\n\n                'if this is the first window, then scan ahead for primes'\n                If IsFirstWindow Then\n                    For i = Primes(NextPrime - 1) + 1 To p ^ 2 - 1  'the range of possible new primes'\n                        'Dont go beyond the first window'\n                        If i >= WindowSize Then Exit For\n                        If Numbers(i - FirstValue).UnFactored = i Then\n                            'this is a prime less than SQRT(N), so add it to the list.'\n                            Primes(NextPrime) = i\n                            NextPrime += 1\n                        End If\n                    Next\n                End If\n\n                PrimeIndex += 1     'move to the next prime'\n            Loop\n\n            'Now Finish & Emit each one'\n            For k = FirstValue To LastValue\n                With Numbers(k - FirstValue)\n                    'Primes larger than Sqrt(N) will not be finished: '\n                    If .UnFactored > 1 Then\n                        'Not done factoring, must be an large prime factor remaining: '\n                        .Phi = .Phi * (.UnFactored - 1)\n                        .UnFactored = 1\n                    End If\n\n                    'Emit the value pair: (k, Phi(k)) '\n                    EmitPhi(k, .Phi)\n                End With\n            Next\n\n            're-Map to the next window '\n            IsFirstWindow = False\n            MapWindow(NextFirst)\n        Loop While FirstValue <= N\n    End Sub\n\n    Sub EmitPhi(ByVal k As Long, ByVal Phi As Long)\n        'just a placeholder for now, that raises an event to the display form' \n        ' periodically for reporting purposes.  Change this to do the actual'\n        ' emitting.'\n        If (k Mod ReportInterval) = 0 Then\n            RaiseEvent EmitTotientPair(k, Phi)\n        End If\n    End Sub\n\n    Public Sub MapWindow(ByVal FirstVal As Long)\n        'Efficiently reset the window so that we do not have to re-allocate it.'\n\n        'init all of the boundary values'\n        FirstValue = FirstVal\n        PrevLast = FirstValue - 1\n        NextFirst = FirstValue + WindowSize\n        LastValue = NextFirst - 1\n\n        'Initialize the Numbers prime factor arrays'\n        Dim i As Long\n        For i = 0 To WindowSize - 1\n            With Numbers(i)\n                .UnFactored = i + FirstValue 'initially equal to the number itself'\n                .Phi = 1        'starts at mulplicative identity(1)'\n            End With\n        Next\n    End Sub\n\n    Function PiMax(ByVal x As Long) As Long\n        'estimate of pi(n) == {primes <= (n)} that is never less'\n        ' than the actual number of primes. (from P. Dusart, 1999)'\n        Return (x / Log(x)) * (1.0 + 1.2762 / Log(x))\n    End Function\nEnd Class