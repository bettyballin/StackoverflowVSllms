<?php\n\nini_set( "display_errors", "on" );\nerror_reporting( E_ALL );\n\ninterface ILexer\n{\n    public function execute( $str );\n    public function getTokens();\n}\n\ninterface IParser\n{\n    public function __construct( iLexer $lexer );\n    public function parse( $input );\n    public function addToken( $token );\n}\n\nclass GoogleQueryLexer implements ILexer\n{\n    private $tokenStack = array();\n\n    public function execute( $str )\n    {\n        $chars = str_split( $str );\n        foreach ( $chars as $char )\n        {\n            //  add to self::$tokenStack per your rules\n        }\n\n        //'("used cars" OR "new cars") -ford -mistubishi'\n        $this->tokenStack = array(\n                '('\n            ,   'used cars'\n            ,   'or new cars'\n            ,   ')'\n            ,   '-ford'\n            ,   '-mitsubishi'\n        );\n    }\n\n    public function getTokens()\n    {\n        return $this->tokenStack;\n    }\n}\n\nclass GoogleQueryParser implements IParser\n{\n    protected $lexer;\n\n    public function __construct( iLexer $lexer )\n    {\n        $this->lexer = $lexer;\n    }\n\n    public function addToken( $token )\n    {\n        $this->tokenStack[] = $token;\n    }\n\n    public function parse( $input )\n    {\n        $this->lexer->execute( $input );\n        $tokens = $this->lexer->getTokens();\n\n        $expression = new QueryExpression();\n\n        foreach ( $tokens as $token )\n        {\n            $expression = $this->processToken( $token, $expression );\n        }\n\n        return $expression;\n    }\n\n    protected function processToken( $token, QueryExpression $expression )\n    {\n        switch ( $token )\n        {\n            case '(':\n                return $expression->initiateSubExpression();\n                break;\n            case ')':\n                return $expression->getParentExpression();\n                break;\n            default:\n                $modifier   = $token[0];\n                $phrase     = substr( $token, 1 );\n                switch ( $modifier )\n                {\n                    case '-':\n                        $expression->addExclusionPhrase( $phrase );\n                        break;\n                    case '+':\n                        $expression->addPhrase( $phrase );\n                        break;\n                    default:\n                        $operator   = trim( substr( $token, 0, strpos( $token, ' ' ) ) );\n                        $phrase     = trim( substr( $token, strpos( $token, ' ' ) ) );\n                        switch ( strtolower( $operator ) )\n                        {\n                            case 'and':\n                                $expression->addAndPhrase( $phrase );\n                                break;\n                            case 'or':\n                                $expression->addOrPhrase( $phrase );\n                                break;\n                            default:\n                                $expression->addPhrase( $token );\n                        }\n                }\n        }\n        return $expression;\n    }\n}\n\nclass QueryExpression\n{\n    protected $phrases = array();\n    protected $subExpressions = array();\n    protected $parent;\n\n    public function __construct( $parent=null )\n    {\n        $this->parent = $parent;\n    }\n\n    public function initiateSubExpression()\n    {\n        $expression = new self( $this );\n        $this->subExpressions[] = $expression;\n        return $expression;\n    }\n\n    public function getPhrases()\n    {\n        return $this->phrases;\n    }\n\n    public function getSubExpressions()\n    {\n        return $this->subExpressions;\n    }\n\n    public function getParentExpression()\n    {\n        return $this->parent;\n    }\n\n    protected function addQueryPhrase( QueryPhrase $phrase )\n    {\n        $this->phrases[] = $phrase;\n    }\n\n    public function addPhrase( $input )\n    {\n        $this->addQueryPhrase( new QueryPhrase( $input ) );\n    }\n\n    public function addOrPhrase( $input )\n    {\n        $this->addQueryPhrase( new QueryPhrase( $input, QueryPhrase::MODE_OR ) );\n    }\n\n    public function addAndPhrase( $input )\n    {\n        $this->addQueryPhrase( new QueryPhrase( $input, QueryPhrase::MODE_AND ) );\n    }\n\n    public function addExclusionPhrase( $input )\n    {\n        $this->addQueryPhrase( new QueryPhrase( $input, QueryPhrase::MODE_EXCLUDE ) );\n    }\n}\n\nclass QueryPhrase\n{\n    const MODE_DEFAULT = 1;\n    const MODE_OR = 2;\n    const MODE_AND = 3;\n    const MODE_EXCLUDE = 4;\n\n    protected $phrase;\n    protected $mode;\n\n    public function __construct( $input, $mode=self::MODE_DEFAULT )\n    {\n        $this->phrase = $input;\n        $this->mode = $mode;\n    }\n\n    public function getMode()\n    {\n        return $this->mode;\n    }\n\n    public function __toString()\n    {\n        return $this->phrase;\n    }\n}\n\nclass TsqueryBuilder\n{\n    protected $expression;\n    protected $query;\n\n    public function __construct( QueryExpression $expression )\n    {\n        $this->query = trim( $this->processExpression( $expression ), ' &|' );\n    }\n\n    public function getResult()\n    {\n        return $this->query;\n    }\n\n    protected function processExpression( QueryExpression $expression )\n    {\n        $query = '';\n        $phrases = $expression->getPhrases();\n        $subExpressions = $expression->getSubExpressions();\n\n        foreach ( $phrases as $phrase )\n        {\n            $format = "'%s' ";\n            switch ( $phrase->getMode() )\n            {\n                case QueryPhrase::MODE_AND :\n                    $format = "& '%s' ";\n                    break;\n                case QueryPhrase::MODE_OR :\n                    $format = "| '%s' ";\n                    break;\n                case QueryPhrase::MODE_EXCLUDE :\n                    $format = "& !'%s' ";\n                    break;\n            }\n            $query .= sprintf( $format, str_replace( "'", "\\'", $phrase ) );\n        }\n\n        foreach ( $subExpressions as $subExpression )\n        {\n            $query .= "& (" . $this->processExpression( $subExpression ) . ")";\n        }\n        return $query;\n    }\n}\n\n$parser = new GoogleQueryParser( new GoogleQueryLexer() );\n\n$queryBuilder = new TsqueryBuilder( $parser->parse( '("used cars" OR "new cars") -ford -mistubishi' ) );\n\necho $queryBuilder->getResult();