$(function() {\n  $.fn.pmaker = function() {\n    var brs = 0;\n    var nodes = [];\n\n    function makeP()\n    {\n      // only bother doing this if we have nodes to stick into a P\n      if (nodes.length) {\n        var p = $("<p/>");\n        p.insertBefore(nodes[0]);  // insert a new P before the content\n        p.append(nodes); // add the children        \n        nodes = [];\n      }\n      brs=0;\n    }\n\n    this.contents().each(function() {    \n      if (this.nodeType == 3) // text node \n      {\n        // if the text has non whitespace - reset the BR counter\n        if (/\S+/.test(this.data)) {\n          nodes.push(this);\n          brs = 0;\n        }\n      } else if (this.nodeType == 1) {\n        if (/br/i.test(this.tagName)) {\n          if (++brs == 2) {\n            $(this).remove(); // remove this BR from the dom\n            $(nodes.pop()).remove(); // delete the previous BR from the array and the DOM\n            makeP();\n          } else {\n            nodes.push(this);\n          }\n        } else if (/^(?:p)$/i.test(this.tagName)) {\n          // these tags for the P break but dont scan within\n          makeP();\n        } else if (/^(?:div)$/i.test(this.tagName)) {\n          // force a P break and scan within\n          makeP();\n          $(this).pmaker();\n        } else {\n          brs = 0; // some other tag - reset brs.\n          nodes.push(this); // add the node \n          // specific nodes to not peek inside of - inline tags\n          if (!(/^(?:b|i|strong|em|span|u)$/i.test(this.tagName))) {\n            $(this).pmaker(); // peek inside for P needs            \n          }\n        } \n      } \n    });\n    while ((brs--)>0) { // remove any extra BR's at the end\n      $(nodes.pop()).remove();\n    }\n    makeP();\n    return this;\n  };\n\n  // run it against something:\n  $(function(){ \n    $("#worker").pmaker();\n  });