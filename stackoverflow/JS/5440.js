<pre><script>\n\nvar fib = {};\n\n(function() {\n    var sqrt_5  = Math.sqrt(5),\n        phi     = (1 + sqrt_5) / 2;\n\n    fib.round = function(n) {\n        return Math.floor(Math.pow(phi, n) / sqrt_5 + 0.5);\n    };\n})();\n\n(function() {\n    fib.loop = function(n) {\n        var i = 0,\n            j = 1;\n\n        while(n--) {\n            var tmp = i;\n            i = j;\n            j += tmp;\n        }\n\n        return i;\n    };\n})();\n\n(function () {\n    var cache = [0, 1];\n\n    fib.loop_cached = function(n) {\n        if(n >= cache.length) {\n            for(var i = cache.length; i <= n; ++i)\n                cache[i] = cache[i - 1] + cache[i - 2];\n        }\n\n        return cache[n];\n    };\n})();\n\n(function() {\n    //Fibonacci sequence generator in JS\n    //Cobbled together by Salty\n    var m;\n    var odd = [[1,1],[1,0]];\n\n    function matrix(a,b) {\n        /*\n            Matrix multiplication\n            Strassen Algorithm\n            Only works with 2x2 matrices.\n        */\n        var c=[[0,0],[0,0]];\n        var m1=(a[0][0]+a[1][1])*(b[0][0]+b[1][1]);\n        var m2=(a[1][0]+a[1][1])*b[0][0];\n        var m3=a[0][0]*(b[0][1]-b[1][1]);\n        var m4=a[1][1]*(b[1][0]-b[0][0]);\n        var m5=(a[0][0]+a[0][1])*b[1][1];\n        var m6=(a[1][0]-a[0][0])*(b[0][0]+b[0][1]);\n        var m7=(a[0][1]-a[1][1])*(b[1][0]+b[1][1]);\n        c[0][0]=m1+m4-m5+m7;\n        c[0][1]=m3+m5;\n        c[1][0]=m2+m4;\n        c[1][1]=m1-m2+m3+m6;\n        return c;\n    }\n\n    function mat(n) {\n        if(n > 1) {\n            mat(n/2);\n            m = matrix(m,m);\n        }\n        m = (n%2<1) ? m : matrix(m,odd);\n    }\n\n    fib.matrix = function(n) {\n        m = [[1,0],[0,1]];\n        mat(n-1);\n        return m[0][0];\n    };\n})();\n\n(function() {\n    var a;\n\n    function square() {\n        var a00 = a[0][0],\n            a01 = a[0][1],\n            a10 = a[1][0],\n            a11 = a[1][1];\n\n        var a10_x_a01 = a10 * a01,\n            a00_p_a11 = a00 + a11;\n\n        a[0][0] = a10_x_a01 + a00 * a00;\n        a[0][1] = a00_p_a11 * a01;\n        a[1][0] = a00_p_a11 * a10;\n        a[1][1] = a10_x_a01 + a11 * a11;\n    }\n\n    function powPlusPlus() {\n        var a01 = a[0][1],\n            a11 = a[1][1];\n\n        a[0][1] = a[0][0];\n        a[1][1] = a[1][0];\n        a[0][0] += a01;\n        a[1][0] += a11;\n    }\n\n    function compute(n) {\n        if(n > 1) {\n            compute(n >> 1);\n            square();\n            if(n & 1)\n                powPlusPlus();\n        }\n    }\n\n    fib.matrix_optimised = function(n) {\n        if(n == 0)\n            return 0;\n\n        a = [[1, 1], [1, 0]];\n        compute(n - 1);\n\n        return a[0][0];\n    };\n})();\n\n(function() {\n    var cache = {};\n    cache[0] = [[1, 0], [0, 1]];\n    cache[1] = [[1, 1], [1, 0]];\n\n    function mult(a, b) {\n        return [\n            [a[0][0] * b[0][0] + a[0][1] * b[1][0],\n                a[0][0] * b[0][1] + a[0][1] * b[1][1]],\n            [a[1][0] * b[0][0] + a[1][1] * b[1][0],\n                a[1][0] * b[0][1] + a[1][1] * b[1][1]]\n        ];\n    }\n\n    function compute(n) {\n        if(!cache[n]) {\n            var n_2 = n >> 1;\n            compute(n_2);\n            cache[n] = mult(cache[n_2], cache[n_2]);\n            if(n & 1)\n                cache[n] = mult(cache[1], cache[n]);\n        }\n    }\n\n    fib.matrix_cached = function(n) {\n        if(n == 0)\n            return 0;\n\n        compute(--n);\n\n        return cache[n][0][0];\n    };\n})();\n\nfunction test(name, func, n, count) {\n    var value;\n\n    var start = Number(new Date);\n    while(count--)\n        value = func(n);\n    var end = Number(new Date);\n\n    return 'fib.' + name + '(' + n + ') = ' + value + ' [' +\n        (end - start) + 'ms]';\n}\n\nfor(var func in fib)\n    document.writeln(test(func, fib[func], 1450, 10000));\n\n</script></pre>