import math, random\n\n\ndef get_pool(items, y, z):\n    slots = y*z\n\n    use_each_times = slots/len(items)\n    exceptions = slots - use_each_times*len(items)\n\n\n    if (use_each_times > y or\n        exceptions > 0 and use_each_times+1 > y):\n        raise Exception("Impossible.")\n\n\n    pool = {}\n    for n in items:\n        pool[n] = use_each_times\n\n    for n in random.sample(items, exceptions):\n        pool[n] += 1\n\n    return pool\n\ndef rebalance(ret, pool, z):\n    max_item = None\n    max_times = None\n\n    for item, times in pool.items():\n        if times > max_times:\n            max_item = item\n            max_times = times\n\n\n    next, times = max_item, max_times\n\n    candidates = []\n    for i in range(len(ret)):\n        item = ret[i]\n\n        if next not in item:\n            candidates.append( (item, i) )\n\n\n    swap, swap_index = random.choice(candidates)\n\n    swapi = []\n    for i in range(len(swap)):\n        if swap[i] not in pool:\n            swapi.append( (swap[i], i) )\n\n\n    which, i = random.choice(swapi)\n\n    pool[next] -= 1\n    pool[swap[i]] = 1\n    swap[i] = next\n\n    ret[swap_index] = swap\n\ndef plist(items, y, z):\n    pool = get_pool(items, y, z)\n\n    ret = []\n    while len(pool.keys()) > 0:\n        while len(pool.keys()) < z:\n            rebalance(ret, pool, z)\n\n        selections = random.sample(pool.keys(), z)\n\n        for i in selections:\n            pool[i] -= 1\n            if pool[i] == 0:\n                del pool[i]\n\n        ret.append( selections )\n\n    return ret\n\n\nprint plist([0,1,2,3], 6, 2)