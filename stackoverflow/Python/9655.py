#!/usr/bin/env python\n\nimport sys\nimport re\nfrom optparse import OptionParser\nfrom math import fabs\n\nsplitPattern = re.compile(r',|\s+|;')\n\nclass FailObject(object):\n    def __init__(self, options):\n        self.options = options\n        self.failure = False\n\n    def fail(self, brief, full = ""):\n        print ">>>> ", brief\n        if options.verbose and full != "":\n            print "     ", full\n        self.failure = True\n\n\n    def exit(self):\n        if (self.failure):\n            print "FAILURE"\n            sys.exit(1)\n        else:\n            print "SUCCESS"\n            sys.exit(0)\n\ndef numSplit(line):\n    list = splitPattern.split(line)\n    if list[-1] == "":\n        del list[-1]\n\n    numList = [float(a) for a in list]\n    return numList\n\ndef softEquiv(ref, target, tolerance):\n    if (fabs(target - ref) <= fabs(ref) * tolerance):\n        return True\n\n    #if the reference number is zero, allow tolerance\n    if (ref == 0.0):\n        return (fabs(target) <= tolerance)\n\n    #if reference is non-zero and it failed the first test\n    return False\n\ndef compareStrings(f, options, expLine, actLine, lineNum):\n    ### check that they're a bunch of numbers\n    try:\n        exp = numSplit(expLine)\n        act = numSplit(actLine)\n    except ValueError, e:\n#        print "It looks like line %d is made of strings (exp=%s, act=%s)." \\n#                % (lineNum, expLine, actLine)\n        if (expLine != actLine and options.checkText):\n            f.fail( "Text did not match in line %d" % lineNum )\n        return\n\n    ### check the ranges\n    if len(exp) != len(act):\n        f.fail( "Wrong number of columns in line %d" % lineNum )\n        return\n\n    ### soft equiv on each value\n    for col in range(0, len(exp)):\n        expVal = exp[col]\n        actVal = act[col]\n        if not softEquiv(expVal, actVal, options.tol):\n            f.fail( "Non-equivalence in line %d, column %d" \n                    % (lineNum, col) )\n    return\n\ndef run(expectedFileName, actualFileName, options):\n    # message reporter\n    f = FailObject(options)\n\n    expected  = open(expectedFileName)\n    actual    = open(actualFileName)\n    lineNum   = 0\n\n    while True:\n        lineNum += 1\n        expLine = expected.readline().rstrip()\n        actLine = actual.readline().rstrip()\n\n        ## check that the files haven't ended,\n        #  or that they ended at the same time\n        if expLine == "":\n            if actLine != "":\n                f.fail("Tested file ended too late.")\n            break\n        if actLine == "":\n            f.fail("Tested file ended too early.")\n            break\n\n        compareStrings(f, options, expLine, actLine, lineNum)\n\n        #print "%3d: %s|%s" % (lineNum, expLine[0:10], actLine[0:10])\n\n    f.exit()\n\n################################################################################\nif __name__ == '__main__':\n    parser = OptionParser(usage = "%prog [options] ExpectedFile NewFile")\n    parser.add_option("-q", "--quiet",\n                      action="store_false", dest="verbose", default=True,\n                      help="Don't print status messages to stdout")\n\n    parser.add_option("--check-text",\n                      action="store_true", dest="checkText", default=False,\n                      help="Verify that lines of text match exactly")\n\n    parser.add_option("-t", "--tolerance",\n                      action="store", type="float", dest="tol", default=1.e-15,\n                      help="Relative error when comparing doubles")\n\n    (options, args) = parser.parse_args()\n\n    if len(args) != 2:\n        print "Usage: numdiff.py EXPECTED ACTUAL"\n        sys.exit(1)\n\n    run(args[0], args[1], options)