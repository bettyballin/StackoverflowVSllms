# first, collect all the data in a dict of dicts of lists\n# first key is version, second key is year (only for non-empty years)\n\ntree = dict()\nfor root, dirs, files in os.walk('make_1/model_1'):\n    head, tail = os.path.split(root)\n    if dirs:\n       # here, tail is a version\n       tree[tail] = dict\n    elif files:\n       # here, tail is a year\n       tree[os.path.basename(head)][tail] = files\n\n# now specialcase default_version\ndefault_version = tree.pop('default_version')\n# determine range of years; rule is quite asymmetrical:\n#   for min, only years with files in them count\nmin_year = min(d for d in default_version if default_version[d])\n#   for max, all years count, even if empty\nmax_year = max(default_version)\n\nfor version, years in tree.iteritems():\n    current_files = default_version[min_year]\n    years.append(max_year + 1)\n    y = min_year\n    while years:\n        next_change = min(years)\n        if y < next_change:\n            for f in current_files:\n                writerow(version, y, next_change-1, f)\n        y = next_change\n        current_files = years.pop(y)