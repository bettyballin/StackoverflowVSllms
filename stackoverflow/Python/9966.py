from __future__ import division\nfrom math import ceil\n\ndef make_combos(max_val,target_sum,n_cells):\n    combos = []\n    # The highest possible value of the next cell is whatever is \n    # largest of the max_val, or the target_sum minus the number \n    # of remaining cells (as you can't enter 0).\n    highest = min(max_val, target_sum - n_cells + 1)\n    # The lowest is the lowest number you can have that will add upp to \n    # target_sum if you multiply it with n_cells.\n    lowest = int(ceil(target_sum/n_cells))\n    for x in range(highest, lowest-1, -1):\n        if n_cells == 1: # This is the last cell, no more recursion.\n            combos.append((x,))\n            break\n        # Recurse to get the next cell:\n        # Set the max to x (or we'll get duplicates like\n        # (6,3,2,1) and (6,2,3,1), which is pointless.\n        # Reduce the target_sum with x to keep the sum correct.\n        # Reduce the number of cells with 1.\n        for combo in make_combos(x, target_sum-x, n_cells-1):\n            combos.append((x,)+combo)\n    return combos\n\nif __name__ == '__main__':\n    import pprint\n    # And by using pprint the output gets easier to read\n    pprint.pprint(make_combos( 6,12,4))