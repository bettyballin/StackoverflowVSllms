function balance_html($text) {\n    $doc = new DOMDocument();\n    libxml_use_internal_errors(true);\n    $doc->loadHTML($text, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);\n    libxml_clear_errors();\n\n    $body = $doc->getElementsByTagName('body')->item(0);\n    $html = $doc->saveHTML($body);\n    return substr($html, 6, -7); // Remove <body> tags added by loadHTML\n}\n\nfunction trim_html_preserve_tags($text, $limit = 50) {\n    $output = '';\n    $length = 0;\n    $open_tags = [];\n\n    preg_match_all('/(<[^>]+>|[^<]+)+/', $text, $matches, PREG_SET_ORDER);\n    \n    foreach ($matches as $token) {\n        if ($length >= $limit) {\n            break;\n        }\n        \n        $token = $token[0];\n        if (preg_match('/<[^>]+>/', $token)) {\n            if (preg_match('/<([a-z]+)[^>]*>/i', $token, $tag_match)) {\n                array_unshift($open_tags, $tag_match[1]);\n            } elseif (preg_match('/<\/([a-z]+)>/i', $token, $tag_match)) {\n                unset($open_tags[array_search($tag_match[1], $open_tags)]);\n            }\n            $output .= $token;\n        } else {\n            if (($length + mb_strlen($token)) > $limit) {\n                $token = mb_substr($token, 0, $limit - $length);\n            }\n            $output .= $token;\n            $length += mb_strlen($token);\n        }\n    }\n    \n    foreach ($open_tags as $tag) {\n        $output .= "</$tag>";\n    }\n    \n    return balance_html($output);\n}\n\n$html_content = "This is <b>my bold</b> text with more than 50 characters. Let's see how it handles trimming!";\n$trimmed_html = trim_html_preserve_tags($html_content, 50);\n\necho $trimmed_html;