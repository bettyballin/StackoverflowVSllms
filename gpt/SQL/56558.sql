-- Create the necessary indexes\nCREATE INDEX idx_userid ON tblUser(UserID);\nCREATE INDEX idx_groupid ON tblGroup(GroupID);\nCREATE INDEX idx_groupgroupid ON tblGroupGroup(GroupGroupID);\nCREATE INDEX idx_groupuserid ON tblGroupUser(GroupUserID);\nCREATE INDEX idx_permission ON tblPermission(SecurityObjectID, SecuredID, TableName);\n\n-- Recursive CTE to handle nested groups\nWITH RecursiveGroups AS (\n    SELECT g.GroupID, gu.UserID\n    FROM tblGroupUser gu\n    JOIN tblGroup g ON gu.GroupUserID = g.GroupID\n    UNION ALL\n    SELECT gg.GroupGroupID, rg.UserID\n    FROM tblGroupGroup gg\n    JOIN RecursiveGroups rg ON gg.GroupID = rg.GroupID\n)\n-- Aggregate permissions for each user\nSELECT\n    p.PermissionID,\n    p.SecurityObjectID,\n    p.SecuredID,\n    p.TableName,\n    MAX(p.AllowFlag) AS AllowFlag -- Resolve conflicts by prioritizing denials (0) over allowances (1)\nFROM tblPermission p\nJOIN (\n    SELECT UserID, SecurityObjectID\n    FROM tblUser u\n    LEFT JOIN RecursiveGroups rg ON u.UserID = rg.UserID\n    UNION\n    SELECT GroupID AS UserID, SecurityObjectID\n    FROM tblGroup\n) AS UserPermissions ON p.SecurityObjectID = UserPermissions.SecurityObjectID\nGROUP BY p.PermissionID, p.SecurityObjectID, p.SecuredID, p.TableName\nHAVING MAX(CASE WHEN p.AllowFlag = 0 THEN 1 ELSE 0 END) = 0 -- Ensure that explicit denials take precedence