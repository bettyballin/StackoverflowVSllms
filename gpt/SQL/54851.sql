-- Create the initial table\ncreate table #ranges (Start int, Finish int,  Priority int);\n\n-- Insert the given values\ninsert #ranges values (1 , 10, 0);\ninsert #ranges values (2 , 5 , 1);\ninsert #ranges values (3 , 4 , 2);\ninsert #ranges values (1 , 5 , 0);\ninsert #ranges values (200028, 308731, 0);\n\n-- Step 1: Expand the ranges to individual points with priority\nwith ExpandedRanges as (\n    select Start as Point, Priority from #ranges\n    union all\n    select Finish, Priority from #ranges\n),\n-- Step 2: Assign a row number for each point based on priority\nNumberedPoints as (\n    select Point,\n           Priority,\n           row_number() over (order by Point, Priority desc) as RowNum\n    from ExpandedRanges\n),\n-- Step 3: Determine the starts and ends of new non-overlapping ranges\nNewRanges as (\n    select Point as Start,\n           lead(Point) over (order by RowNum) as Finish,\n           Priority\n    from NumberedPoints\n    where lead(Point) over (order by RowNum) is not null\n)\n-- Step 4: Filter out the gaps and duplicates\nselect Start,\n       Finish,\n       Priority\ninto #non_overlapping_ranges\nfrom NewRanges\nwhere Start <> Finish\ngroup by Start, Finish, Priority;\n\n-- Step 5: Eliminate duplicates and overlapping ranges by prioritizing\nwith FinalRanges as (\n    select Start,\n           Finish,\n           Priority,\n           row_number() over (partition by Start, Finish order by Priority desc) as RowNum\n    from #non_overlapping_ranges\n)\n-- Step 6: Select the final result\nselect Start,\n       Finish,\n       Priority\nfrom FinalRanges\nwhere RowNum = 1\norder by Start, Priority desc;\n\n-- Cleanup temporary table\ndrop table #non_overlapping_ranges;\ndrop table #ranges;