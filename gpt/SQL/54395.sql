-- Step 1: Retrieve and store the constraints definitions\nSELECT \n    rc.RDB$CONSTRAINT_NAME, \n    rc.RDB$RELATION_NAME, \n    rc.RDB$DEFERRABLE,\n    rc.RDB$INITIALLY_DEFERRED,\n    s.RDB$FIELD_NAME,\n    fk.RDB$UPDATE_RULE,\n    fk.RDB$DELETE_RULE,\n    fk.RDB$CONST_NAME_UQ,\n    refc.RDB$FIELD_NAME AS REF_FIELD_NAME\nFROM \n    RDB$RELATION_CONSTRAINTS rc\nJOIN \n    RDB$INDEX_SEGMENTS s ON rc.RDB$INDEX_NAME = s.RDB$INDEX_NAME\nJOIN \n    RDB$REF_CONSTRAINTS fk ON rc.RDB$CONSTRAINT_NAME = fk.RDB$CONSTRAINT_NAME\nJOIN \n    RDB$INDEX_SEGMENTS refc ON fk.RDB$CONST_NAME_UQ = refc.RDB$INDEX_NAME\nWHERE \n    rc.RDB$CONSTRAINT_TYPE = 'FOREIGN KEY' \n    AND rc.RDB$RELATION_NAME = 'YOUR_TABLE_NAME';\n\n-- Step 2: Drop the constraints\nALTER TABLE YOUR_TABLE_NAME DROP CONSTRAINT YOUR_CONSTRAINT_NAME;\n\n-- Repeat the ALTER TABLE DROP statement for each constraint\n\n-- Perform your operations here\n\n-- Step 3: Re-create the constraints using the stored definitions\nALTER TABLE YOUR_TABLE_NAME ADD CONSTRAINT YOUR_CONSTRAINT_NAME FOREIGN KEY (YOUR_FIELD_NAME)\n  REFERENCES REFERENCED_TABLE (REFERENCED_FIELD_NAME)\n  ON UPDATE CASCADE -- or other rule as per the stored definition\n  ON DELETE CASCADE; -- or other rule as per the stored definition\n\n-- Repeat the ALTER TABLE ADD CONSTRAINT statement for each constraint