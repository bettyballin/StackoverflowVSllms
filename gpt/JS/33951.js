// Step 1: Construct the MST\nMST = constructMST(graph);\n\n// Step 2: Dynamic Programming on the MST\n// Initialize DP table dp[node][k] to store the minimal distance subtree with k nodes rooted at 'node'\ninitialize dp[node][k] for all nodes and k;\n\n// Recursive function to fill the DP table\nfunction dfs(node, parent) {\n    // Base case: minimal distance subtree with 1 node (itself)\n    dp[node][1] = 0; \n\n    // Iterate over all children of the current node\n    for (child : MST[node]) {\n        if (child == parent) continue;\n        \n        // Recurse to calculate dp for child\n        dfs(child, node);\n        \n        // Combine results from child to the current node\n        for (k = m; k >= 1; --k) {\n            for (j = 1; j < k; ++j) {\n                dp[node][k] = min(dp[node][k], dp[node][k-j] + dp[child][j] + weight(node, child));\n            }\n        }\n    }\n}\n\n// Start the DFS from an arbitrary root node (e.g., 0)\ndfs(0, -1);\n\n// The result is the minimal subtree with 'm' nodes rooted at any node\nresult = min(dp[node][m] for all nodes);