import numpy as np\n\ndef inverse_distance_weighting(x, y, points, power=2):\n    weighted_sum = 0\n    weight_total = 0\n    for point in points:\n        px, py, value = point\n        distance = np.sqrt((x - px) ** 2 + (y - py) ** 2)\n        if distance == 0:\n            return value\n        weight = 1 / (distance ** power)\n        weighted_sum += weight * value\n        weight_total += weight\n    return weighted_sum / weight_total\n\ndef generate_heightmap(width, height, points, power=2):\n    heightmap = np.zeros((height, width))\n    for y in range(height):\n        for x in range(width):\n            heightmap[y, x] = inverse_distance_weighting(x, y, points, power)\n    return heightmap\n\n# Example usage:\npoints = [\n    (10, 10, 5),\n    (20, 20, 10),\n    (30, 10, 15),\n    # Add more points as needed\n]\n\nwidth = 50\nheight = 50\nheightmap = generate_heightmap(width, height, points, power=2)\n\n# Optional: visualize the heightmap using matplotlib\nimport matplotlib.pyplot as plt\nplt.imshow(heightmap, cmap='terrain')\nplt.colorbar()\nplt.show()