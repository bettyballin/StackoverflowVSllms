import math\nimport mmh3\nfrom bitarray import bitarray\n\nclass BloomFilter:\n    def __init__(self, item_count, fp_prob):\n        self.fp_prob = fp_prob\n        self.size = self.get_size(item_count, fp_prob)\n        self.hash_count = self.get_hash_count(self.size, item_count)\n        self.bit_array = bitarray(self.size)\n        self.bit_array.setall(0)\n\n    @staticmethod\n    def get_size(n, p):\n        m = -(n * math.log(p)) / (math.log(2) ** 2)\n        return int(m)\n\n    @staticmethod\n    def get_hash_count(m, n):\n        k = (m / n) * math.log(2)\n        return int(k)\n\n    def add(self, item):\n        digests = []\n        for i in range(self.hash_count):\n            digest = mmh3.hash(item, i) % self.size\n            digests.append(digest)\n            self.bit_array[digest] = True\n\n    def check(self, item):\n        for i in range(self.hash_count):\n            digest = mmh3.hash(item, i) % self.size\n            if not self.bit_array[digest]:\n                return False\n        return True\n\n# Example usage\nn = 1000  # Number of expected elements in the filter\np = 0.01  # Probability of false positives\n\nbloomf = BloomFilter(n, p)\n\n# Adding items\nbloomf.add("192.168.1.1")\nbloomf.add("192.168.1.2")\n\n# Checking membership\nprint(bloomf.check("192.168.1.1"))  # Output: True\nprint(bloomf.check("192.168.1.3"))  # Output: False