from Crypto.Cipher import AES\nfrom Crypto.Random import get_random_bytes\nimport struct\nimport time\n\n# Function to encrypt a message\ndef encrypt_message(message, key):\n    nonce = get_random_bytes(12)  # 12 bytes nonce for AES GCM\n    timestamp = int(time.time())\n    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)\n    \n    # Include timestamp in the message to prevent replay attacks\n    message_with_timestamp = struct.pack(">I", timestamp) + message.encode()\n    \n    ciphertext, tag = cipher.encrypt_and_digest(message_with_timestamp)\n    return nonce + tag + ciphertext\n\n# Function to decrypt a message\ndef decrypt_message(enc_message, key):\n    nonce = enc_message[:12]\n    tag = enc_message[12:28]\n    ciphertext = enc_message[28:]\n    \n    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)\n    try:\n        message_with_timestamp = cipher.decrypt_and_verify(ciphertext, tag)\n        timestamp, message = struct.unpack(">I", message_with_timestamp[:4]), message_with_timestamp[4:]\n        return message.decode(), timestamp\n    except ValueError:\n        # Handle decryption error (e.g., wrong key or tampered message)\n        return None, None\n\n# Example usage\nkey = get_random_bytes(32)  # 32 bytes key for AES-256\n\nmessage = "Hello, this is a secure message."\nencrypted = encrypt_message(message, key)\nprint("Encrypted:", encrypted)\n\ndecrypted, timestamp = decrypt_message(encrypted, key)\nprint("Decrypted:", decrypted)\nprint("Timestamp:", timestamp)