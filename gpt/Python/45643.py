def min_vertex_cover(tree):\n    n = len(tree)\n    dp = [[0, 0] for _ in range(n)]\n    \n    def dfs(node, parent):\n        dp[node][0] = 0\n        dp[node][1] = 1\n        for neighbor in tree[node]:\n            if neighbor == parent:\n                continue\n            dfs(neighbor, node)\n            dp[node][0] += dp[neighbor][1]\n            dp[node][1] += min(dp[neighbor][0], dp[neighbor][1])\n    \n    dfs(0, -1)\n    return min(dp[0][0], dp[0][1])\n\n# Example usage:\n# Tree represented as an adjacency list where each index represents a node\n# and each list at an index contains its neighbors.\ntree = [\n    [1, 2],    # Neighbors of node 0\n    [0, 3, 4], # Neighbors of node 1\n    [0],       # Neighbors of node 2\n    [1],       # Neighbors of node 3\n    [1]        # Neighbors of node 4\n]\n\nprint(min_vertex_cover(tree))  # Output: 2