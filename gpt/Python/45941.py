function find_furthest_points(grid):\n    start = find_any_non_blocked_point(grid)\n    P1 = bfs_furthest_point(grid, start)\n    P2 = bfs_furthest_point(grid, P1)\n    return (P1, P2)\n\nfunction bfs_furthest_point(grid, start):\n    queue = [start]\n    distances = {[start]: 0}\n    furthest_point = start\n    max_distance = 0\n\n    while queue is not empty:\n        current_point = queue.pop_front()\n        current_distance = distances[current_point]\n\n        for each neighbor in get_neighbors(grid, current_point):\n            if neighbor is not blocked and neighbor not in distances:\n                queue.append(neighbor)\n                distances[neighbor] = current_distance + 1\n                \n                if distances[neighbor] > max_distance:\n                    max_distance = distances[neighbor]\n                    furthest_point = neighbor\n\n    return furthest_point\n\nfunction get_neighbors(grid, point):\n    neighbors = []\n    (x, y) = point\n    if grid[x-1][y] is valid and not blocked:\n        neighbors.append((x-1, y))\n    if grid[x+1][y] is valid and not blocked:\n        neighbors.append((x+1, y))\n    if grid[x][y-1] is valid and not blocked:\n        neighbors.append((x, y-1))\n    if grid[x][y+1] is valid and not blocked:\n        neighbors.append((x, y+1))\n    return neighbors\n\nfunction find_any_non_blocked_point(grid):\n    for each row in grid:\n        for each point in row:\n            if point is not blocked:\n                return point\n    return None