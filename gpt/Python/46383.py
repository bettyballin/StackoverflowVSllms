import os\nimport heapq\nimport tempfile\n\ndef sort_and_save_chunk(data, chunk_num):\n    data.sort()\n    filename = f'chunk_{chunk_num}.txt'\n    with open(filename, 'w') as f:\n        for num in data:\n            f.write(f"{num}\n")\n    return filename\n\ndef merge_files(sorted_files, output_file):\n    min_heap = []\n    file_pointers = [open(file, 'r') for file in sorted_files]\n    for i, fp in enumerate(file_pointers):\n        line = fp.readline().strip()\n        if line:\n            heapq.heappush(min_heap, (int(line), i))\n\n    with open(output_file, 'w') as outfile:\n        while min_heap:\n            smallest, file_index = heapq.heappop(min_heap)\n            outfile.write(f"{smallest}\n")\n            line = file_pointers[file_index].readline().strip()\n            if line:\n                heapq.heappush(min_heap, (int(line), file_index))\n\n    for fp in file_pointers:\n        fp.close()\n\ndef external_sort(input_file, output_file):\n    chunk_size = 50000  # Adjust based on available memory\n    chunk_num = 0\n    sorted_files = []\n\n    with open(input_file, 'r') as infile:\n        data = []\n        for line in infile:\n            data.append(int(line.strip()))\n            if len(data) >= chunk_size:\n                sorted_files.append(sort_and_save_chunk(data, chunk_num))\n                data = []\n                chunk_num += 1\n\n        if data:  # Handle the last chunk\n            sorted_files.append(sort_and_save_chunk(data, chunk_num))\n\n    merge_files(sorted_files, output_file)\n\n    # Clean up temporary chunk files\n    for file in sorted_files:\n        os.remove(file)\n\n# Example usage\ninput_file = 'input.txt'  # Input file containing 1 million integers\noutput_file = 'sorted_output.txt'  # Output file for sorted integers\nexternal_sort(input_file, output_file)