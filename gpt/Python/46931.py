class VertexPoolAllocator:\n    def __init__(self, size):\n        self.pool = [None] * size  # Preallocate the array\n        self.free_list = [(0, size)]  # Initially, the entire pool is free\n\n    def allocate(self, length):\n        for i, (start, end) in enumerate(self.free_list):\n            if end - start >= length:\n                allocated_range = (start, start + length)\n                if end - start == length:\n                    self.free_list.pop(i)  # Remove the exact fit free block\n                else:\n                    self.free_list[i] = (start + length, end)  # Adjust the free block\n                return allocated_range\n        raise MemoryError("Not enough memory to allocate")\n\n    def deallocate(self, start, length):\n        # Merge the deallocated block with adjacent free blocks if possible\n        end = start + length\n        new_free_block = (start, end)\n        merged = False\n        \n        for i, (free_start, free_end) in enumerate(self.free_list):\n            if free_end == start:\n                self.free_list[i] = (free_start, end)\n                merged = True\n                break\n            elif free_start == end:\n                self.free_list[i] = (start, free_end)\n                merged = True\n                break\n        \n        if not merged:\n            self.free_list.append(new_free_block)\n            self.free_list.sort()  # Maintain sorted free list for efficient allocation\n\n# Example usage\npool = VertexPoolAllocator(100)\n\n# Allocate 20 vertices\nallocated_range = pool.allocate(20)\nprint(f"Allocated range: {allocated_range}")\n\n# Deallocate previously allocated vertices\npool.deallocate(allocated_range[0], 20)