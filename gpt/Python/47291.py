class EloRating:\n    def __init__(self, K=32):\n        self.ratings = {}\n        self.K = K\n\n    def add_product(self, product):\n        if product not in self.ratings:\n            self.ratings[product] = 1000  # Initial rating\n\n    def expected_score(self, rating_a, rating_b):\n        return 1 / (1 + 10**((rating_b - rating_a) / 400))\n\n    def update_ratings(self, product_a, product_b, score_a, score_b):\n        rating_a = self.ratings[product_a]\n        rating_b = self.ratings[product_b]\n        \n        expected_a = self.expected_score(rating_a, rating_b)\n        expected_b = self.expected_score(rating_b, rating_a)\n        \n        self.ratings[product_a] += self.K * (score_a - expected_a)\n        self.ratings[product_b] += self.K * (score_b - expected_b)\n\n    def get_ratings(self):\n        return self.ratings\n\n# Instantiate EloRating system\nelo = EloRating()\n\n# Add products\nproducts = ['a', 'b', 'c']\nfor product in products:\n    elo.add_product(product)\n\n# User feedbacks\nfeedbacks = [\n    ('a', 150, 'b', 0),\n    ('a', 150, 'c', 20),\n    ('c', 200, 'a', 10),\n    ('a', 200, 'b', 40, 'c', 100),\n    ('a', 150, 'b', 50),\n    ('a', 150, 'b', 20)\n]\n\n# Process feedbacks\nfor feedback in feedbacks:\n    if len(feedback) == 4:\n        # Pairwise comparison\n        product_a, score_a, product_b, score_b = feedback\n        elo.update_ratings(product_a, product_b, score_a, score_b)\n    elif len(feedback) == 6:\n        # Triple comparison (a vs b, a vs c, b vs c)\n        product_a, score_a, product_b, score_b, product_c, score_c = feedback\n        elo.update_ratings(product_a, product_b, score_a, score_b)\n        elo.update_ratings(product_a, product_c, score_a, score_c)\n        elo.update_ratings(product_b, product_c, score_b, score_c)\n\n# Get final ratings\nratings = elo.get_ratings()\nsorted_ratings = sorted(ratings.items(), key=lambda x: x[1], reverse=True)\n\nfor product, rating in sorted_ratings:\n    print(f"Product {product}: {rating:.2f}")