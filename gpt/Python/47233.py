class Node:\n    def __init__(self, value):\n        self.value = value\n        self.edges = []\n\n    def add_edge(self, node):\n        self.edges.append(node)\n\ndef invert_dag(nodes):\n    # Create a dictionary to hold the new nodes\n    inverted_nodes = {node.value: Node(node.value) for node in nodes}\n\n    # Traverse the original graph and reverse edges\n    for node in nodes:\n        for neighbor in node.edges:\n            inverted_nodes[neighbor.value].add_edge(inverted_nodes[node.value])\n\n    # Find the new roots (nodes with no incoming edges)\n    new_roots = {node for node in inverted_nodes.values() if not any(node in n.edges for n in inverted_nodes.values())}\n\n    return new_roots, inverted_nodes\n\n# Example usage:\nA, B, C, D, E, F, G = Node('A'), Node('B'), Node('C'), Node('D'), Node('E'), Node('F'), Node('G')\nA.add_edge(B)\nA.add_edge(C)\nB.add_edge(G)\nC.add_edge(E)\nC.add_edge(D)\nE.add_edge(F)\nD.add_edge(F)\n\nnodes = [A, B, C, D, E, F, G]\nnew_roots, inverted_nodes = invert_dag(nodes)\n\n# Print new roots\nprint("New roots:")\nfor root in new_roots:\n    print(root.value)