import heapq\n\nclass Child:\n    def __init__(self, id, dataLoad):\n        self.id = id\n        self.dataLoad = dataLoad\n\n    def __lt__(self, other):\n        return self.dataLoad < other.dataLoad\n\ndef balance_load(children):\n    if not children:\n        return\n\n    n = len(children)\n    total_load = sum(child.dataLoad for child in children)\n    avg_load = total_load // n\n    remainder = total_load % n\n\n    # Create min-heap and max-heap\n    min_heap = []\n    max_heap = []\n\n    for child in children:\n        if child.dataLoad > avg_load + 1:\n            heapq.heappush(max_heap, (-child.dataLoad, child))\n        elif child.dataLoad < avg_load:\n            heapq.heappush(min_heap, child)\n\n    while max_heap and min_heap:\n        overloaded = heapq.heappop(max_heap)[1]\n        underloaded = heapq.heappop(min_heap)\n\n        transfer_amount = min(overloaded.dataLoad - (avg_load + 1), avg_load - underloaded.dataLoad)\n        overloaded.dataLoad -= transfer_amount\n        underloaded.dataLoad += transfer_amount\n\n        if overloaded.dataLoad > avg_load + 1:\n            heapq.heappush(max_heap, (-overloaded.dataLoad, overloaded))\n        if underloaded.dataLoad < avg_load:\n            heapq.heappush(min_heap, underloaded)\n\n    # Handle the remainder distribution\n    if remainder:\n        for i in range(remainder):\n            heapq.heappush(min_heap, children[i])\n        while min_heap:\n            child = heapq.heappop(min_heap)\n            child.dataLoad += 1\n\n# Example usage:\nchildren = [Child(i, load) for i, load in enumerate([5, 1, 3, 7, 2])]\nbalance_load(children)\nfor child in children:\n    print(f"Child {child.id} has load {child.dataLoad}")