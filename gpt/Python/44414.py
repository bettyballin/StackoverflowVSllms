from collections import defaultdict, deque\n\n# Function to perform topological sort\ndef topological_sort(graph, indegree):\n    topo_order = []\n    zero_indegree = deque([node for node in graph if indegree[node] == 0])\n    \n    while zero_indegree:\n        node = zero_indegree.popleft()\n        topo_order.append(node)\n        \n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                zero_indegree.append(neighbor)\n    \n    return topo_order\n\n# Function to compute the longest path in the DAG\ndef longest_path_dag(graph, weights):\n    indegree = {node: 0 for node in graph}\n    \n    for node in graph:\n        for neighbor in graph[node]:\n            indegree[neighbor] += 1\n    \n    topo_order = topological_sort(graph, indegree)\n    \n    # Initialize distances with negative infinity and set the source node distance\n    dist = {node: float('-inf') for node in graph}\n    dist[topo_order[0]] = weights[topo_order[0]]  # Assuming topo_order[0] is the source node\n    \n    # Process nodes in topological order\n    for node in topo_order:\n        for neighbor in graph[node]:\n            if dist[neighbor] < dist[node] + weights[neighbor]:\n                dist[neighbor] = dist[node] + weights[neighbor]\n    \n    # Find the maximum distance which will be the weight of the critical path\n    max_dist = max(dist.values())\n    \n    return max_dist\n\n# Example graph\ngraph = {\n    'A': ['B', 'D'],\n    'B': ['E', 'F'],\n    'D': [],\n    'E': [],\n    'F': []\n}\n\nweights = {\n    'A': 3,\n    'B': 4,\n    'D': 7,\n    'E': 2,\n    'F': 3\n}\n\nprint(longest_path_dag(graph, weights))  # Output: 10