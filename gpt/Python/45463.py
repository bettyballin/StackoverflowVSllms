class Token:\n    def __init__(self, type, value):\n        self.type = type\n        self.value = value\n\nclass Parser:\n    def __init__(self, tokens):\n        self.tokens = tokens\n        self.current_token = self.tokens.pop(0)\n    \n    def eat(self, token_type):\n        if self.current_token.type == token_type:\n            self.current_token = self.tokens.pop(0) if self.tokens else None\n        else:\n            raise Exception(f"Expected token {token_type}, got {self.current_token.type}")\n    \n    def parse_expression(self):\n        node = self.parse_term()\n        while self.current_token and self.current_token.type in ('PLUS', 'MINUS'):\n            token = self.current_token\n            if token.type == 'PLUS':\n                self.eat('PLUS')\n            elif token.type == 'MINUS':\n                self.eat('MINUS')\n            node = ('bin_op', token, node, self.parse_term())\n        return node\n    \n    def parse_term(self):\n        node = self.parse_factor()\n        while self.current_token and self.current_token.type in ('MUL', 'DIV'):\n            token = self.current_token\n            if token.type == 'MUL':\n                self.eat('MUL')\n            elif token.type == 'DIV':\n                self.eat('DIV')\n            node = ('bin_op', token, node, self.parse_factor())\n        return node\n    \n    def parse_factor(self):\n        token = self.current_token\n        if token.type == 'INTEGER':\n            self.eat('INTEGER')\n            return ('num', token)\n        elif token.type == 'LPAREN':\n            self.eat('LPAREN')\n            node = self.parse_expression()\n            self.eat('RPAREN')\n            return node\n        else:\n            raise Exception(f"Unexpected token {token.type}")\n\n# Example usage\ntokens = [\n    Token('INTEGER', '3'),\n    Token('PLUS', '+'),\n    Token('INTEGER', '5'),\n    Token('MUL', '*'),\n    Token('INTEGER', '2')\n]\n\nparser = Parser(tokens)\nparse_tree = parser.parse_expression()\nprint(parse_tree)