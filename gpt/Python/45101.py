class MyQUEUE:  # just an implementation of a queue\n    def __init__(self):\n        self.holder = []\n\n    def enqueue(self, val):\n        self.holder.append(val)\n\n    def dequeue(self):\n        val = None\n        try:\n            val = self.holder[0]\n            if len(self.holder) == 1:\n                self.holder = []\n            else:\n                self.holder = self.holder[1:]\n        except IndexError:\n            pass\n        return val\n\n    def IsEmpty(self):\n        return len(self.holder) == 0\n\ndef BFS(graph, start, end, q):\n    temp_path = [start]\n    q.enqueue(temp_path)\n    paths = []\n\n    while not q.IsEmpty():\n        tmp_path = q.dequeue()\n        last_node = tmp_path[-1]\n        if last_node == end:\n            paths.append(tmp_path)\n        for link_node in graph.get(last_node, []):\n            if link_node not in tmp_path:\n                new_path = tmp_path + [link_node]\n                q.enqueue(new_path)\n    return paths\n\n# Define the graph based on the provided connections\ngraph = {\n    1: [2],\n    2: [1, 3, 5, 4],\n    3: [2, 6],\n    4: [2],\n    5: [2, 11, 6],\n    6: [7, 5, 3, 8],\n    7: [6],\n    8: [6, 10, 9],\n    9: [8],\n    10: [8],\n    11: [5, 12],\n    12: [11]\n}\n\npath_queue = MyQUEUE()  # create a queue instance\npaths = BFS(graph, 1, 7, path_queue)  # find all paths from node 1 to node 7\n\n# Output the paths\nprint(f"{len(paths)} paths found and they are:")\nfor path in paths:\n    print(','.join(map(str, path)))