import numpy as np\n\n# Function to convert a bitmap to a 1D binary array\ndef bitmap_to_array(bitmap):\n    return np.array(bitmap).flatten()\n\n# Function to compute Hamming distance between two binary arrays\ndef hamming_distance(arr1, arr2):\n    return np.sum(arr1 != arr2)\n\n# Example bitmaps (binary images)\nbitmap_A = [\n    [1, 0, 0, 1],\n    [1, 1, 1, 0],\n    [0, 1, 0, 0],\n    [1, 0, 1, 1]\n]\n\nbitmap_B = [\n    [1, 0, 0, 1],\n    [1, 1, 1, 0],\n    [0, 1, 0, 1],\n    [1, 0, 1, 1]\n]\n\nbitmap_C = [\n    [0, 0, 0, 1],\n    [0, 1, 1, 0],\n    [0, 1, 0, 0],\n    [1, 0, 1, 0]\n]\n\n# Reference bitmaps (stored characters)\nreference_bitmaps = [bitmap_A, bitmap_B, bitmap_C]\nreference_arrays = [bitmap_to_array(bmp) for bmp in reference_bitmaps]\n\n# Bitmap to compare\nbitmap_to_compare = [\n    [1, 0, 0, 1],\n    [1, 1, 1, 0],\n    [0, 1, 0, 0],\n    [1, 0, 1, 1]\n]\n\narray_to_compare = bitmap_to_array(bitmap_to_compare)\n\n# Find the closest match using Hamming distance\nmin_distance = float('inf')\nbest_match_index = -1\n\nfor i, ref_array in enumerate(reference_arrays):\n    distance = hamming_distance(array_to_compare, ref_array)\n    if distance < min_distance:\n        min_distance = distance\n        best_match_index = i\n\nprint(f"Best match is bitmap {best_match_index} with Hamming distance {min_distance}")