def minimal_coverage(intervals, a, b):\n    # Sort intervals by starting point, and by ending point in descending order if start points are the same\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    chosen_intervals = []\n    current_end = a\n    index = 0\n\n    while current_end < b:\n        farthest_end = current_end\n        while index < len(intervals) and intervals[index][0] <= current_end:\n            farthest_end = max(farthest_end, intervals[index][1])\n            index += 1\n        if farthest_end == current_end:\n            return []  # No solution\n        current_end = farthest_end\n        chosen_intervals.append((intervals[index-1][0], farthest_end))\n\n    return chosen_intervals\n\n# Example usage\nintervals = [(1, 4), (2, 8), (3, 5), (6, 9), (8, 10)]\na = 1\nb = 10\nprint(minimal_coverage(intervals, a, b))