import random\n\ndef preference_list_to_dict(preferences):\n    return {person: pref_list for person, pref_list in preferences.items()}\n\ndef stable_roommates(preferences):\n    n = len(preferences)\n    proposals = {p: [] for p in preferences}\n    rotations = {p: [] for p in preferences}\n\n    # Phase 1: Propose to top choice\n    while any(len(proposals[p]) < n-1 for p in preferences):\n        for p in preferences:\n            if len(proposals[p]) < n-1:\n                top_choice = preferences[p][0]\n                proposals[top_choice].append(p)\n                preferences[p] = preferences[p][1:]\n\n    # Phase 2: Resolve conflicts\n    for p in preferences:\n        if len(proposals[p]) > 1:\n            rotations[p].extend(proposals[p][1:])\n            proposals[p] = proposals[p][:1]\n\n    # Phase 3: Resolve rotations\n    for p in preferences:\n        for r in rotations[p]:\n            preferences[r].remove(p)\n\n    # Phase 4: Clean up\n    result = {}\n    for p in preferences:\n        result[p] = proposals[p][0]\n\n    return result\n\n# Example preferences\npreferences = {\n    'A': ['B', 'D', 'C', 'F', 'E'],\n    'B': ['A', 'C', 'E', 'D', 'F'],\n    'C': ['D', 'E', 'F', 'A', 'B'],\n    'D': ['C', 'F', 'A', 'B', 'E'],\n    'E': ['F', 'A', 'B', 'C', 'D'],\n    'F': ['E', 'B', 'D', 'C', 'A']\n}\n\n# Prevent direct reciprocation by removing mutual top choices\nfor a in preferences:\n    for b in preferences[a]:\n        if a in preferences[b]:\n            preferences[b].remove(a)\n\n# Run the stable roommates algorithm\nresult = stable_roommates(preferences)\nprint(result)