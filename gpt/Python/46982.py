import numpy as np\n\ndef levenshtein_distance(s1, s2):\n    d = np.zeros((len(s1) + 1, len(s2) + 1), dtype=int)\n\n    for i in range(len(s1) + 1):\n        d[i][0] = i\n    for j in range(len(s2) + 1):\n        d[0][j] = j\n\n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            cost = 0 if s1[i - 1] == s2[j - 1] else 1\n            d[i][j] = min(d[i - 1][j] + 1,    # Deletion\n                          d[i][j - 1] + 1,    # Insertion\n                          d[i - 1][j - 1] + cost)  # Substitution\n\n    return d[len(s1)][len(s2)]\n\ndef correct_city_name(city_name, valid_city_names, threshold=3):\n    closest_city = None\n    min_distance = float('inf')\n\n    for valid_city in valid_city_names:\n        distance = levenshtein_distance(city_name, valid_city)\n        if distance < min_distance and distance <= threshold:\n            min_distance = distance\n            closest_city = valid_city\n\n    return closest_city if closest_city is not None else city_name\n\n# Example usage:\nvalid_city_names = {"New York", "Los Angeles", "Chicago", "Houston", "Phoenix"}  # Add more valid city names\ntext_file_city_names = ["New Yrk", "Los Angles", "Chcago", "Houstan", "Phonix"]\n\ncorrected_city_names = [correct_city_name(city_name, valid_city_names) for city_name in text_file_city_names]\n\nprint(corrected_city_names)