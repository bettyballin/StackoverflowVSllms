def is_valid_move(x, y, N, visited):\n    return 0 <= x < N and 0 <= y < N and not visited[x][y]\n\ndef traverse(grid, x, y, N, X, visited, path, all_paths):\n    if X == 0:\n        # Reset to starting point\n        path.append((x, y))\n        all_paths.append(path.copy())\n        return\n    \n    # Define possible moves (up, down, left, right)\n    moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for move in moves:\n        next_x, next_y = x + move[0], y + move[1]\n        \n        if is_valid_move(next_x, next_y, N, visited):\n            visited[next_x][next_y] = True\n            path.append((next_x, next_y))\n            \n            traverse(grid, next_x, next_y, N, X - 1, visited, path, all_paths)\n            \n            # Backtrack\n            visited[next_x][next_y] = False\n            path.pop()\n\ndef find_all_paths(N, X):\n    grid = [[0] * N for _ in range(N)]\n    visited = [[False] * N for _ in range(N)]\n    all_paths = []\n    \n    # Starting point (middle of the grid)\n    start_x, start_y = N // 2, N // 2\n    visited[start_x][start_y] = True\n    path = [(start_x, start_y)]\n    \n    traverse(grid, start_x, start_y, N, X, visited, path, all_paths)\n    \n    return all_paths\n\n# Example usage\nN = 5  # Grid size\nX = 3  # Move constraint\nall_paths = find_all_paths(N, X)\n\nfor path in all_paths:\n    print(path)