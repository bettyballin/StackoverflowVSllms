import numpy as np\n\ndef ray_cast(start, end, obstacles):\n    direction = np.subtract(end, start)\n    distance = np.linalg.norm(direction)\n    direction = direction / distance  # Normalize direction vector\n    step_size = 0.1  # Adjust step size for accuracy/performance\n    current_position = np.array(start)\n    \n    for _ in np.arange(0, distance, step_size):\n        current_position += direction * step_size\n        if check_collision(current_position, obstacles):\n            return False  # Line of sight is blocked\n    return True  # Line of sight is clear\n\ndef check_collision(position, obstacles):\n    for obstacle in obstacles:\n        if obstacle.contains(position):\n            return True\n    return False\n\n# Example usage:\nstart = [0, 0]\nend = [10, 10]\nobstacles = [Obstacle(5, 5, 1)]  # Define your obstacle class\nprint(ray_cast(start, end, obstacles))