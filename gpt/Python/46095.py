import networkx as nx\n\ndef min_spanning_arborescence(graph):\n    """\n    Finds the minimum spanning arborescence for a directed graph.\n    \n    :param graph: A NetworkX DiGraph object\n    :return: Minimum spanning arborescence as a NetworkX DiGraph object\n    """\n    def find_mst(graph, root):\n        """ Helper function to find MST """\n        mst = nx.DiGraph()\n        edges = []\n        \n        # Step 1: Find the minimum incoming edge for each vertex\n        for node in graph.nodes:\n            if node == root:\n                continue\n            in_edges = list(graph.in_edges(node, data='weight'))\n            if in_edges:\n                min_edge = min(in_edges, key=lambda edge: edge[2])\n                edges.append(min_edge)\n        \n        # Step 2: Contract cycles\n        components = list(nx.strongly_connected_components(nx.DiGraph(edges)))\n        contracted_graph = nx.DiGraph()\n        \n        for component in components:\n            if len(component) > 1:\n                component_weight = sum(graph[u][v]['weight'] for u, v in nx.edges(graph.subgraph(component)))\n                meta_node = frozenset(component)\n                contracted_graph.add_node(meta_node)\n                for node in component:\n                    for u, v, data in graph.in_edges(node, data=True):\n                        if v not in component:\n                            contracted_graph.add_edge(v, meta_node, weight=data['weight'] - component_weight)\n                    for u, v, data in graph.out_edges(node, data=True):\n                        if u not in component:\n                            contracted_graph.add_edge(meta_node, u, weight=data['weight'])\n            else:\n                contracted_graph.add_node(list(component)[0])\n        \n        if len(components) == 1 and components[0] == set(graph.nodes):\n            return nx.DiGraph(edges)\n        \n        # Step 3: Recursively find MST for the contracted graph\n        contracted_mst = find_mst(contracted_graph, root)\n        \n        # Step 4: Expand the cycles\n        for meta_node in contracted_mst.nodes:\n            if isinstance(meta_node, frozenset):\n                component = meta_node\n                for u, v, data in graph.subgraph(component).edges(data=True):\n                    if (u, v) in edges:\n                        mst.add_edge(u, v, weight=data['weight'])\n        \n        for u, v, data in contracted_mst.edges(data=True):\n            if not isinstance(v, frozenset):\n                mst.add_edge(u, v, weight=data['weight'])\n            else:\n                for node in v:\n                    mst.add_edge(u, node, weight=data['weight'])\n                    break\n\n        return mst\n\n    root = list(graph.nodes)[0]  # assuming the graph has at least one node\n    return find_mst(graph, root)\n\n# Example usage:\nG = nx.DiGraph()\n# Add edges: G.add_edge(u, v, weight=w)\n# Example: G.add_edge(0, 1, weight=1)\n\nmst = min_spanning_arborescence(G)\nprint(list(mst.edges(data=True)))