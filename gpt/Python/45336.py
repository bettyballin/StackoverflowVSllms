import random\nfrom datasketch import MinHash, MinHashLSH\n\n# Define the number of hash functions\nnum_perm = 128\n\n# Create a function to generate MinHash for a user's movie ratings\ndef get_minhash(ratings):\n    m = MinHash(num_perm=num_perm)\n    for movie, rating in ratings.items():\n        m.update(f"{movie}:{rating}".encode('utf8'))\n    return m\n\n# Sample user ratings\nuser_ratings = {\n    'Xm': {'A': 9, 'B': 5, 'D': 1, 'F': 1, 'H': 5},\n    'Ym': {'C': 4, 'D': 6, 'E': 1, 'I': 8},\n    'Zf': {'A': 9, 'C': 6, 'D': 4, 'I': 7}\n}\n\n# Create MinHashLSH index\nlsh = MinHashLSH(threshold=0.5, num_perm=num_perm)\n\n# Add users to the LSH index\nfor user, ratings in user_ratings.items():\n    minhash = get_minhash(ratings)\n    lsh.insert(user, minhash)\n\n# Query for similar users to 'Zf'\nquery_user = 'Zf'\nquery_ratings = user_ratings[query_user]\nquery_minhash = get_minhash(query_ratings)\n\nsimilar_users = lsh.query(query_minhash)\nprint(f"Users similar to {query_user}: {similar_users}")\n\n# Calculate actual distances for final ranking\ndef calculate_distance(user1, user2):\n    ratings1 = user_ratings[user1]\n    ratings2 = user_ratings[user2]\n    common_movies = set(ratings1.keys()).intersection(ratings2.keys())\n    if not common_movies:\n        return float('inf')\n    distance = sum(abs(ratings1[movie] - ratings2[movie]) for movie in common_movies) / len(common_movies)\n    return distance\n\ndistances = {user: calculate_distance(query_user, user) for user in similar_users}\nbest_match = min(distances, key=distances.get)\nprint(f"Best match for {query_user} is {best_match} with distance {distances[best_match]}")