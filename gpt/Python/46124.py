def smallest_interval_modulo(v, N):\n    # Sort the values\n    v = sorted(v)\n    \n    # Initialize variables to track the smallest interval\n    min_d = float('inf')\n    best_c = None\n    \n    # Iterate over each value to consider it as the starting point\n    for i in range(len(v)):\n        # Calculate the current interval\n        start = v[i]\n        end = v[(i + len(v) - 1) % len(v)]\n        \n        # Calculate distance with wrap-around consideration\n        dist = ((end - start + N) % N)\n        \n        # If this distance is smaller than the previously found distances, update the best interval\n        if dist < min_d:\n            min_d = dist\n            best_c = (start + dist / 2) % N\n    \n    # Calculate the interval center and radius\n    c = best_c\n    d = min_d / 2\n    \n    return c, d\n\n# Example usage with angles in degrees\nangles = [10, 20, 350, 5]\nN = 360\nc, d = smallest_interval_modulo(angles, N)\nprint(f"Center: {c}, Radius: {d}")