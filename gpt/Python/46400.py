def is_valid_assignment(assignment, constraints):\n    for constraint in constraints:\n        if not constraint(assignment):\n            return False\n    return True\n\ndef backtrack(assignment, variables, constraints):\n    if len(assignment) == len(variables):\n        return assignment\n\n    var = select_unassigned_variable(variables, assignment)\n    for value in get_possible_values(var):\n        assignment[var] = value\n        if is_valid_assignment(assignment, constraints):\n            result = backtrack(assignment, variables, constraints)\n            if result is not None:\n                return result\n        assignment.pop(var)\n\n    return None\n\ndef select_unassigned_variable(variables, assignment):\n    for var in variables:\n        if var not in assignment:\n            return var\n    return None\n\ndef get_possible_values(var):\n    # Replace with actual logic for possible values\n    return [1, 2, 3]\n\ndef main():\n    variables = ['James', 'John', 'Ursula', 'Mary']\n    constraints = [\n        lambda a: sum(1 for v in a.values() if v == 'doctor') == 2,\n        lambda a: 'Ursula' in a and a['Ursula'] == 'doctor',\n        lambda a: 'Ursula' in a and a['Ursula'] == 'team A'\n        # Add more constraints as necessary\n    ]\n    assignment = {}\n    result = backtrack(assignment, variables, constraints)\n    if result:\n        print("Solution found:", result)\n    else:\n        print("No solution found")\n\nif __name__ == "__main__":\n    main()