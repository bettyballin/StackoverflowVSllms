import os\nimport concurrent.futures\n\ndef copy_chunk(src, tgt, start, size):\n    with open(src, 'rb') as fsrc:\n        fsrc.seek(start)\n        chunk = fsrc.read(size)\n    \n    with open(tgt, 'r+b') as ftgt:\n        ftgt.seek(start)\n        ftgt.write(chunk)\n\ndef get_file_size(file_path):\n    return os.path.getsize(file_path)\n\ndef copy_file_multithreaded(src, tgt, num_threads=4):\n    file_size = get_file_size(src)\n    chunk_size = file_size // num_threads\n\n    # Create target file of the same size\n    with open(tgt, 'wb') as f:\n        f.truncate(file_size)\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:\n        futures = []\n        for i in range(num_threads):\n            start = i * chunk_size\n            size = chunk_size if i != num_threads - 1 else file_size - start\n            futures.append(executor.submit(copy_chunk, src, tgt, start, size))\n\n        # Wait for all threads to complete\n        concurrent.futures.wait(futures)\n\n# Example usage:\n# copy_file_multithreaded('source_file_path.txt', 'target_file_path.txt', num_threads=4)