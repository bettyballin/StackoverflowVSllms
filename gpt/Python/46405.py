import numpy as np\n\ndef unit_vector(v):\n    return v / np.linalg.norm(v)\n\ndef potential_field_planning(start, goal, obstacles, obstacle_radius, step_size, max_iterations=1000):\n    position = np.array(start)\n    goal = np.array(goal)\n    \n    for _ in range(max_iterations):\n        # Attractive force towards the goal\n        direction_to_goal = unit_vector(goal - position)\n        attractive_force = direction_to_goal\n        \n        # Repulsive force away from obstacles\n        repulsive_force = np.zeros_like(position)\n        for obstacle in obstacles:\n            obstacle = np.array(obstacle)\n            direction_from_obstacle = position - obstacle\n            distance_to_obstacle = np.linalg.norm(direction_from_obstacle)\n            if distance_to_obstacle < obstacle_radius:\n                repulsive_force += unit_vector(direction_from_obstacle) * (obstacle_radius - distance_to_obstacle)\n        \n        # Combine forces\n        total_force = attractive_force - repulsive_force\n        move_vector = unit_vector(total_force) * step_size\n        position += move_vector\n        \n        # Check if goal is reached\n        if np.linalg.norm(goal - position) < step_size:\n            print("Goal reached!")\n            break\n    \n    return position\n\n# Example usage\nstart = (0, 0)\ngoal = (10, 10)\nobstacles = [(5, 5), (7, 8)]\nobstacle_radius = 1.5\nstep_size = 0.1\n\nfinal_position = potential_field_planning(start, goal, obstacles, obstacle_radius, step_size)\nprint("Final position:", final_position)