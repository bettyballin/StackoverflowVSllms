from collections import deque\nimport time\n\nclass EventStats:\n    def __init__(self, window_size):\n        self.window_size = window_size  # Window size in seconds\n        self.events = deque()  # Use deque to store events with timestamps\n        self.failures = 0  # Counter for failures\n\n    def add_event(self, is_failure):\n        current_time = time.time()  # Get current time\n        self.events.append((current_time, is_failure))\n        if is_failure:\n            self.failures += 1\n        self._remove_old_events()  # Remove events outside the window\n\n    def _remove_old_events(self):\n        current_time = time.time()\n        while self.events and self.events[0][0] < current_time - self.window_size:\n            _, is_failure = self.events.popleft()\n            if is_failure:\n                self.failures -= 1\n\n    def get_failure_rate(self):\n        self._remove_old_events()  # Ensure old events are removed before calculation\n        total_events = len(self.events)\n        if total_events == 0:\n            return 0\n        return self.failures / total_events\n\n# Example usage\nstats = EventStats(window_size=60)  # Last 60 seconds window\nstats.add_event(is_failure=True)\nstats.add_event(is_failure=False)\nstats.add_event(is_failure=True)\n\n# Wait some time and add more events\ntime.sleep(1)\nstats.add_event(is_failure=False)\n\n# Get the failure rate in the last 60 seconds\nprint(stats.get_failure_rate())