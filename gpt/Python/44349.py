import numpy as np\n\ndef generate_random_contingency_table(row_sums, col_sums):\n    rows = len(row_sums)\n    cols = len(col_sums)\n    \n    # Initialize the table with zeros\n    table = np.zeros((rows, cols), dtype=int)\n    \n    # Generate a random initial table that satisfies the row and column sums\n    for i in range(rows):\n        for j in range(cols):\n            if i == rows - 1:  # Last row\n                table[i, j] = col_sums[j] - np.sum(table[:i, j])\n            elif j == cols - 1:  # Last column\n                table[i, j] = row_sums[i] - np.sum(table[i, :j])\n            else:\n                max_val = min(row_sums[i] - np.sum(table[i, :j]), col_sums[j] - np.sum(table[:i, j]))\n                table[i, j] = np.random.randint(0, max_val + 1)\n                \n    # Define a function to perform a single step of the MCMC algorithm\n    def mcmc_step(table, row_sums, col_sums):\n        rows, cols = table.shape\n        # Select two rows and two columns at random\n        r1, r2 = np.random.choice(rows, 2, replace=False)\n        c1, c2 = np.random.choice(cols, 2, replace=False)\n        \n        # Calculate the maximum allowed swap value\n        max_swap = min(table[r1, c1], table[r2, c2], row_sums[r1] - np.sum(table[r1, :]), col_sums[c1] - np.sum(table[:, c1]))\n        if max_swap > 0:\n            swap_val = np.random.randint(1, max_swap + 1)\n            table[r1, c1] -= swap_val\n            table[r2, c2] -= swap_val\n            table[r1, c2] += swap_val\n            table[r2, c1] += swap_val\n        \n        return table\n    \n    # Perform a number of MCMC steps to randomize the initial table\n    for _ in range(10000):  # Number of steps can be adjusted\n        table = mcmc_step(table, row_sums, col_sums)\n    \n    return table\n\n# Example usage:\nrow_sums = [10, 15, 20]\ncol_sums = [12, 18, 15]\ncontingency_table = generate_random_contingency_table(row_sums, col_sums)\nprint(contingency_table)