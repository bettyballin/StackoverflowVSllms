def compact_records(file):\n    # Constants\n    BLOCK_SIZE = 4 * 1024  # Example block size of 4KB\n    RECORD_SIZE = 100  # Average record size (for the sake of example)\n    NUM_BLOCKS = len(file)  # Total number of blocks in the file\n\n    # Initialize pointers\n    source = 0\n    destination = NUM_BLOCKS - 1\n\n    while source < destination:\n        # Find the next partly filled block from the start\n        while source < NUM_BLOCKS and is_fully_filled(file[source]):\n            source += 1\n        \n        # Find the next empty or underutilized block from the end\n        while destination >= 0 and (is_fully_filled(file[destination]) or is_empty(file[destination])):\n            destination -= 1\n\n        if source < destination:\n            # Move records from source to destination\n            move_records(file[source], file[destination])\n            # Mark source block as empty after moving\n            mark_as_empty(file[source])\n        \n        # Update pointers\n        source += 1\n        destination -= 1\n\ndef is_fully_filled(block):\n    # Check if the block is fully filled with records\n    # Implementation depends on the specific file format\n    pass\n\ndef is_empty(block):\n    # Check if the block is empty\n    # Implementation depends on the specific file format\n    pass\n\ndef move_records(source_block, destination_block):\n    # Move records from source_block to destination_block\n    # Ensure records are duplicated before removing from source_block\n    # Implementation depends on the specific file format\n    pass\n\ndef mark_as_empty(block):\n    # Mark the block as empty\n    # Implementation depends on the specific file format\n    pass