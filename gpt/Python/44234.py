import numpy as np\nfrom scipy.cluster.hierarchy import linkage, fcluster\nfrom sklearn.neighbors import DistanceMetric\n\n# Assume addresses is a list of tuples containing (latitude, longitude)\naddresses = [(lat1, lon1), (lat2, lon2), ...]\n\n# Convert to numpy array\ncoords = np.array(addresses)\n\n# Calculate distance matrix using Haversine formula\ndist = DistanceMetric.get_metric('haversine')\ndist_matrix = dist.pairwise(np.radians(coords))\n\n# Perform hierarchical clustering\nZ = linkage(dist_matrix, method='average')\n\n# Define constraints\nmax_addresses_per_cluster = 10\nmax_distance_within_cluster = 0.01  # in radians (approx 1 km)\n\n# Create clusters considering the constraints\nclusters = fcluster(Z, t=max_distance_within_cluster, criterion='distance')\n\n# Balance the clusters\ndef balance_clusters(clusters, max_addresses_per_cluster):\n    unique, counts = np.unique(clusters, return_counts=True)\n    for cluster_id, count in zip(unique, counts):\n        if count > max_addresses_per_cluster:\n            # Logic to rebalance clusters\n            pass\n    return clusters\n\nbalanced_clusters = balance_clusters(clusters, max_addresses_per_cluster)\n\n# Print the resulting clusters\nfor cluster_id in np.unique(balanced_clusters):\n    print(f"Cluster {cluster_id}:")\n    cluster_addresses = coords[balanced_clusters == cluster_id]\n    for addr in cluster_addresses:\n        print(addr)