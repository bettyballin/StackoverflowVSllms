import numpy as np\n\ndef normalize(v):\n    norm = np.linalg.norm(v)\n    if norm == 0:\n       return v\n    return v / norm\n\ndef create_icosahedron():\n    t = (1.0 + np.sqrt(5.0)) / 2.0\n\n    vertices = np.array([[-1,  t,  0],\n                         [ 1,  t,  0],\n                         [-1, -t,  0],\n                         [ 1, -t,  0],\n                         [ 0, -1,  t],\n                         [ 0,  1,  t],\n                         [ 0, -1, -t],\n                         [ 0,  1, -t],\n                         [ t,  0, -1],\n                         [ t,  0,  1],\n                         [-t,  0, -1],\n                         [-t,  0,  1]])\n\n    faces = np.array([[0, 11, 5],\n                      [0, 5, 1],\n                      [0, 1, 7],\n                      [0, 7, 10],\n                      [0, 10, 11],\n                      [1, 5, 9],\n                      [5, 11, 4],\n                      [11, 10, 2],\n                      [10, 7, 6],\n                      [7, 1, 8],\n                      [3, 9, 4],\n                      [3, 4, 2],\n                      [3, 2, 6],\n                      [3, 6, 8],\n                      [3, 8, 9],\n                      [4, 9, 5],\n                      [2, 4, 11],\n                      [6, 2, 10],\n                      [8, 6, 7],\n                      [9, 8, 1]])\n\n    return vertices, faces\n\ndef subdivide(vertices, faces):\n    midpoint_cache = {}\n    def midpoint(v1, v2):\n        smaller_idx = min(v1, v2)\n        larger_idx = max(v1, v2)\n        key = (smaller_idx, larger_idx)\n        if key not in midpoint_cache:\n            midpoint_cache[key] = len(vertices)\n            midpoint_vertex = normalize((vertices[v1] + vertices[v2]) / 2)\n            vertices.append(midpoint_vertex)\n        return midpoint_cache[key]\n\n    new_faces = []\n    for tri in faces:\n        v1, v2, v3 = tri\n        a = midpoint(v1, v2)\n        b = midpoint(v2, v3)\n        c = midpoint(v3, v1)\n        new_faces.extend([[v1, a, c],\n                          [v2, b, a],\n                          [v3, c, b],\n                          [a, b, c]])\n\n    return vertices, new_faces\n\ndef generate_subdivided_icosahedron(subdivisions):\n    vertices, faces = create_icosahedron()\n    vertices = vertices.tolist()\n    for _ in range(subdivisions):\n        vertices, faces = subdivide(vertices, faces)\n    return np.array(vertices), np.array(faces)\n\n# Example usage\nsubdivisions = 2  # Number of subdivisions\nvertices, faces = generate_subdivided_icosahedron(subdivisions)\nprint("Vertices:", vertices)\nprint("Faces:", faces)