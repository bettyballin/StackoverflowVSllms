def minimize_adjacent_distance(arr, f):\n    def find_min_index(current, candidates):\n        min_index = -1\n        min_value = float('inf')\n        for i, candidate in enumerate(candidates):\n            distance = f(current, candidate)\n            if distance < min_value:\n                min_value = distance\n                min_index = i\n        return min_index\n    \n    n = len(arr)\n    if n == 0:\n        return []\n    \n    # Start with the first element\n    remaining = arr[1:]\n    result = [arr[0]]\n    \n    # Build the permutation\n    while remaining:\n        current = result[-1]\n        min_index = find_min_index(current, remaining)\n        result.append(remaining.pop(min_index))\n    \n    # Ensure the loop constraint is minimized\n    if f(result[-1], result[0]) > f(result[0], result[-1]):\n        result = result[::-1]\n    \n    return result\n\n# Example usage:\narr = [1, 2, 3, 4, 5]\ndef f(a, b):\n    return abs(a - b)\n\npermutation = minimize_adjacent_distance(arr, f)\nprint(permutation)