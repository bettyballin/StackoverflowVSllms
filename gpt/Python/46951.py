import heapq\n\ndef dijkstra(graph, start):\n    # Priority queue to store (cost, vertex)\n    queue = [(0, start)]\n    # Dictionary to store the shortest path to each node\n    shortest_paths = {start: (None, 0)}\n    \n    while queue:\n        (cost, current_vertex) = heapq.heappop(queue)\n\n        for neighbor, weight in graph[current_vertex].items():\n            old_cost = shortest_paths.get(neighbor, (None, float('inf')))[1]\n            new_cost = cost + weight\n            if new_cost < old_cost:\n                shortest_paths[neighbor] = (current_vertex, new_cost)\n                heapq.heappush(queue, (new_cost, neighbor))\n    \n    return shortest_paths\n\n# Example usage:\ngraph = {\n    'A': {'B': 1, 'C': 4},\n    'B': {'A': 1, 'C': 2, 'D': 5},\n    'C': {'A': 4, 'B': 2, 'D': 1},\n    'D': {'B': 5, 'C': 1}\n}\n\nstart_vertex = 'A'\nshortest_paths = dijkstra(graph, start_vertex)\nprint(shortest_paths)