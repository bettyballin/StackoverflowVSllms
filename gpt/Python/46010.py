import numpy as np\n\ndef inverse_distance_weighting(lat, lon, known_points, power=2):\n    """\n    Perform inverse distance weighting interpolation.\n    \n    lat, lon: the latitude and longitude of the point to be interpolated.\n    known_points: a list of tuples [(lat, lon, x, y), ...] with known mappings.\n    power: the power parameter for weighting, default is 2.\n    \n    Returns: (x, y) the interpolated coordinates on the distorted map.\n    """\n    weights = []\n    x_coords = []\n    y_coords = []\n    \n    for known_lat, known_lon, x, y in known_points:\n        dist = np.sqrt((lat - known_lat) ** 2 + (lon - known_lon) ** 2)\n        if dist == 0:\n            # If the point matches exactly, return the known mapping\n            return x, y\n        weight = 1 / (dist ** power)\n        weights.append(weight)\n        x_coords.append(x)\n        y_coords.append(y)\n        \n    # Calculate weighted average\n    weights = np.array(weights)\n    x_coords = np.array(x_coords)\n    y_coords = np.array(y_coords)\n    \n    x_interpolated = np.sum(weights * x_coords) / np.sum(weights)\n    y_interpolated = np.sum(weights * y_coords) / np.sum(weights)\n    \n    return x_interpolated, y_interpolated\n\n# Example usage\nknown_points = [\n    (lat1, lon1, x1, y1),\n    (lat2, lon2, x2, y2),\n    # Add more known points with their mapped coordinates\n]\n\ntarget_lat = # latitude of the target point\ntarget_lon = # longitude of the target point\n\nx, y = inverse_distance_weighting(target_lat, target_lon, known_points)\nprint(f"Interpolated coordinates: ({x}, {y})")