import timeit\nimport numpy as np\nfrom scipy.optimize import curve_fit\nimport matplotlib.pyplot as plt\n\n# Function to be analyzed\ndef example_function(n):\n    # Replace this with the actual function\n    total = 0\n    for i in range(n):\n        total += i\n    return total\n\n# Measure execution time for different input sizes\ninput_sizes = [100, 200, 400, 800, 1600, 3200]\nexecution_times = []\n\nfor n in input_sizes:\n    time = timeit.timeit(lambda: example_function(n), number=10)\n    execution_times.append(time)\n\n# Define complexity classes\ndef O_1(n, a):\n    return a\n\ndef O_n(n, a):\n    return a * n\n\ndef O_n_log_n(n, a):\n    return a * n * np.log(n)\n\ndef O_n_squared(n, a):\n    return a * n**2\n\n# Fit data to complexity classes\npopt_O_1, _ = curve_fit(O_1, input_sizes, execution_times)\npopt_O_n, _ = curve_fit(O_n, input_sizes, execution_times)\npopt_O_n_log_n, _ = curve_fit(O_n_log_n, input_sizes, execution_times)\npopt_O_n_squared, _ = curve_fit(O_n_squared, input_sizes, execution_times)\n\n# Plot the results\nplt.figure(figsize=(10, 6))\nplt.scatter(input_sizes, execution_times, label='Measured', color='black')\nplt.plot(input_sizes, O_1(np.array(input_sizes), *popt_O_1), label='O(1)', linestyle='dashed')\nplt.plot(input_sizes, O_n(np.array(input_sizes), *popt_O_n), label='O(n)', linestyle='dashed')\nplt.plot(input_sizes, O_n_log_n(np.array(input_sizes), *popt_O_n_log_n), label='O(n log n)', linestyle='dashed')\nplt.plot(input_sizes, O_n_squared(np.array(input_sizes), *popt_O_n_squared), label='O(n^2)', linestyle='dashed')\nplt.xlabel('Input Size')\nplt.ylabel('Execution Time')\nplt.legend()\nplt.show()\n\n# Determine the best fit (smallest residuals)\nresiduals_O_1 = np.sum((O_1(np.array(input_sizes), *popt_O_1) - execution_times) ** 2)\nresiduals_O_n = np.sum((O_n(np.array(input_sizes), *popt_O_n) - execution_times) ** 2)\nresiduals_O_n_log_n = np.sum((O_n_log_n(np.array(input_sizes), *popt_O_n_log_n) - execution_times) ** 2)\nresiduals_O_n_squared = np.sum((O_n_squared(np.array(input_sizes), *popt_O_n_squared) - execution_times) ** 2)\n\nresiduals = {\n    'O(1)': residuals_O_1,\n    'O(n)': residuals_O_n,\n    'O(n log n)': residuals_O_n_log_n,\n    'O(n^2)': residuals_O_n_squared\n}\n\nbest_fit = min(residuals, key=residuals.get)\nprint(f'The best fit complexity class is: {best_fit}')