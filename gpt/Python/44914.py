from cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding, rsa\nfrom cryptography.hazmat.primitives.serialization import load_pem_private_key, load_pem_public_key\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Generate RSA keys (for demonstration purposes, use a secure method to manage keys)\nprivate_key = rsa.generate_private_key(\n    public_exponent=65537,\n    key_size=2048,\n    backend=default_backend()\n)\npublic_key = private_key.public_key()\n\n# Encrypt data using AES\ndef encrypt_data(data, password):\n    salt = os.urandom(16)\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=100000,\n        backend=default_backend()\n    )\n    key = kdf.derive(password)\n    iv = os.urandom(16)\n    cipher = Cipher(algorithms.AES(key), modes.CFB(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n    encrypted_data = encryptor.update(data) + encryptor.finalize()\n    return salt + iv + encrypted_data\n\n# Sign data\ndef sign_data(data, private_key):\n    signature = private_key.sign(\n        data,\n        padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH\n        ),\n        hashes.SHA256()\n    )\n    return signature\n\n# Verify signature\ndef verify_signature(data, signature, public_key):\n    try:\n        public_key.verify(\n            signature,\n            data,\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH\n            ),\n            hashes.SHA256()\n        )\n        return True\n    except Exception as e:\n        return False\n\n# Example usage\ndata = b"Sensitive research data"\npassword = b"strong_password"\n\n# Encrypt the data\nencrypted_data = encrypt_data(data, password)\n\n# Sign the encrypted data\nsignature = sign_data(encrypted_data, private_key)\n\n# Store encrypted_data and signature\n\n# To verify and decrypt later\nis_valid = verify_signature(encrypted_data, signature, public_key)\nif is_valid:\n    print("Data integrity verified")\n    # Decrypt the data (similar to the encryption process, but in reverse)\nelse:\n    print("Data integrity compromised")