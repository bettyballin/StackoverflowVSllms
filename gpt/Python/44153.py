class AllocatorTracker:\n    def __init__(self, snapshot_interval=1000):\n        self.events = []\n        self.snapshots = {}\n        self.snapshot_interval = snapshot_interval\n\n    def add_event(self, event_type, event_id):\n        self.events.append((event_type, event_id))\n        if len(self.events) % self.snapshot_interval == 0:\n            self._take_snapshot(len(self.events))\n\n    def _take_snapshot(self, change_index):\n        current_state = self._compute_state(change_index)\n        self.snapshots[change_index] = current_state\n\n    def _compute_state(self, up_to_change):\n        state = {}\n        for i in range(up_to_change):\n            event_type, event_id = self.events[i]\n            if event_type == 'alloc':\n                state[event_id] = True\n            elif event_type == 'dealloc' and event_id in state:\n                del state[event_id]\n        return state\n\n    def get_state_after_change(self, change_index):\n        nearest_snapshot_index = (change_index // self.snapshot_interval) * self.snapshot_interval\n        state = self.snapshots.get(nearest_snapshot_index, {})\n        \n        for i in range(nearest_snapshot_index, change_index):\n            event_type, event_id = self.events[i]\n            if event_type == 'alloc':\n                state[event_id] = True\n            elif event_type == 'dealloc' and event_id in state:\n                del state[event_id]\n        \n        return state\n\n# Example usage\ntracker = AllocatorTracker()\n\n# Simulate adding events\nfor i in range(1, 10001):\n    if i % 2 == 0:\n        tracker.add_event('alloc', f'id_{i}')\n    else:\n        tracker.add_event('dealloc', f'id_{i-1}')\n\n# Get the state after the 9000th change\nstate_after_9000 = tracker.get_state_after_change(9000)\nprint(state_after_9000)