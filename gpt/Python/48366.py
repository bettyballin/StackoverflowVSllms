class Edge:\n    def __init__(self, p1, p2):\n        self.p1 = p1\n        self.p2 = p2\n\n    def __eq__(self, other):\n        return (self.p1 == other.p1 and self.p2 == other.p2) or (self.p1 == other.p2 and self.p2 == other.p1)\n\n    def __hash__(self):\n        return hash((min(self.p1, self.p2), max(self.p1, self.p2)))\n\ndef find_contour(triangles):\n    edge_count = {}\n    \n    # Count occurrences of each edge\n    for triangle in triangles:\n        edges = [Edge(triangle[i], triangle[(i + 1) % 3]) for i in range(3)]\n        for edge in edges:\n            if edge in edge_count:\n                edge_count[edge] += 1\n            else:\n                edge_count[edge] = 1\n\n    # Collect boundary edges (those appearing only once)\n    boundary_edges = [edge for edge, count in edge_count.items() if count == 1]\n    \n    # Group edges into contours (outer boundary and holes)\n    contours = group_edges_into_contours(boundary_edges)\n    \n    return contours\n\ndef group_edges_into_contours(edges):\n    contours = []\n    while edges:\n        contour = []\n        edge = edges.pop()\n        contour.append(edge.p1)\n        contour.append(edge.p2)\n        \n        while True:\n            for i, next_edge in enumerate(edges):\n                if next_edge.p1 == contour[-1]:\n                    contour.append(next_edge.p2)\n                    edges.pop(i)\n                    break\n                elif next_edge.p2 == contour[-1]:\n                    contour.append(next_edge.p1)\n                    edges.pop(i)\n                    break\n            else:\n                break\n        \n        contours.append(contour)\n    \n    return contours\n\n# Example usage\ntriangles = [\n    ((0, 0), (1, 0), (0, 1)),\n    ((1, 0), (1, 1), (0, 1)),\n    # Add more triangles here\n]\n\ncontours = find_contour(triangles)\nfor contour in contours:\n    print("Contour:", contour)