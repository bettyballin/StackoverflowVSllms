import asyncio\nimport aiofiles\nimport pickle\nfrom queue import Queue\nfrom threading import Lock\n\nclass PersistentQueue:\n    def __init__(self, backup_file):\n        self.queue = Queue()\n        self.backup_file = backup_file\n        self.lock = Lock()\n\n    async def enqueue(self, item):\n        with self.lock:\n            self.queue.put(item)\n            await self._backup()\n\n    async def dequeue(self):\n        with self.lock:\n            if not self.queue.empty():\n                item = self.queue.get()\n                await self._backup()\n                return item\n                \n    async def _backup(self):\n        async with aiofiles.open(self.backup_file, 'wb') as f:\n            await f.write(pickle.dumps(list(self.queue.queue)))\n\n    async def restore(self):\n        async with aiofiles.open(self.backup_file, 'rb') as f:\n            data = await f.read()\n            items = pickle.loads(data)\n            with self.lock:\n                for item in items:\n                    self.queue.put(item)\n\n# Example usage:\nasync def main():\n    pq = PersistentQueue('queue_backup.pkl')\n    await pq.restore()\n    await pq.enqueue("task1")\n    await pq.enqueue("task2")\n    print(await pq.dequeue())\n\nasyncio.run(main())