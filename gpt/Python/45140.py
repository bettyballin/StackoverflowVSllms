from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.backends import default_backend\nimport os\n\n# Key should be either 16, 24, or 32 bytes long\nkey = os.urandom(32)  # 256-bit key for AES\niv = os.urandom(16)   # Initialization vector for CBC mode\n\ndef encrypt_order_number(order_number):\n    # Convert the order number to bytes\n    order_bytes = order_number.to_bytes((order_number.bit_length() + 7) // 8, byteorder='big')\n    \n    # Pad the order number to be a multiple of the block size\n    padder = padding.PKCS7(128).padder()\n    padded_data = padder.update(order_bytes) + padder.finalize()\n    \n    # Encrypt the padded order number\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\n    encryptor = cipher.encryptor()\n    encrypted_data = encryptor.update(padded_data) + encryptor.finalize()\n    \n    # Return encrypted data along with IV for decryption\n    return iv + encrypted_data\n\ndef decrypt_order_number(encrypted_data):\n    iv = encrypted_data[:16]\n    encrypted_order_number = encrypted_data[16:]\n    \n    # Decrypt the data\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend())\n    decryptor = cipher.decryptor()\n    decrypted_padded_data = decryptor.update(encrypted_order_number) + decryptor.finalize()\n    \n    # Unpad the decrypted data\n    unpadder = padding.PKCS7(128).unpadder()\n    decrypted_data = unpadder.update(decrypted_padded_data) + unpadder.finalize()\n    \n    # Convert bytes back to integer\n    order_number = int.from_bytes(decrypted_data, byteorder='big')\n    return order_number\n\n# Example usage\norder_number = 12345\nencrypted_data = encrypt_order_number(order_number)\nprint(f"Encrypted order number: {encrypted_data}")\n\ndecrypted_order_number = decrypt_order_number(encrypted_data)\nprint(f"Decrypted order number: {decrypted_order_number}")