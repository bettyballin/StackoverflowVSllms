class TreeNode:\n    def __init__(self, triangles, left=None, right=None):\n        self.triangles = triangles\n        self.left = left\n        self.right = right\n\ndef tree_depth(node):\n    if not node:\n        return 0\n    return max(tree_depth(node.left), tree_depth(node.right)) + 1\n\ndef count_splits(node):\n    if not node:\n        return 0\n    splits = 1 if node.left or node.right else 0\n    return splits + count_splits(node.left) + count_splits(node.right)\n\ndef is_balanced(node):\n    if not node:\n        return True, 0\n    left_balanced, left_height = is_balanced(node.left)\n    right_balanced, right_height = is_balanced(node.right)\n    balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n    return balanced, max(left_height, right_height) + 1\n\ndef evaluate_bsp_tree(root):\n    n = len(root.triangles)\n    depth = tree_depth(root)\n    splits = count_splits(root)\n    balanced, _ = is_balanced(root)\n    \n    log2_n = math.log2(n)\n    is_depth_optimal = depth <= log2_n + 1\n    is_balanced_tree = balanced\n    \n    print(f"Tree Depth: {depth}")\n    print(f"Splits: {splits}")\n    print(f"Is Depth Optimal: {is_depth_optimal}")\n    print(f"Is Balanced: {is_balanced_tree}")\n    \n    # You can define further conditions to decide if the tree is optimal\n    # For example:\n    return is_depth_optimal and is_balanced_tree\n\n# Usage\nimport math\n\n# Assume `root` is the root node of your BSP tree\n# root = TreeNode(...)\n\n# Evaluate the BSP tree\nis_optimal = evaluate_bsp_tree(root)\nprint(f"Is the BSP tree optimal? {is_optimal}")