import numpy as np\n\ndef gaussian_elimination_binary(A, b):\n    n = len(b)\n    for i in range(n):\n        if A[i][i] == 0:\n            for j in range(i + 1, n):\n                if A[j][i] == 1:\n                    A[i], A[j] = A[j], A[i]\n                    b[i], b[j] = b[j], b[i]\n                    break\n        if A[i][i] == 0:\n            continue\n        for j in range(i + 1, n):\n            if A[j][i] == 1:\n                A[j] = (A[j] + A[i]) % 2\n                b[j] = (b[j] + b[i]) % 2\n\n    x = np.zeros(n, dtype=int)\n    for i in range(n - 1, -1, -1):\n        if A[i][i] == 0:\n            if b[i] == 1:\n                return None  # No solution\n            continue\n        x[i] = b[i]\n        for j in range(i - 1, -1, -1):\n            b[j] = (b[j] + A[j][i] * x[i]) % 2\n\n    return x\n\ndef is_solvable(matrix, initial_state):\n    size = len(initial_state)\n    A = np.zeros((size, size), dtype=int)\n    b = np.array(initial_state, dtype=int)\n\n    # Fill the matrix A with the game rules\n    for i in range(size):\n        for j in range(size):\n            if i == j or (i, j) in neighbors(i, size):  # Adjust the neighbors function as per the game rules\n                A[i][j] = 1\n\n    solution = gaussian_elimination_binary(A, b)\n    return solution is not None\n\ndef neighbors(index, size):\n    # Define the neighbor logic based on the game rules\n    # For example, for a 3x3 grid, you might want to return the indices of the neighbors\n    # Adjust this function according to the actual rules of the game\n    # This is just a placeholder\n    return [(index - 1) % size, (index + 1) % size]\n\n# Example usage\ninitial_state = [1, 0, 1, 0, 1, 0, 1, 0, 1]  # Example initial state for a 3x3 grid flattened\nmatrix = [\n    [1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 0, 0, 0, 0],\n    # Define the rest of the matrix based on the game rules\n]\n\nprint(is_solvable(matrix, initial_state))