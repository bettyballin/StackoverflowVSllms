class NDFSM:\n    def __init__(self):\n        self.transitions = {}\n        self.start_state = None\n        self.accept_states = set()\n\n    def add_transition(self, current_state, input_char, next_states):\n        if current_state not in self.transitions:\n            self.transitions[current_state] = {}\n        if input_char not in self.transitions[current_state]:\n            self.transitions[current_state][input_char] = set()\n        self.transitions[current_state][input_char].update(next_states)\n\n    def set_start_state(self, state):\n        self.start_state = state\n\n    def add_accept_state(self, state):\n        self.accept_states.add(state)\n\n    def accepts(self, input_string):\n        def dfs(current_states, remaining_input):\n            if not remaining_input:\n                return any(state in self.accept_states for state in current_states)\n            next_states = set()\n            for state in current_states:\n                if state in self.transitions and remaining_input[0] in self.transitions[state]:\n                    next_states.update(self.transitions[state][remaining_input[0]])\n            return dfs(next_states, remaining_input[1:])\n\n        return dfs({self.start_state}, input_string)\n\n# Example usage\nndfsm = NDFSM()\nndfsm.set_start_state('q0')\nndfsm.add_accept_state('q2')\nndfsm.add_transition('q0', 'a', {'q0', 'q1'})\nndfsm.add_transition('q1', 'b', {'q2'})\nprint(ndfsm.accepts("aab"))  # True\nprint(ndfsm.accepts("ab"))   # True\nprint(ndfsm.accepts("a"))    # False