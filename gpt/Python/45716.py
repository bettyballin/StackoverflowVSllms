def find_idle_time(total_start, total_end, jobs):\n    # Sort jobs by start time\n    jobs.sort(key=lambda x: x[0])\n    \n    # Merge overlapping intervals\n    merged_intervals = []\n    current_start, current_end = jobs[0]\n    \n    for start, end in jobs[1:]:\n        if start <= current_end:  # Overlapping intervals\n            current_end = max(current_end, end)\n        else:  # No overlap, push the interval and reset\n            merged_intervals.append((current_start, current_end))\n            current_start, current_end = start, end\n    \n    # Append the last interval\n    merged_intervals.append((current_start, current_end))\n    \n    # Calculate total busy time\n    busy_time = sum(end - start for start, end in merged_intervals)\n    \n    # Total time span\n    total_time_span = total_end - total_start\n    \n    # Calculate idle time\n    idle_time = total_time_span - busy_time\n    \n    return idle_time\n\n# Example usage\ntotal_start = 1\ntotal_end = 10\njobs = [(1, 3), (2, 5), (6, 8)]\nprint(find_idle_time(total_start, total_end, jobs))  # Output: 3