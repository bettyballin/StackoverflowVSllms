#include <boost/thread.hpp>\n#include <queue>\n#include <iostream>\n\nboost::mutex access;\nboost::condition_variable cond;\nstd::queue<data> queue;\n\n// consumer\ndata read() {\n    boost::mutex::scoped_lock lock(access);\n\n    // this blocks until the data is ready\n    while (queue.empty()) {\n        cond.wait(lock);\n    }\n\n    // queue is ready\n    data d = queue.front();\n    queue.pop();\n    return d;\n}\n\n// producer\nbool push(data d) {\n    boost::mutex::scoped_lock lock(access, boost::try_to_lock);\n\n    // Check if lock was acquired\n    if (!lock) {\n        return false; // Indicate that push did not happen due to lock contention\n    }\n\n    // add data to queue\n    queue.push(d);\n    cond.notify_one();\n    return true; // Indicate successful push\n}\n\n// Example usage\nint main() {\n    // Initialize and use threads to call read() and push() methods.\n}