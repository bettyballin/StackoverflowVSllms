#include <windows.h>\n#include <wininet.h>\n#include <iostream>\n\n#pragma comment(lib, "wininet.lib")\n\nvoid FindCacheEntry(const std::wstring& fileName)\n{\n    DWORD bufferSize = 0;\n    HANDLE hCache = FindFirstUrlCacheEntry(NULL, NULL, &bufferSize);\n\n    if (hCache == NULL && GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n    {\n        LPINTERNET_CACHE_ENTRY_INFO cacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) new BYTE[bufferSize];\n        hCache = FindFirstUrlCacheEntry(NULL, cacheEntry, &bufferSize);\n\n        if (hCache != NULL)\n        {\n            do\n            {\n                if (cacheEntry->lpszLocalFileName && fileName == cacheEntry->lpszLocalFileName)\n                {\n                    std::wcout << L"URL: " << cacheEntry->lpszSourceUrlName << std::endl;\n                    break;\n                }\n\n                bufferSize = 0;\n                if (!FindNextUrlCacheEntry(hCache, cacheEntry, &bufferSize) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)\n                {\n                    delete[] cacheEntry;\n                    cacheEntry = (LPINTERNET_CACHE_ENTRY_INFO) new BYTE[bufferSize];\n                    FindNextUrlCacheEntry(hCache, cacheEntry, &bufferSize);\n                }\n            } while (GetLastError() != ERROR_NO_MORE_ITEMS);\n\n            delete[] cacheEntry;\n        }\n        FindCloseUrlCache(hCache);\n    }\n}\n\nint main()\n{\n    std::wstring fileName = L"C:\\Path\\To\\Your\\Temporary\\File.docx";\n    FindCacheEntry(fileName);\n    return 0;\n}