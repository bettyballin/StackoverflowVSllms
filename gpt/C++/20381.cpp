#include <windows.h>\n#include <string>\n#include <vector>\n#include <iostream>\n\nstd::string ExecuteProcess(const std::string& command) {\n    // Create pipes for the process's standard output\n    HANDLE hStdOutRead, hStdOutWrite;\n    SECURITY_ATTRIBUTES sa = {};\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.bInheritHandle = TRUE;\n    sa.lpSecurityDescriptor = NULL;\n\n    if (!CreatePipe(&hStdOutRead, &hStdOutWrite, &sa, 0)) {\n        throw std::runtime_error("Failed to create pipe");\n    }\n\n    // Ensure the read handle to the pipe is not inherited\n    if (!SetHandleInformation(hStdOutRead, HANDLE_FLAG_INHERIT, 0)) {\n        CloseHandle(hStdOutRead);\n        CloseHandle(hStdOutWrite);\n        throw std::runtime_error("Failed to set handle information");\n    }\n\n    // Set up the STARTUPINFO structure\n    STARTUPINFO si = {};\n    si.cb = sizeof(STARTUPINFO);\n    si.hStdOutput = hStdOutWrite;\n    si.hStdError = hStdOutWrite; // Redirect stderr to stdout\n    si.dwFlags |= STARTF_USESTDHANDLES;\n\n    PROCESS_INFORMATION pi = {};\n\n    // Create the process\n    if (!CreateProcess(NULL, const_cast<char*>(command.c_str()), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n        CloseHandle(hStdOutRead);\n        CloseHandle(hStdOutWrite);\n        throw std::runtime_error("Failed to create process");\n    }\n\n    // Close the write end of the pipe in this process\n    CloseHandle(hStdOutWrite);\n\n    // Read the process's output\n    std::vector<char> outputBuffer;\n    char buffer[4096];\n    DWORD bytesRead;\n\n    while (ReadFile(hStdOutRead, buffer, sizeof(buffer) - 1, &bytesRead, NULL) && bytesRead > 0) {\n        buffer[bytesRead] = '\0';\n        outputBuffer.insert(outputBuffer.end(), buffer, buffer + bytesRead);\n    }\n\n    // Wait for the process to finish\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Close handles\n    CloseHandle(hStdOutRead);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return std::string(outputBuffer.begin(), outputBuffer.end());\n}\n\nint main() {\n    try {\n        std::string output = ExecuteProcess("cmd.exe /c echo Hello, World!");\n        std::cout << "Process output: " << output << std::endl;\n    } catch (const std::exception& ex) {\n        std::cerr << "Error: " << ex.what() << std::endl;\n    }\n    return 0;\n}