#include <Windows.h>\n#include <iostream>\n\nint main() {\n    // Create a job object\n    HANDLE hJob = CreateJobObject(NULL, NULL);\n    if (hJob == NULL) {\n        std::cerr << "Failed to create job object: " << GetLastError() << std::endl;\n        return 1;\n    }\n\n    // Set the job object extended limit information\n    JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {0};\n    jeli.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n    if (!SetInformationJobObject(hJob, JobObjectExtendedLimitInformation, &jeli, sizeof(jeli))) {\n        std::cerr << "Failed to set job object information: " << GetLastError() << std::endl;\n        CloseHandle(hJob);\n        return 1;\n    }\n\n    // Launch child process\n    STARTUPINFO si = {sizeof(si)};\n    PROCESS_INFORMATION pi;\n\n    if (!CreateProcess(NULL, L"child_process.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {\n        std::cerr << "Failed to create child process: " << GetLastError() << std::endl;\n        CloseHandle(hJob);\n        return 1;\n    }\n\n    // Assign the child process to the job object\n    if (!AssignProcessToJobObject(hJob, pi.hProcess)) {\n        std::cerr << "Failed to assign process to job object: " << GetLastError() << std::endl;\n        TerminateProcess(pi.hProcess, 1);\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n        CloseHandle(hJob);\n        return 1;\n    }\n\n    // Resume the child process\n    ResumeThread(pi.hThread);\n\n    // Wait for the child process to complete (for demonstration purposes)\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Clean up handles\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n    CloseHandle(hJob);\n\n    return 0;\n}