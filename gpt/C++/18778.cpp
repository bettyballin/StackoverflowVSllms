#include <iostream>\n#include <thread>\n#include <future>\n#include <chrono>\n#include <stdexcept>\n\nbool run_with_timeout(std::function<void()> func, unsigned int timeout_seconds) {\n    std::packaged_task<void()> task(func);\n    std::future<void> future = task.get_future();\n    std::thread task_thread(std::move(task));\n    \n    if (future.wait_for(std::chrono::seconds(timeout_seconds)) == std::future_status::timeout) {\n        // Timeout occurred\n        task_thread.detach(); // Detach the thread to allow it to finish on its own\n        return false;\n    } else {\n        // Function completed within the timeout\n        task_thread.join(); // Ensure the thread has finished\n        return true;\n    }\n}\n\nvoid my_function() {\n    // Simulate a long-running task\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n}\n\nint main() {\n    unsigned int timeout_seconds = 3;\n\n    if (run_with_timeout(my_function, timeout_seconds)) {\n        std::cout << "Function completed within the timeout." << std::endl;\n    } else {\n        std::cout << "Function timed out." << std::endl;\n    }\n\n    return 0;\n}