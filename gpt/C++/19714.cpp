#include <iostream>\n#include <thread>\n#include <vector>\n#include <shared_mutex>\n#include <cassert>\n\nclass ReadWriteLock {\npublic:\n    void read_lock() {\n        rw_lock.lock_shared();\n    }\n    void read_unlock() {\n        rw_lock.unlock_shared();\n    }\n    void write_lock() {\n        rw_lock.lock();\n    }\n    void write_unlock() {\n        rw_lock.unlock();\n    }\n\nprivate:\n    std::shared_mutex rw_lock;\n};\n\nvoid reader(ReadWriteLock& lock, int& shared_data) {\n    lock.read_lock();\n    // Simulate some read operation\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    assert(shared_data == 42); // Check shared data is consistent\n    lock.read_unlock();\n}\n\nvoid writer(ReadWriteLock& lock, int& shared_data) {\n    lock.write_lock();\n    // Simulate some write operation\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    shared_data = 42;\n    lock.write_unlock();\n}\n\nint main() {\n    ReadWriteLock lock;\n    int shared_data = 0;\n\n    // Start writer thread\n    std::thread writer_thread(writer, std::ref(lock), std::ref(shared_data));\n    writer_thread.join();\n\n    // Start multiple reader threads\n    std::vector<std::thread> reader_threads;\n    for (int i = 0; i < 10; ++i) {\n        reader_threads.emplace_back(reader, std::ref(lock), std::ref(shared_data));\n    }\n\n    for (auto& thread : reader_threads) {\n        thread.join();\n    }\n\n    std::cout << "All tests passed!" << std::endl;\n    return 0;\n}