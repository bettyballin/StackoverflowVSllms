template<typename T>\n   class arena_ptr {\n   public:\n       explicit arena_ptr(Arena& a) : arena(a), ptr(nullptr) {}\n       ~arena_ptr() { if (ptr) arena.deallocate(ptr); }\n\n       void allocate(std::size_t size = 1) {\n           ptr = static_cast<T*>(arena.allocate(size * sizeof(T)));\n           for (std::size_t i = 0; i < size; ++i) {\n               new (ptr + i) T();\n           }\n       }\n\n       T* get() const { return ptr; }\n\n   private:\n       Arena& arena;\n       T* ptr;\n   };\n\n   // Usage\n   Arena a;\n   arena_ptr<char> string(a); string.allocate(80);\n   arena_ptr<int> intp(a); intp.allocate();\n   arena_ptr<foo> fp(a); fp.allocate();