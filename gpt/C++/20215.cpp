#include <iostream>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <string>\n\nstruct Node {\n    std::string key;\n    int value;\n\n    Node() = default;\n    Node(std::string k, int v) : key(k), value(v) {}\n\n    // Serialize a node to an output stream\n    void serialize(std::ofstream &out) const {\n        size_t key_size = key.size();\n        out.write(reinterpret_cast<const char*>(&key_size), sizeof(key_size));\n        out.write(key.c_str(), key_size);\n        out.write(reinterpret_cast<const char*>(&value), sizeof(value));\n    }\n\n    // Deserialize a node from an input stream\n    void deserialize(std::ifstream &in) {\n        size_t key_size;\n        in.read(reinterpret_cast<char*>(&key_size), sizeof(key_size));\n        key.resize(key_size);\n        in.read(&key[0], key_size);\n        in.read(reinterpret_cast<char*>(&value), sizeof(value));\n    }\n};\n\nclass HashTable {\nprivate:\n    std::vector<std::list<Node>> table;\n    size_t capacity;\n\npublic:\n    HashTable(size_t cap) : capacity(cap), table(cap) {}\n\n    // Insert key-value pair into the hash table\n    void insert(const std::string &key, int value) {\n        size_t index = std::hash<std::string>{}(key) % capacity;\n        table[index].emplace_back(key, value);\n    }\n\n    // Serialize the hash table to a file\n    void serialize(const std::string &filename) const {\n        std::ofstream out(filename, std::ios::binary);\n        if (!out.is_open()) {\n            throw std::runtime_error("Cannot open file for writing");\n        }\n        out.write(reinterpret_cast<const char*>(&capacity), sizeof(capacity));\n        for (const auto &chain : table) {\n            size_t chain_size = chain.size();\n            out.write(reinterpret_cast<const char*>(&chain_size), sizeof(chain_size));\n            for (const auto &node : chain) {\n                node.serialize(out);\n            }\n        }\n        out.close();\n    }\n\n    // Deserialize the hash table from a file\n    void deserialize(const std::string &filename) {\n        std::ifstream in(filename, std::ios::binary);\n        if (!in.is_open()) {\n            throw std::runtime_error("Cannot open file for reading");\n        }\n        in.read(reinterpret_cast<char*>(&capacity), sizeof(capacity));\n        table.resize(capacity);\n        for (auto &chain : table) {\n            size_t chain_size;\n            in.read(reinterpret_cast<char*>(&chain_size), sizeof(chain_size));\n            for (size_t i = 0; i < chain_size; ++i) {\n                Node node;\n                node.deserialize(in);\n                chain.push_back(node);\n            }\n        }\n        in.close();\n    }\n};\n\nint main() {\n    // Example usage\n    HashTable ht(10);\n    ht.insert("key1", 100);\n    ht.insert("key2", 200);\n\n    // Serialize to file\n    ht.serialize("hash_table.dat");\n\n    // Deserialize from file\n    HashTable loaded_ht(10); // Initial capacity doesn't matter, will be overwritten\n    loaded_ht.deserialize("hash_table.dat");\n\n    // You can now use loaded_ht as the hash table loaded from the file\n    return 0;\n}