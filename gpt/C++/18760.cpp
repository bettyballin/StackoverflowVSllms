#include <windows.h>\n#include <tlhelp32.h>\n#include <tchar.h>\n#include <iostream>\n\nDWORD GetProcessIdByName(const TCHAR* processName) {\n    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hSnapshot == INVALID_HANDLE_VALUE) {\n        return 0;\n    }\n\n    PROCESSENTRY32 pe;\n    pe.dwSize = sizeof(PROCESSENTRY32);\n\n    if (Process32First(hSnapshot, &pe)) {\n        do {\n            if (_tcsicmp(pe.szExeFile, processName) == 0) {\n                CloseHandle(hSnapshot);\n                return pe.th32ProcessID;\n            }\n        } while (Process32Next(hSnapshot, &pe));\n    }\n\n    CloseHandle(hSnapshot);\n    return 0;\n}\n\nint main() {\n    const TCHAR* processName = _T("example.exe");\n    DWORD processId = GetProcessIdByName(processName);\n\n    if (processId == 0) {\n        std::cerr << "Process not found." << std::endl;\n        return 1;\n    }\n\n    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processId);\n    if (hProcess == NULL) {\n        std::cerr << "Failed to open process." << std::endl;\n        return 1;\n    }\n\n    if (TerminateProcess(hProcess, 0)) {\n        std::cout << "Process terminated successfully." << std::endl;\n    } else {\n        std::cerr << "Failed to terminate process." << std::endl;\n    }\n\n    CloseHandle(hProcess);\n    return 0;\n}