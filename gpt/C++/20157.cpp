#include <windows.h>\n#include <iostream>\n\nLRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n    if (uMsg == WM_INPUT)\n    {\n        UINT dwSize = 0;\n        GetRawInputData((HRAWINPUT)lParam, RID_INPUT, NULL, &dwSize, sizeof(RAWINPUTHEADER));\n        LPBYTE lpb = new BYTE[dwSize];\n        if (lpb == NULL)\n        {\n            return 0;\n        }\n\n        if (GetRawInputData((HRAWINPUT)lParam, RID_INPUT, lpb, &dwSize, sizeof(RAWINPUTHEADER)) != dwSize)\n        {\n            std::cerr << "GetRawInputData does not return correct size !" << std::endl;\n        }\n\n        RAWINPUT* raw = (RAWINPUT*)lpb;\n\n        if (raw->header.dwType == RIM_TYPEKEYBOARD)\n        {\n            RAWKEYBOARD rawKeyboard = raw->data.keyboard;\n            std::cout << "Keyboard Handle: " << raw->header.hDevice << std::endl;\n            std::cout << "Scan Code: " << rawKeyboard.MakeCode << std::endl;\n            std::cout << "Virtual Key: " << rawKeyboard.VKey << std::endl;\n        }\n\n        delete[] lpb;\n    }\n    return DefWindowProc(hwnd, uMsg, wParam, lParam);\n}\n\nint main()\n{\n    HINSTANCE hInstance = GetModuleHandle(NULL);\n    WNDCLASS wc = { 0 };\n    wc.lpfnWndProc = WindowProc;\n    wc.hInstance = hInstance;\n    wc.lpszClassName = L"RawInputClass";\n    RegisterClass(&wc);\n\n    HWND hwnd = CreateWindowEx(0, L"RawInputClass", L"Raw Input Window", 0, 0, 0, 0, 0, HWND_MESSAGE, NULL, hInstance, NULL);\n\n    RAWINPUTDEVICE rid[1];\n    rid[0].usUsagePage = 0x01;\n    rid[0].usUsage = 0x06;\n    rid[0].dwFlags = RIDEV_INPUTSINK;\n    rid[0].hwndTarget = hwnd;\n\n    if (RegisterRawInputDevices(rid, 1, sizeof(rid[0])) == FALSE)\n    {\n        std::cerr << "Failed to register raw input device." << std::endl;\n        return -1;\n    }\n\n    MSG msg;\n    while (GetMessage(&msg, NULL, 0, 0))\n    {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n\n    return 0;\n}