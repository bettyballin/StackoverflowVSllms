#include <windows.h>\n#include <iostream>\n\nvoid LaunchAndWait(LPCWSTR lpFile) {\n    SHELLEXECUTEINFO sei = { sizeof(sei) };\n    sei.fMask = SEE_MASK_NOCLOSEPROCESS;\n    sei.lpVerb = L"open";\n    sei.lpFile = lpFile;\n    sei.nShow = SW_SHOWNORMAL;\n\n    if (!ShellExecuteEx(&sei)) {\n        std::cerr << "ShellExecuteEx failed: " << GetLastError() << std::endl;\n        return;\n    }\n\n    HANDLE hJob = CreateJobObject(NULL, NULL);\n    if (hJob == NULL) {\n        std::cerr << "CreateJobObject failed: " << GetLastError() << std::endl;\n        CloseHandle(sei.hProcess);\n        return;\n    }\n\n    JOBOBJECT_EXTENDED_LIMIT_INFORMATION jobInfo = { 0 };\n    jobInfo.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n    if (!SetInformationJobObject(hJob, JobObjectExtendedLimitInformation, &jobInfo, sizeof(jobInfo))) {\n        std::cerr << "SetInformationJobObject failed: " << GetLastError() << std::endl;\n        CloseHandle(hJob);\n        CloseHandle(sei.hProcess);\n        return;\n    }\n\n    if (!AssignProcessToJobObject(hJob, sei.hProcess)) {\n        std::cerr << "AssignProcessToJobObject failed: " << GetLastError() << std::endl;\n        CloseHandle(hJob);\n        CloseHandle(sei.hProcess);\n        return;\n    }\n\n    WaitForSingleObject(sei.hProcess, INFINITE);\n\n    // Clean up\n    CloseHandle(hJob);\n    CloseHandle(sei.hProcess);\n}\n\nint main() {\n    LaunchAndWait(L"Uninstall.lnk");\n    return 0;\n}