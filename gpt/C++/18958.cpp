#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <new>\n#include <dlfcn.h>\n#include "base.hpp"\n\nvoid* operator new(size_t size) {\n    std::printf("New of client called\n");\n    void *p = std::malloc(size);\n    if (p == 0) // did malloc succeed?\n        throw std::bad_alloc(); // ANSI/ISO compliant behavior\n    return p;\n}\n\nvoid operator delete(void* p) {\n    std::printf("Delete of client called\n");\n    std::free(p);\n}\n\ntypedef Base* create_module_t();\ntypedef void destroy_module_t(Base *);\n\nint main() {\n    void* handle = dlopen("./library.so", RTLD_LAZY | RTLD_DEEPBIND);\n    if (handle == NULL) {\n        std::cout << dlerror() << std::endl;\n        return 1;\n    }\n    \n    create_module_t* create_module = nullptr;\n    void* func = dlsym(handle, "create");\n    if (func == NULL) {\n        std::cout << dlerror() << std::endl;\n        return 1;\n    } else {\n        create_module = (create_module_t *)func;\n    }\n\n    destroy_module_t* destroy_module = nullptr;\n    func = dlsym(handle, "destroy");\n    if (func == NULL) {\n        std::cout << dlerror() << std::endl;\n        return 1;\n    } else {\n        destroy_module = (destroy_module_t *)func;\n    }\n\n    Base* obj = create_module();\n    std::cout << "Value: " << obj->get_value() << std::endl;\n    destroy_module(obj);\n\n    dlclose(handle);\n\n    return 0;\n}