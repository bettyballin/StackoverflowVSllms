#include <windows.h>\n#include <iostream>\n\nint LaunchProcessFromService(const char* path, const char* args) {\n    STARTUPINFO si = { sizeof(si) };\n    PROCESS_INFORMATION pi;\n\n    // Initialize memory for STARTUPINFO\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n    ZeroMemory(&pi, sizeof(pi));\n\n    // Create the process\n    if (!CreateProcess(path, (LPSTR)args, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n        std::cerr << "CreateProcess failed with error: " << GetLastError() << std::endl;\n        return -1;\n    }\n\n    // Wait for the process to complete\n    DWORD waitResult = WaitForSingleObject(pi.hProcess, INFINITE);\n    if (waitResult != WAIT_OBJECT_0) {\n        std::cerr << "WaitForSingleObject failed with error: " << GetLastError() << std::endl;\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n        return -1;\n    }\n\n    // Retrieve the exit code\n    DWORD exitCode;\n    if (!GetExitCodeProcess(pi.hProcess, &exitCode)) {\n        std::cerr << "GetExitCodeProcess failed with error: " << GetLastError() << std::endl;\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n        return -1;\n    }\n\n    // Close process and thread handles\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return exitCode;\n}\n\nint main() {\n    const char* path = "C:\\Path\\To\\Your\\App.exe";\n    const char* args = "\"C:\\Path\\To\\Your\\App.exe\" \"your arguments\"";\n\n    int result = LaunchProcessFromService(path, args);\n    std::cout << "Process exited with code: " << result << std::endl;\n\n    return 0;\n}