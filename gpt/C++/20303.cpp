#include <iostream>\n#include <sql.h>\n#include <sqlext.h>\n\nvoid checkError(SQLRETURN ret, SQLHANDLE handle, SQLSMALLINT type) {\n    if (ret != SQL_SUCCESS && ret != SQL_SUCCESS_WITH_INFO) {\n        SQLCHAR sqlState[1024];\n        SQLCHAR message[1024];\n        if (SQLGetDiagRec(type, handle, 1, sqlState, NULL, message, 1024, NULL) == SQL_SUCCESS) {\n            std::cerr << "Message: " << message << "\nSQL State: " << sqlState << std::endl;\n        }\n    }\n}\n\nint main() {\n    SQLHENV env;\n    SQLHDBC dbc;\n    SQLHSTMT stmt;\n\n    SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &env);\n    SQLSetEnvAttr(env, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);\n    SQLAllocHandle(SQL_HANDLE_DBC, env, &dbc);\n\n    SQLCHAR outstr[1024];\n    SQLSMALLINT outstrlen;\n    SQLRETURN ret = SQLDriverConnect(dbc, NULL, (SQLCHAR*)"DSN=MyDataSource;UID=user;PWD=password;", SQL_NTS, outstr, sizeof(outstr), &outstrlen, SQL_DRIVER_COMPLETE);\n\n    checkError(ret, dbc, SQL_HANDLE_DBC);\n\n    SQLAllocHandle(SQL_HANDLE_STMT, dbc, &stmt);\n    ret = SQLExecDirect(stmt, (SQLCHAR*)"SELECT COUNT(*) FROM my_table", SQL_NTS);\n    checkError(ret, stmt, SQL_HANDLE_STMT);\n\n    SQLINTEGER count;\n    SQLBindCol(stmt, 1, SQL_C_SLONG, &count, 0, NULL);\n    while ((ret = SQLFetch(stmt)) != SQL_NO_DATA) {\n        std::cout << "Number of rows in my_table: " << count << std::endl;\n    }\n\n    SQLFreeHandle(SQL_HANDLE_STMT, stmt);\n    SQLDisconnect(dbc);\n    SQLFreeHandle(SQL_HANDLE_DBC, dbc);\n    SQLFreeHandle(SQL_HANDLE_ENV, env);\n\n    return 0;\n}