#include <boost/spirit/include/qi.hpp>\n#include <boost/phoenix.hpp>\n#include <iostream>\n#include <string>\n#include <map>\n#include <functional>\n\nnamespace qi = boost::spirit::qi;\nnamespace phoenix = boost::phoenix;\n\nusing FunctionMap = std::map<std::string, std::function<double(double)>>;\n\ndouble square(double x) {\n    return x * x;\n}\n\ndouble cube(double x) {\n    return x * x * x;\n}\n\ntemplate <typename Iterator>\nstruct Calculator : qi::grammar<Iterator, double(), qi::ascii::space_type> {\n    Calculator(FunctionMap& functions) : Calculator::base_type(expression), functions(functions) {\n        using qi::double_;\n        using qi::lexeme;\n        using qi::lit;\n        using qi::_val;\n        using qi::_1;\n        using phoenix::ref;\n\n        expression = term[_val = _1] >> *(('+' >> term[_val += _1]) | ('-' >> term[_val -= _1]));\n        term = factor[_val = _1] >> *(('*' >> factor[_val *= _1]) | ('/' >> factor[_val /= _1]));\n        factor = double_[_val = _1] | ('(' >> expression[_val = _1] >> ')') |\n                 (function_call[_val = _1]);\n\n        function_call = (lexeme[+(qi::char_ - '(')] >> '(' >> expression >> ')')[_val = phoenix::bind(&Calculator::call_function, this, _1, _2)];\n    }\n\n    double call_function(const std::string& name, double arg) {\n        auto it = functions.find(name);\n        if (it != functions.end()) {\n            return it->second(arg);\n        }\n        throw std::runtime_error("Function not found: " + name);\n    }\n\n    qi::rule<Iterator, double(), qi::ascii::space_type> expression, term, factor, function_call;\n    FunctionMap& functions;\n};\n\nint main() {\n    std::string input;\n    FunctionMap functions = {\n        {"square", square},\n        {"cube", cube}\n    };\n\n    std::cout << "Enter an expression: ";\n    std::getline(std::cin, input);\n\n    Calculator<std::string::const_iterator> calc(functions);\n    double result;\n    auto it = input.begin();\n    bool success = qi::phrase_parse(it, input.end(), calc, qi::ascii::space, result);\n\n    if (success && it == input.end()) {\n        std::cout << "Result: " << result << std::endl;\n    } else {\n        std::cout << "Parsing failed. Remaining input: " << std::string(it, input.end()) << std::endl;\n    }\n\n    return 0;\n}