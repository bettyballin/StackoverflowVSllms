#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nclass ScopedKey {\npublic:\n    ScopedKey(const std::vector<uint8_t>& obfuscated_key, uint8_t mask) \n        : key_(obfuscated_key.size()), mask_(mask) {\n        // De-obfuscate the key\n        std::transform(obfuscated_key.begin(), obfuscated_key.end(), key_.begin(),\n                       [this](uint8_t byte) { return byte ^ mask_; });\n    }\n    \n    ~ScopedKey() {\n        // Clear the key from memory\n        std::fill(key_.begin(), key_.end(), 0);\n    }\n\n    const std::vector<uint8_t>& get() const {\n        return key_;\n    }\n\nprivate:\n    std::vector<uint8_t> key_;\n    uint8_t mask_;\n};\n\nint main() {\n    // Example key and mask\n    std::vector<uint8_t> obfuscated_key = { 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF };\n    uint8_t mask = 0xAA;\n\n    // Use the scoped key\n    {\n        ScopedKey key(obfuscated_key, mask);\n        const std::vector<uint8_t>& decrypted_key = key.get();\n\n        // Use the decrypted key here\n        std::cout << "Decrypted key: ";\n        for (auto byte : decrypted_key) {\n            std::cout << std::hex << static_cast<int>(byte) << " ";\n        }\n        std::cout << std::endl;\n        // Key will be cleared from memory when 'key' goes out of scope\n    }\n\n    return 0;\n}