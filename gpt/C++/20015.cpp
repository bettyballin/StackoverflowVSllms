#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Structure to represent an edge with its weight\nstruct Edge {\n    int u, v, weight;\n    bool operator<(const Edge& other) const {\n        return weight > other.weight; // Sort in descending order of weights\n    }\n};\n\n// Function to switch nodes in the graph\nvoid switchNodes(vector<Edge>& edges, vector<vector<int>>& adjMatrix) {\n    vector<bool> switched(adjMatrix.size(), false);\n\n    for (auto& edge : edges) {\n        if (!switched[edge.u] && !switched[edge.v]) {\n            // Switch nodes u and v\n            swap(adjMatrix[edge.u], adjMatrix[edge.v]);\n\n            // Mark nodes as switched\n            switched[edge.u] = true;\n            switched[edge.v] = true;\n\n            // Reset the edge weight\n            edge.weight = 0;\n        }\n    }\n}\n\nint main() {\n    // Number of nodes\n    const int n = 4;\n\n    // Adjacency matrix to represent the graph\n    vector<vector<int>> adjMatrix(n, vector<int>(n, 0));\n    adjMatrix[0][1] = 100; adjMatrix[1][0] = 100;\n    adjMatrix[0][2] = 120; adjMatrix[2][0] = 120;\n    adjMatrix[1][3] = 220; adjMatrix[3][1] = 220;\n    adjMatrix[2][3] = 150; adjMatrix[3][2] = 150;\n\n    // List of edges with weights\n    vector<Edge> edges = {\n        {0, 1, 100},\n        {0, 2, 120},\n        {1, 3, 220},\n        {2, 3, 150}\n    };\n\n    // Sort edges by descending weight\n    sort(edges.begin(), edges.end());\n\n    // Perform node switching\n    switchNodes(edges, adjMatrix);\n\n    // Print the final layout (for demonstration purposes)\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cout << adjMatrix[i][j] << " ";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}