#include <windows.h>\n#include <tlhelp32.h>\n#include <iostream>\n\nvoid ListThreads(DWORD dwOwnerPID) {\n    HANDLE hThreadSnap = INVALID_HANDLE_VALUE; \n    THREADENTRY32 te32; \n\n    // Take a snapshot of all threads in the system.\n    hThreadSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); \n    if (hThreadSnap == INVALID_HANDLE_VALUE) {\n        std::cerr << "CreateToolhelp32Snapshot (of threads) failed" << std::endl;\n        return;\n    }\n\n    // Fill in the size of the structure before using it.\n    te32.dwSize = sizeof(THREADENTRY32); \n\n    // Retrieve information about the first thread,\n    // and exit if unsuccessful\n    if (!Thread32First(hThreadSnap, &te32)) {\n        std::cerr << "Thread32First failed" << std::endl;\n        CloseHandle(hThreadSnap);     // Must clean up the snapshot object!\n        return;\n    }\n\n    // Now walk the thread list of the system,\n    // and display information about each thread\n    // associated with the specified process\n    do {\n        if (te32.th32OwnerProcessID == dwOwnerPID) {\n            std::cout << "THREAD ID: " << te32.th32ThreadID << std::endl;\n        }\n    } while (Thread32Next(hThreadSnap, &te32)); \n\n    CloseHandle(hThreadSnap);\n}\n\nint main() {\n    DWORD processID = GetCurrentProcessId(); // Replace with the process ID you want to monitor\n    ListThreads(processID);\n    return 0;\n}