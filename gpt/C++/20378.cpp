#include <iostream>\n#include <deque>\n#include <vector>\n#include <algorithm>\n\ndouble findMaxRange(const std::vector<double>& data, int windowSize) {\n    std::deque<int> maxDeque, minDeque;\n    double maxRange = 0.0;\n\n    for (int i = 0; i < data.size(); ++i) {\n        // Remove elements outside the current window\n        if (!maxDeque.empty() && maxDeque.front() <= i - windowSize) {\n            maxDeque.pop_front();\n        }\n        if (!minDeque.empty() && minDeque.front() <= i - windowSize) {\n            minDeque.pop_front();\n        }\n\n        // Maintain the descending order for maxDeque\n        while (!maxDeque.empty() && data[maxDeque.back()] <= data[i]) {\n            maxDeque.pop_back();\n        }\n        maxDeque.push_back(i);\n\n        // Maintain the ascending order for minDeque\n        while (!minDeque.empty() && data[minDeque.back()] >= data[i]) {\n            minDeque.pop_back();\n        }\n        minDeque.push_back(i);\n\n        // Compute the range and update maxRange for the current window\n        if (i >= windowSize - 1) {\n            double currentRange = data[maxDeque.front()] - data[minDeque.front()];\n            maxRange = std::max(maxRange, currentRange);\n        }\n    }\n\n    return maxRange;\n}\n\nint main() {\n    const int dataSize = 3600000;\n    const int windowSize = 1000;\n    std::vector<double> data(dataSize);\n    \n    // Assuming data is filled with values here\n    \n    double result = findMaxRange(data, windowSize);\n    std::cout << "Maximum range within a window of size " << windowSize << " is: " << result << std::endl;\n\n    return 0;\n}