#include <windows.h>\n#include <iphlpapi.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#pragma comment(lib, "iphlpapi.lib")\n\nvoid PrintTcpConnections()\n{\n    PMIB_TCPTABLE_OWNER_PID pTcpTable;\n    DWORD dwSize = 0;\n    DWORD dwRetVal = 0;\n\n    // Allocate the initial buffer for the TCP table\n    pTcpTable = (MIB_TCPTABLE_OWNER_PID *)malloc(sizeof(MIB_TCPTABLE_OWNER_PID));\n    if (pTcpTable == NULL) {\n        printf("Error allocating memory\n");\n        return;\n    }\n\n    // Make an initial call to GetExtendedTcpTable to get the buffer size\n    if ((dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0)) == ERROR_INSUFFICIENT_BUFFER) {\n        free(pTcpTable);\n        pTcpTable = (MIB_TCPTABLE_OWNER_PID *)malloc(dwSize);\n        if (pTcpTable == NULL) {\n            printf("Error allocating memory\n");\n            return;\n        }\n    }\n\n    // Make a second call to GetExtendedTcpTable to get the actual data\n    if ((dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0)) == NO_ERROR) {\n        printf("Number of entries: %d\n", (int)pTcpTable->dwNumEntries);\n        for (DWORD i = 0; i < pTcpTable->dwNumEntries; i++) {\n            printf("\nTCP[%d] State: %ld\n", i, pTcpTable->table[i].dwState);\n            printf("Local Addr: %s\n", inet_ntoa(*(struct in_addr*)&pTcpTable->table[i].dwLocalAddr));\n            printf("Local Port: %d \n", ntohs((u_short)pTcpTable->table[i].dwLocalPort));\n            printf("Remote Addr: %s\n", inet_ntoa(*(struct in_addr*)&pTcpTable->table[i].dwRemoteAddr));\n            printf("Remote Port: %d\n", ntohs((u_short)pTcpTable->table[i].dwRemotePort));\n            printf("PID: %d\n", pTcpTable->table[i].dwOwningPid);\n        }\n    } else {\n        printf("\tGetExtendedTcpTable failed with %d\n", dwRetVal);\n    }\n\n    if (pTcpTable != NULL) {\n        free(pTcpTable);\n        pTcpTable = NULL;\n    }\n}\n\nint main()\n{\n    PrintTcpConnections();\n    return 0;\n}