#include <iostream>\n#include <cmath>\n\ntemplate <class T>\nstruct Node {\n    T value;\n    int index;\n    Node* previous;\n    Node* next;\n};\n\ntemplate <class T>\nclass List {\npublic:\n    Node<T>* head = nullptr;\n    Node<T>* last = nullptr;\n    Node<T>* current = nullptr;\n\n    Node<T>* get_closest(Node<T>* node, int& difference) {\n        if (!head || !last) {\n            difference = 0;\n            return nullptr;\n        }\n        int curr_to_i = current ? current->index - node->index : INT_MAX;\n        int last_to_i = last->index - node->index;\n        Node<T>* closest = (abs(curr_to_i) < abs(node->index)) ? current : head;\n        closest = (abs(closest->index - node->index) < abs(last_to_i)) ? closest : last;\n        difference = closest->index - node->index;\n        return closest;\n    }\n\n    bool add(T value, int index) {\n        if (index < 0) { // Invalid index\n            return false;\n        } else if (!head && index == 0) { // Adding the first node\n            head = new Node<T>{value, index, nullptr, nullptr};\n            last = head;\n            current = head;\n            return true;\n        } else if (index == last->index + 1) { // Adding at the end\n            Node<T>* new_n = new Node<T>{value, index, last, nullptr};\n            last->next = new_n;\n            last = new_n;\n            return true;\n        } else if (index > 0) {\n            Node<T>* new_n = new Node<T>{value, index, nullptr, nullptr};\n            int difference;\n            Node<T>* closest = get_closest(new_n, difference);\n            if (!closest) return false; // Invalid operation if closest node is not found\n\n            current = closest;\n\n            if (difference < 0) {\n                for (int i = 0; i < abs(difference); i++) {\n                    current = current->previous;\n                }\n            } else if (difference > 0) {\n                for (int i = 0; i < abs(difference); i++) {\n                    current = current->next;\n                }\n            }\n\n            // Insert the new node\n            new_n->previous = current->previous;\n            new_n->next = current;\n            if (current->previous) {\n                current->previous->next = new_n;\n            }\n            current->previous = new_n;\n\n            // Update head if necessary\n            if (index == 0) {\n                head = new_n;\n            }\n\n            // Update indices of subsequent nodes\n            Node<T>* temp = new_n->next;\n            while (temp) {\n                temp->index++;\n                temp = temp->next;\n            }\n            return true;\n        }\n        return false;\n    }\n};