#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\nclass Monitor {\npublic:\n    void produce(int item) {\n        std::unique_lock<std::mutex> lock(mtx);\n        while (queue.size() >= maxSize) {\n            std::cout << "Queue full, producer waiting...\n";\n            cond.wait(lock);\n        }\n        queue.push(item);\n        std::cout << "Produced: " << item << "\n";\n        cond.notify_all(); // Notify all waiting threads\n    }\n\n    void consume() {\n        std::unique_lock<std::mutex> lock(mtx);\n        while (queue.empty()) {\n            std::cout << "Queue empty, consumer waiting...\n";\n            cond.wait(lock);\n        }\n        int item = queue.front();\n        queue.pop();\n        std::cout << "Consumed: " << item << "\n";\n        cond.notify_all(); // Notify all waiting threads\n    }\n\nprivate:\n    std::mutex mtx;\n    std::condition_variable cond;\n    std::queue<int> queue;\n    const size_t maxSize = 10;\n};\n\nvoid producer(Monitor& monitor) {\n    for (int i = 0; i < 20; ++i) {\n        monitor.produce(i);\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n}\n\nvoid consumer(Monitor& monitor) {\n    for (int i = 0; i < 20; ++i) {\n        monitor.consume();\n        std::this_thread::sleep_for(std::chrono::milliseconds(150));\n    }\n}\n\nint main() {\n    Monitor monitor;\n    std::thread producerThread(producer, std::ref(monitor));\n    std::thread consumerThread(consumer, std::ref(monitor));\n\n    producerThread.join();\n    consumerThread.join();\n\n    return 0;\n}