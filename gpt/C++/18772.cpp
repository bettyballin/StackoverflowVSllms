struct InputData\n{\n    float diameter;\n    float length;\n    int vertIndex;\n    InputData *parent;\n    std::vector<InputData*> children;\n    bool deadEnd;\n\n    InputData(float dia, float lngth)\n        : diameter(dia), length(lngth), vertIndex(0), parent(nullptr), deadEnd(false)\n    {\n    }\n};\n\nvoid BuildMeshVertices(InputData* current, std::vector<int> *vertices)\n{\n    // Do work\n\n    if (current->children.size() == 1)\n    {\n        BuildMeshVertices(current->children[0], vertices);\n    }\n    else if (current->children.size() == 0 && current->deadEnd == false)\n    {\n        InputData* iDeadEnd = new InputData(1.01f, 0.5f);\n        iDeadEnd->deadEnd = true;\n        iDeadEnd->parent = current;\n        current->children.push_back(iDeadEnd);\n\n        BuildMeshVertices(iDeadEnd, vertices);\n    }\n}\n\n// Example usage\nint main()\n{\n    InputData i0 = InputData(3.0f, 3.0f);\n    InputData i1 = InputData(2.0f, 2.0f);\n    InputData i2 = InputData(1.0f, 1.0f);\n    InputData i3 = InputData(1.0f, 1.0f);\n    InputData i4 = InputData(1.0f, 1.0f);\n    InputData i5 = InputData(1.01f, 0.5f);\n\n    i0.children.push_back(&i1);\n    i1.children.push_back(&i2);\n    i2.children.push_back(&i3);\n    i3.children.push_back(&i4);\n    i4.children.push_back(&i5);\n\n    i1.parent = &i0;\n    i2.parent = &i1;\n    i3.parent = &i2;\n    i4.parent = &i3;\n    i5.parent = &i4;\n\n    std::vector<int> vertices;\n    BuildMeshVertices(&i0, &vertices);\n\n    // Make sure to properly delete allocated memory if needed\n    // This is just a basic example, you may need to implement a destructor to clean up memory in a more complex scenario\n\n    return 0;\n}