#include <memory>\n#include <Windows.h>\n\n// Forward declaration of the DLL and object interfaces\nclass IObject;\nclass IExampleDll;\n\n// Function to load the DLL\nIExampleDll* LoadDll(const wchar_t* dllPath);\n\n// Custom deleter to unload the DLL safely\nstruct DllDeleter {\n    HMODULE hModule;\n    void operator()(IExampleDll* dll) {\n        if (dll) {\n            // Call the DLL's release method (if necessary)\n            // dll->Release();\n\n            // Unload the DLL\n            FreeLibrary(hModule);\n        }\n    }\n};\n\nint main() {\n    // Load the DLL and get the handle\n    HMODULE hModule = LoadLibrary(L"bin\\example.dll");\n    if (!hModule) {\n        return -1;  // Handle error\n    }\n\n    // Load the DLL interface\n    auto createDll = reinterpret_cast<IExampleDll* (*)()>(GetProcAddress(hModule, "CreateDll"));\n    if (!createDll) {\n        FreeLibrary(hModule);\n        return -1;  // Handle error\n    }\n\n    // Create the DLL object\n    std::shared_ptr<IExampleDll> dll(createDll(), DllDeleter{hModule});\n    if (!dll) {\n        return -1;  // Handle error\n    }\n\n    // Create an object from the DLL\n    std::shared_ptr<IObject> obj(dll->CreateObject(), [dll](IObject* ptr) {\n        if (ptr) {\n            ptr->Release();  // Ensure the object is properly released\n        }\n    });\n\n    // Use the object and DLL as needed\n    // ...\n\n    return 0;  // The shared_ptr will automatically handle the cleanup\n}