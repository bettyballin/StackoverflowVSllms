#include <windows.h>\n#include <comdef.h>\n#include <iostream>\n#include <oleauto.h>\n#include "Excel.tlh" // You need to generate this using the #import directive\n\nclass ExcelEventHandler : public IDispatch {\npublic:\n    ULONG __stdcall AddRef() {\n        return ++m_refCount;\n    }\n\n    ULONG __stdcall Release() {\n        if (--m_refCount == 0) {\n            delete this;\n            return 0;\n        }\n        return m_refCount;\n    }\n\n    HRESULT __stdcall QueryInterface(REFIID riid, void **ppv) {\n        if (riid == IID_IUnknown || riid == IID_IDispatch) {\n            *ppv = static_cast<IDispatch *>(this);\n            AddRef();\n            return S_OK;\n        }\n        *ppv = nullptr;\n        return E_NOINTERFACE;\n    }\n\n    HRESULT __stdcall GetTypeInfoCount(UINT *pctinfo) {\n        return E_NOTIMPL;\n    }\n\n    HRESULT __stdcall GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo) {\n        return E_NOTIMPL;\n    }\n\n    HRESULT __stdcall GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) {\n        return E_NOTIMPL;\n    }\n\n    HRESULT __stdcall Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) {\n        if (dispIdMember == 0x0000061D) { // dispid for SheetSelectionChange\n            if (pDispParams->cArgs == 2) {\n                Excel::_WorksheetPtr pSheet = pDispParams->rgvarg[1].pdispVal;\n                Excel::RangePtr pRange = pDispParams->rgvarg[0].pdispVal;\n\n                // Your code to handle the selection change goes here\n                std::wcout << L"Selection changed in sheet: " << (LPCWSTR)pSheet->Name << std::endl;\n                std::wcout << L"New selection range: " << (LPCWSTR)pRange->Address << std::endl;\n            }\n        }\n        return S_OK;\n    }\n\nprivate:\n    ULONG m_refCount = 1;\n};\n\nint main() {\n    CoInitialize(nullptr);\n\n    Excel::_ApplicationPtr pExcel;\n    HRESULT hr = pExcel.CreateInstance(L"Excel.Application");\n\n    if (SUCCEEDED(hr)) {\n        Excel::WorkbookPtr pWorkbook = pExcel->Workbooks->Add();\n        Excel::WorksheetPtr pSheet = pWorkbook->Sheets->Item[1];\n\n        // Connect to the event\n        IConnectionPointContainerPtr pCPC = pExcel;\n        IConnectionPointPtr pCP;\n        pCPC->FindConnectionPoint(__uuidof(Excel::AppEvents), &pCP);\n\n        DWORD dwCookie;\n        ExcelEventHandler *pEventHandler = new ExcelEventHandler();\n        pCP->Advise(static_cast<IDispatch *>(pEventHandler), &dwCookie);\n\n        // Make Excel visible and interact with it\n        pExcel->Visible[0] = VARIANT_TRUE;\n\n        // Wait for user input before exiting\n        std::cout << "Press Enter to exit..." << std::endl;\n        std::cin.get();\n\n        // Unregister the event\n        pCP->Unadvise(dwCookie);\n        pEventHandler->Release();\n\n        pWorkbook->Close(VARIANT_FALSE);\n        pExcel->Quit();\n    } else {\n        std::cerr << "Failed to create Excel instance." << std::endl;\n    }\n\n    CoUninitialize();\n    return 0;\n}