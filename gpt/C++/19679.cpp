#include <stack>\n#include <vector>\n#include <iostream>\n\n// Assuming a tree node structure like this:\nstruct TreeNode {\n    char data;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(char val) : data(val), left(nullptr), right(nullptr) {}\n};\n\n// Iterative postorder DFS using a stack\nvoid iterativePostorder(TreeNode* root) {\n    if (root == nullptr) return;\n\n    std::stack<TreeNode*> nodeStack;\n    std::stack<TreeNode*> outputStack;\n    nodeStack.push(root);\n\n    while (!nodeStack.empty()) {\n        TreeNode* current = nodeStack.top();\n        nodeStack.pop();\n        outputStack.push(current);\n\n        if (current->left) {\n            nodeStack.push(current->left);\n        }\n        if (current->right) {\n            nodeStack.push(current->right);\n        }\n    }\n\n    while (!outputStack.empty()) {\n        TreeNode* current = outputStack.top();\n        outputStack.pop();\n        std::cout << current->data << " ";\n    }\n}\n\n// Helper function to add a node to the tree\nTreeNode* addNode(char data) {\n    return new TreeNode(data);\n}\n\nint main() {\n    // Creating a sample tree: \n    //         A\n    //       /   \\n    //      B     C\n    //     / \   / \\n    //    D   E F   G\n\n    TreeNode* root = addNode('A');\n    root->left = addNode('B');\n    root->right = addNode('C');\n    root->left->left = addNode('D');\n    root->left->right = addNode('E');\n    root->right->left = addNode('F');\n    root->right->right = addNode('G');\n\n    // Perform iterative postorder traversal\n    std::cout << "Iterative Postorder Traversal: ";\n    iterativePostorder(root);\n    std::cout << std::endl;\n\n    return 0;\n}