#include <windows.h>\n#include <memory>\n\ntemplate <class _Ty>\nclass LockedVirtualMemAllocator : public std::allocator<_Ty> {\npublic:\n    template <class _Other>\n    LockedVirtualMemAllocator<_Ty>& operator=(const LockedVirtualMemAllocator<_Other>&) {\n        return (*this);\n    }\n\n    template <class Other>\n    struct rebind {\n        typedef LockedVirtualMemAllocator<Other> other;\n    };\n\n    _Ty* allocate(std::size_t n) {\n        SIZE_T allocLen = n * sizeof(_Ty);\n        DWORD allocType = MEM_COMMIT | MEM_RESERVE;\n        DWORD allocProtect = PAGE_READWRITE;\n        LPVOID pMem = ::VirtualAlloc(NULL, allocLen, allocType, allocProtect);\n        if (pMem != NULL) {\n            if (!::VirtualLock(pMem, allocLen)) {\n                ::VirtualFree(pMem, 0, MEM_RELEASE);\n                throw std::bad_alloc();\n            }\n            // Change protection to read-only after allocation\n            DWORD oldProtect;\n            ::VirtualProtect(pMem, allocLen, PAGE_READONLY, &oldProtect);\n        }\n        return reinterpret_cast<_Ty*>(pMem);\n    }\n\n    void deallocate(_Ty* pPtr, std::size_t n) {\n        if (pPtr != NULL) {\n            SIZE_T allocLen = n * sizeof(_Ty);\n            // Change protection to read/write before zeroing memory\n            DWORD oldProtect;\n            ::VirtualProtect(pPtr, allocLen, PAGE_READWRITE, &oldProtect);\n            ::SecureZeroMemory(pPtr, allocLen);\n            ::VirtualUnlock(pPtr, allocLen);\n            ::VirtualFree(pPtr, 0, MEM_RELEASE);\n        }\n    }\n};\n\n// Usage example\ntypedef std::basic_string<char, std::char_traits<char>, LockedVirtualMemAllocator<char>> secure_string;\n\nint main() {\n    secure_string secret("Sensitive Data");\n    // Use secret string\n    return 0;\n}