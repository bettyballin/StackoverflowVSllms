#include <iostream>\n#include <afxwin.h>\n#include <afxmt.h>\n#include <windows.h>\n\nbool bStop = false;\nlong k1 = 0;\nlong k2 = 0;\n\nUINT run1(LPVOID param)\n{\n    while (!bStop)\n    {\n        for (int i = 0; i < 10; ++i)\n        {\n            ++k1;\n        }\n    }\n\n    return 0;\n}\n\nUINT run2(LPVOID param)\n{\n    while (!bStop)\n    {\n        for (int i = 0; i < 10; ++i)\n        {\n            ++k2;\n        }\n    }\n\n    return 0;\n}\n\nvoid PrintThreadTimes(CWinThread* pThread, const std::string& threadName)\n{\n    FILETIME creationTime, exitTime, kernelTime, userTime;\n    if (GetThreadTimes(pThread->m_hThread, &creationTime, &exitTime, &kernelTime, &userTime))\n    {\n        ULARGE_INTEGER kTime;\n        kTime.LowPart = kernelTime.dwLowDateTime;\n        kTime.HighPart = kernelTime.dwHighDateTime;\n\n        ULARGE_INTEGER uTime;\n        uTime.LowPart = userTime.dwLowDateTime;\n        uTime.HighPart = userTime.dwHighDateTime;\n\n        ULONGLONG totalTime = kTime.QuadPart + uTime.QuadPart;\n        double totalTimeInSec = totalTime / 10000000.0;\n\n        std::cout << threadName << " CPU Time: " << totalTimeInSec << " sec" << std::endl;\n    }\n    else\n    {\n        std::cerr << "Failed to get thread times for " << threadName << std::endl;\n    }\n}\n\nint main(int argc, char* argv[])\n{\n    CWinThread* pThread1 = AfxBeginThread(run1, NULL, THREAD_PRIORITY_NORMAL);\n    CWinThread* pThread2 = AfxBeginThread(run2, NULL, THREAD_PRIORITY_BELOW_NORMAL);\n\n    Sleep(3000);\n\n    bStop = true;\n\n    WaitForSingleObject(pThread1->m_hThread, INFINITE);\n    WaitForSingleObject(pThread2->m_hThread, INFINITE);\n\n    std::cout << "K1 = " << k1 << std::endl;\n    std::cout << "K2 = " << k2 << std::endl;\n\n    PrintThreadTimes(pThread1, "Thread1");\n    PrintThreadTimes(pThread2, "Thread2");\n\n    std::cout << "Exit" << std::endl;\n\n    return 0;\n}