#include <vector>\n#include <algorithm>\n\nclass ConnectionPointImpl : public IConnectionPoint\n{\npublic:\n    ConnectionPointImpl() : m_refCount(1) {}\n\n    HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnkSink, DWORD *pdwCookie)\n    {\n        if (!pUnkSink || !pdwCookie)\n            return E_POINTER;\n\n        // Check if the sink already exists\n        if (std::find(m_sinks.begin(), m_sinks.end(), pUnkSink) != m_sinks.end())\n            return CONNECT_E_ADVISELIMIT;\n\n        // Add the sink to the list\n        m_sinks.push_back(pUnkSink);\n        *pdwCookie = static_cast<DWORD>(m_sinks.size());\n        return S_OK;\n    }\n\n    HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie)\n    {\n        if (dwCookie == 0 || dwCookie > m_sinks.size())\n            return CONNECT_E_NOCONNECTION;\n\n        // Remove the sink from the list\n        m_sinks.erase(m_sinks.begin() + (dwCookie - 1));\n        return S_OK;\n    }\n\n    HRESULT STDMETHODCALLTYPE EnumConnections(IEnumConnections **ppEnum)\n    {\n        return E_NOTIMPL; // Not implemented for simplicity\n    }\n\n    ULONG STDMETHODCALLTYPE AddRef()\n    {\n        return InterlockedIncrement(&m_refCount);\n    }\n\n    ULONG STDMETHODCALLTYPE Release()\n    {\n        ULONG ul = InterlockedDecrement(&m_refCount);\n        if (ul == 0)\n        {\n            delete this;\n        }\n        return ul;\n    }\n\n    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject)\n    {\n        if (riid == IID_IUnknown || riid == IID_IConnectionPoint)\n        {\n            *ppvObject = static_cast<IConnectionPoint*>(this);\n            AddRef();\n            return S_OK;\n        }\n        return E_NOINTERFACE;\n    }\n\nprivate:\n    ~ConnectionPointImpl() {}\n\n    std::vector<IUnknown*> m_sinks;\n    LONG m_refCount;\n};\n\n// Usage example\nHRESULT CheckMultipleConnectionsSupport(IConnectionPointContainer* pCPC)\n{\n    IConnectionPoint* pCP = nullptr;\n    HRESULT hr = pCPC->FindConnectionPoint(IID_IS8SimulationEvents, &pCP);\n    if (FAILED(hr))\n        return hr;\n\n    Sink* pSink1 = new Sink();\n    DWORD dwCookie1;\n    hr = pCP->Advise(pSink1, &dwCookie1);\n    if (FAILED(hr))\n    {\n        pCP->Release();\n        return hr;\n    }\n\n    Sink* pSink2 = new Sink();\n    DWORD dwCookie2;\n    hr = pCP->Advise(pSink2, &dwCookie2);\n    if (hr == CONNECT_E_ADVISELIMIT)\n    {\n        std::cout << "Connection point does not support multiple connections." << std::endl;\n    }\n    else if (SUCCEEDED(hr))\n    {\n        std::cout << "Connection point supports multiple connections." << std::endl;\n    }\n\n    pCP->Unadvise(dwCookie1);\n    pCP->Unadvise(dwCookie2);\n    pCP->Release();\n    return S_OK;\n}