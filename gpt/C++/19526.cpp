#include <windows.h>\n#include <sql.h>\n#include <sqlext.h>\n\nSQLHENV hEnv;\nSQLHDBC hDbc;\nSQLHSTMT hStmt;\nSQLRETURN retcode;\n\nvoid checkError(SQLRETURN retcode, SQLSMALLINT handleType, SQLHANDLE handle) {\n    if (retcode != SQL_SUCCESS && retcode != SQL_SUCCESS_WITH_INFO) {\n        SQLCHAR sqlState[5];\n        SQLCHAR message[256];\n        SQLINTEGER nativeError;\n        SQLSMALLINT messageLength;\n        \n        SQLGetDiagRec(handleType, handle, 1, sqlState, &nativeError, message, sizeof(message), &messageLength);\n        std::cerr << "Error: " << message << std::endl;\n    }\n}\n\nint main() {\n    // Allocate environment handle\n    SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &hEnv);\n    SQLSetEnvAttr(hEnv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);\n\n    // Allocate connection handle\n    SQLAllocHandle(SQL_HANDLE_DBC, hEnv, &hDbc);\n\n    // Connect to the data source\n    SQLCHAR connStr[] = "DSN=your_dsn;UID=your_username;PWD=your_password;";\n    SQLDriverConnect(hDbc, NULL, connStr, SQL_NTS, NULL, 0, NULL, SQL_DRIVER_COMPLETE);\n\n    // Allocate statement handle\n    SQLAllocHandle(SQL_HANDLE_STMT, hDbc, &hStmt);\n\n    // Enable asynchronous execution\n    SQLSetStmtAttr(hStmt, SQL_ATTR_ASYNC_ENABLE, (SQLPOINTER)SQL_ASYNC_ENABLE_ON, 0);\n\n    // Execute a statement asynchronously\n    SQLExecDirect(hStmt, (SQLCHAR*)"SELECT * FROM your_table", SQL_NTS);\n\n    // Check the status of the asynchronous operation\n    while ((retcode = SQLExecDirect(hStmt, NULL, 0)) == SQL_STILL_EXECUTING) {\n        Sleep(100); // Sleep for a bit before checking again\n    }\n\n    checkError(retcode, SQL_HANDLE_STMT, hStmt);\n\n    // Clean up\n    SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    SQLDisconnect(hDbc);\n    SQLFreeHandle(SQL_HANDLE_DBC, hDbc);\n    SQLFreeHandle(SQL_HANDLE_ENV, hEnv);\n\n    return 0;\n}