#include <iostream>\n#include <cstring>\n#include <sys/socket.h>\n#include <unistd.h>\n\nunsigned int TCP_BlockSize = 4096;\nunsigned int len;\nint result;\n\n// assume sock is a valid connected socket\n// and len is the length of data to be received\n\nunsigned char *buf = new unsigned char[len];\nunsigned int currentLen = 0;\nresult = 0;\n\nwhile (currentLen < len) {\n    unsigned int bytesToReceive = (len - currentLen < TCP_BlockSize) ? (len - currentLen) : TCP_BlockSize;\n    result = recv(sock, buf + currentLen, bytesToReceive, 0);\n\n    if (result > 0) {\n        currentLen += result;\n    } else if (result == 0) {\n        // Connection closed by the server\n        break;\n    } else {\n        // Handle errors\n        if (errno == EAGAIN || errno == EWOULDBLOCK) {\n            // Non-blocking mode: no data available right now, try again later\n            continue;\n        } else {\n            std::cerr << "Recv failed with error: " << strerror(errno) << std::endl;\n            break;\n        }\n    }\n}\n\nif (currentLen == len) {\n    // Successfully received all data\n    std::cout << "Received all data successfully." << std::endl;\n} else {\n    // Handle incomplete data reception\n    std::cerr << "Failed to receive all data. Current length: " << currentLen << std::endl;\n}\n\ndelete[] buf;\nclose(sock);