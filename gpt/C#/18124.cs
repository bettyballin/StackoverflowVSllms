public static class MurmurHash3\n{\n    public static uint ComputeHash(string data)\n    {\n        const uint seed = 0xc58f1a7b;\n        const uint c1 = 0xcc9e2d51;\n        const uint c2 = 0x1b873593;\n        const int r1 = 15;\n        const int r2 = 13;\n        const uint m = 5;\n        const uint n = 0xe6546b64;\n\n        int length = data.Length;\n        uint hash = seed;\n        int currentIndex = 0;\n\n        while (length >= 4)\n        {\n            uint k = (uint)(data[currentIndex++] | data[currentIndex++] << 8 | data[currentIndex++] << 16 | data[currentIndex++] << 24);\n            k *= c1;\n            k = RotateLeft(k, r1);\n            k *= c2;\n\n            hash ^= k;\n            hash = RotateLeft(hash, r2);\n            hash = hash * m + n;\n\n            length -= 4;\n        }\n\n        uint remaining = 0;\n        switch (length)\n        {\n            case 3: remaining ^= (uint)data[currentIndex + 2] << 16; goto case 2;\n            case 2: remaining ^= (uint)data[currentIndex + 1] << 8; goto case 1;\n            case 1: remaining ^= (uint)data[currentIndex]; break;\n        }\n\n        remaining *= c1;\n        remaining = RotateLeft(remaining, r1);\n        remaining *= c2;\n        hash ^= remaining;\n\n        hash ^= (uint)data.Length;\n        hash = FMix(hash);\n\n        return hash;\n    }\n\n    private static uint RotateLeft(uint x, int r)\n    {\n        return (x << r) | (x >> (32 - r));\n    }\n\n    private static uint FMix(uint h)\n    {\n        h ^= h >> 16;\n        h *= 0x85ebca6b;\n        h ^= h >> 13;\n        h *= 0xc2b2ae35;\n        h ^= h >> 16;\n        return h;\n    }\n}