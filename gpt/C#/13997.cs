using System;\nusing System.Net.Security;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Net.Sockets;\n\npublic class SslServer\n{\n    public static void Main()\n    {\n        X509Certificate2 serverCertificate = new X509Certificate2("path_to_your_server_cert.pfx", "password");\n\n        TcpListener listener = new TcpListener(System.Net.IPAddress.Any, 443);\n        listener.Start();\n        while (true)\n        {\n            TcpClient client = listener.AcceptTcpClient();\n            NetworkStream stream = client.GetStream();\n            SslStream sslStream = new SslStream(stream, false, new RemoteCertificateValidationCallback(ValidateClientCertificate), null);\n\n            try\n            {\n                sslStream.AuthenticateAsServer(serverCertificate, true, SslProtocols.Tls12, false);\n                // Perform your operations with sslStream\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e.Message);\n            }\n        }\n    }\n\n    public static bool ValidateClientCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)\n    {\n        // Implement your custom validation logic here\n        if (sslPolicyErrors == SslPolicyErrors.None)\n        {\n            // Optionally, you can specify accepted client certificates\n            // For example, compare the thumbprint of the client certificate with a predefined list\n            string[] acceptedClientThumbprints = { "thumbprint1", "thumbprint2" };\n            string clientCertThumbprint = certificate.GetCertHashString();\n\n            foreach (var thumbprint in acceptedClientThumbprints)\n            {\n                if (clientCertThumbprint.Equals(thumbprint, StringComparison.OrdinalIgnoreCase))\n                {\n                    return true; // Client certificate is accepted\n                }\n            }\n        }\n\n        return false; // Reject the client certificate\n    }\n}