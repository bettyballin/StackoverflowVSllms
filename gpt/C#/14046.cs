using System;\nusing System.Net;\nusing System.Runtime.InteropServices;\n\npublic class CredentialManager\n{\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]\n    private static extern bool CredRead(string target, int type, int reservedFlag, out IntPtr credentialPtr);\n\n    [DllImport("advapi32.dll", SetLastError = true)]\n    private static extern void CredFree(IntPtr buffer);\n    \n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    private struct CREDENTIAL\n    {\n        public int Flags;\n        public int Type;\n        public string TargetName;\n        public string Comment;\n        public System.Runtime.InteropServices.ComTypes.FILETIME LastWritten;\n        public int CredentialBlobSize;\n        public IntPtr CredentialBlob;\n        public int Persist;\n        public int AttributeCount;\n        public IntPtr Attributes;\n        public string TargetAlias;\n        public string UserName;\n    }\n\n    public static NetworkCredential GetCredential(string target)\n    {\n        IntPtr credentialPtr;\n        if (CredRead(target, 1, 0, out credentialPtr))\n        {\n            try\n            {\n                var credential = (CREDENTIAL)Marshal.PtrToStructure(credentialPtr, typeof(CREDENTIAL));\n                string password = Marshal.PtrToStringUni(credential.CredentialBlob, credential.CredentialBlobSize / 2);\n\n                return new NetworkCredential(credential.UserName, password);\n            }\n            finally\n            {\n                CredFree(credentialPtr);\n            }\n        }\n        throw new InvalidOperationException("Failed to read credential.");\n    }\n}