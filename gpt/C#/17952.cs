using System;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\npublic class Program\n{\n    private const int UNIVERSAL_NAME_INFO_LEVEL = 1;\n    private const int ERROR_MORE_DATA = 234;\n    private const int NO_ERROR = 0;\n\n    [DllImport("mpr.dll", CharSet = CharSet.Unicode)]\n    private static extern int WNetGetUniversalName(\n        string lpLocalPath,\n        int dwInfoLevel,\n        IntPtr lpBuffer,\n        ref int lpBufferSize);\n\n    public static string GetUniversalName(string localPath)\n    {\n        int bufferSize = 660; // Initial buffer size.\n        IntPtr buffer = Marshal.AllocHGlobal(bufferSize);\n\n        try\n        {\n            int result = WNetGetUniversalName(localPath, UNIVERSAL_NAME_INFO_LEVEL, buffer, ref bufferSize);\n\n            if (result == ERROR_MORE_DATA)\n            {\n                buffer = Marshal.ReAllocHGlobal(buffer, (IntPtr)bufferSize);\n                result = WNetGetUniversalName(localPath, UNIVERSAL_NAME_INFO_LEVEL, buffer, ref bufferSize);\n            }\n\n            if (result == NO_ERROR)\n            {\n                var universalNameInfo = Marshal.PtrToStructure<UniversalNameInfo>(buffer);\n                return universalNameInfo.lpUniversalName;\n            }\n            else\n            {\n                throw new System.ComponentModel.Win32Exception(result);\n            }\n        }\n        finally\n        {\n            Marshal.FreeHGlobal(buffer);\n        }\n    }\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n    private struct UniversalNameInfo\n    {\n        public string lpUniversalName;\n    }\n\n    public static void Main()\n    {\n        string localPath = @"W:\Path\Share";\n        try\n        {\n            string uncPath = GetUniversalName(localPath);\n            Console.WriteLine($"UNC Path: {uncPath}");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Error: {ex.Message}");\n        }\n    }\n}