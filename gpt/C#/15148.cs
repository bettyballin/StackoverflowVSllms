using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nclass Program\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool GenerateConsoleCtrlEvent(uint dwCtrlEvent, uint dwProcessGroupId);\n\n    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]\n    private static extern bool AttachConsole(uint dwProcessId);\n\n    [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]\n    private static extern bool FreeConsole();\n\n    private const uint CTRL_C_EVENT = 0;\n\n    static void Main(string[] args)\n    {\n        ProcessStartInfo info = new ProcessStartInfo("your_exe_path.exe", "your_args");\n        info.RedirectStandardError = true;\n        info.RedirectStandardInput = true;\n        info.RedirectStandardOutput = true;\n        info.UseShellExecute = false;\n\n        Process p = Process.Start(info);\n\n        p.StandardInput.AutoFlush = true;\n        p.StandardInput.WriteLine("your_script_code");\n\n        // Attach to the console of the process\n        if (AttachConsole((uint)p.Id))\n        {\n            // Generate CTRL+C event for the process group\n            GenerateConsoleCtrlEvent(CTRL_C_EVENT, 0);\n\n            // Allow some time for the process to handle the signal\n            Thread.Sleep(1000);\n\n            // Detach from the console\n            FreeConsole();\n        }\n\n        string error = p.StandardError.ReadToEnd();\n        if (!String.IsNullOrEmpty(error))\n        {\n            throw new Exception(error);\n        }\n        string output = p.StandardOutput.ReadToEnd();\n\n        Console.WriteLine(output);\n    }\n}