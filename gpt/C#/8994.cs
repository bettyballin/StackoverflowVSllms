public double JaroWinklerDistance(string s1, string s2)\n   {\n       int s1Len = s1.Length;\n       int s2Len = s2.Length;\n       if (s1Len == 0) return s2Len == 0 ? 1.0 : 0.0;\n       int matchDistance = Math.Max(s1Len, s2Len) / 2 - 1;\n       bool[] s1Matches = new bool[s1Len];\n       bool[] s2Matches = new bool[s2Len];\n       int matches = 0;\n       int transpositions = 0;\n       for (int i = 0; i < s1Len; i++)\n       {\n           int start = Math.Max(0, i - matchDistance);\n           int end = Math.Min(i + matchDistance + 1, s2Len);\n           for (int j = start; j < end; j++)\n           {\n               if (s2Matches[j]) continue;\n               if (s1[i] != s2[j]) continue;\n               s1Matches[i] = true;\n               s2Matches[j] = true;\n               matches++;\n               break;\n           }\n       }\n       if (matches == 0) return 0.0;\n       int k = 0;\n       for (int i = 0; i < s1Len; i++)\n       {\n           if (!s1Matches[i]) continue;\n           while (!s2Matches[k]) k++;\n           if (s1[i] != s2[k]) transpositions++;\n           k++;\n       }\n       transpositions /= 2;\n       double matchScore = ((double)matches / s1Len + (double)matches / s2Len + (double)(matches - transpositions) / matches) / 3.0;\n       const double scalingFactor = 0.1;\n       int prefixLength = 0;\n       for (int i = 0; i < Math.Min(4, Math.Min(s1.Length, s2.Length)); i++)\n       {\n           if (s1[i] == s2[i]) prefixLength++;\n           else break;\n       }\n       return matchScore + prefixLength * scalingFactor * (1 - matchScore);\n   }