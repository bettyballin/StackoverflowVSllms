using System;\nusing System.Web;\n\npublic class PermissionCheckModule : IHttpModule\n{\n    public void Init(HttpApplication context)\n    {\n        context.BeginRequest += new EventHandler(OnBeginRequest);\n    }\n\n    private void OnBeginRequest(object sender, EventArgs e)\n    {\n        HttpContext context = HttpContext.Current;\n\n        // Perform your permission check here\n        bool hasPermission = CheckPermissions(context.Request);\n\n        if (!hasPermission)\n        {\n            context.Response.StatusCode = 403; // Forbidden\n            context.Response.End();\n        }\n        else\n        {\n            // Remap the request to the default StaticFileHandler\n            context.RemapHandler(new StaticFileHandler());\n        }\n    }\n\n    private bool CheckPermissions(HttpRequest request)\n    {\n        // Implement your permission check logic here\n        return true; // This is just a placeholder\n    }\n\n    public void Dispose() { }\n}\n\npublic class StaticFileHandler : IHttpHandler\n{\n    public void ProcessRequest(HttpContext context)\n    {\n        // Delegate the request back to IIS for efficient static file handling\n        // This is a simplified way, typically you would let IIS handle it directly\n        string filePath = context.Request.PhysicalPath;\n        context.Response.TransmitFile(filePath);\n        context.Response.End();\n    }\n\n    public bool IsReusable\n    {\n        get { return false; }\n    }\n}