using System;\nusing System.Collections.Generic;\n\npublic class Graph\n{\n    private Dictionary<int, List<Tuple<int, int>>> adjList;\n\n    public Graph()\n    {\n        adjList = new Dictionary<int, List<Tuple<int, int>>>();\n    }\n\n    public void AddEdge(int from, int to, int priority)\n    {\n        if (!adjList.ContainsKey(from))\n        {\n            adjList[from] = new List<Tuple<int, int>>();\n        }\n        adjList[from].Add(new Tuple<int, int>(to, priority));\n    }\n\n    public List<Tuple<int, int>> GetShortestPath(int start, int end)\n    {\n        var priorityQueue = new SortedSet<Tuple<int, int, int>>();\n        var distances = new Dictionary<int, int>();\n        var previousNodes = new Dictionary<int, int>();\n        \n        foreach (var node in adjList.Keys)\n        {\n            distances[node] = int.MaxValue;\n        }\n        distances[start] = 0;\n        priorityQueue.Add(new Tuple<int, int, int>(0, start, -1));\n\n        while (priorityQueue.Count > 0)\n        {\n            var currentNode = priorityQueue.Min;\n            priorityQueue.Remove(currentNode);\n\n            int currentDistance = currentNode.Item1;\n            int currentVertex = currentNode.Item2;\n            int previousVertex = currentNode.Item3;\n\n            if (currentVertex == end)\n            {\n                var path = new List<Tuple<int, int>>();\n                while (previousVertex != -1)\n                {\n                    path.Add(new Tuple<int, int>(previousVertex, currentVertex));\n                    currentVertex = previousVertex;\n                    previousVertex = previousNodes.ContainsKey(currentVertex) ? previousNodes[currentVertex] : -1;\n                }\n                path.Reverse();\n                return path;\n            }\n\n            if (currentDistance > distances[currentVertex])\n            {\n                continue;\n            }\n\n            foreach (var edge in adjList[currentVertex])\n            {\n                int neighbor = edge.Item1;\n                int weight = edge.Item2;\n                int distance = currentDistance + weight;\n\n                if (distance < distances[neighbor])\n                {\n                    distances[neighbor] = distance;\n                    previousNodes[neighbor] = currentVertex;\n                    priorityQueue.Add(new Tuple<int, int, int>(distance, neighbor, currentVertex));\n                }\n            }\n        }\n        return new List<Tuple<int, int>>();\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Graph graph = new Graph();\n        \n        graph.AddEdge(1, 2, 1);\n        graph.AddEdge(3, 2, 1);\n        graph.AddEdge(5, 2, 1);\n        graph.AddEdge(2, 8, 1);\n        graph.AddEdge(8, 10, 1);\n        graph.AddEdge(9, 10, 1);\n\n        var path = graph.GetShortestPath(1, 10);\n        \n        foreach (var edge in path)\n        {\n            Console.WriteLine($"{edge.Item1},{edge.Item2}");\n        }\n    }\n}