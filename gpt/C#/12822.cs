using System;\nusing System.Diagnostics.Tracing;\nusing System.Threading;\n\nclass Program\n{\n    static void Main()\n    {\n        var listener = new AllocationEventListener();\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n\n        // Force some allocations\n        for (int i = 0; i < 1000; i++)\n        {\n            var obj = new object();\n        }\n\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n\n        Thread.Sleep(1000); // Give the listener some time to process events\n    }\n\n    private sealed class AllocationEventListener : EventListener\n    {\n        protected override void OnEventSourceCreated(EventSource eventSource)\n        {\n            if (eventSource.Name == "System.Runtime")\n            {\n                EnableEvents(eventSource, EventLevel.Informational, EventKeywords.All, new Dictionary<string, string>\n                {\n                    ["EventCounterIntervalSec"] = "1"\n                });\n            }\n        }\n\n        protected override void OnEventWritten(EventWrittenEventArgs eventData)\n        {\n            if (eventData.EventName.Equals("GCHeapStats"))\n            {\n                for (int i = 0; i < eventData.Payload.Count; i++)\n                {\n                    Console.WriteLine($"{eventData.PayloadNames[i]}: {eventData.Payload[i]}");\n                }\n            }\n        }\n    }\n}