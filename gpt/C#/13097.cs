using System;\nusing System.Security.Principal;\nusing System.Runtime.InteropServices;\nusing System.Security.Permissions;\n\npublic class ImpersonationHelper\n{\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Auto)]\n    public extern static int LogonUser(\n        String lpszUsername, \n        String lpszDomain, \n        String lpszPassword, \n        int dwLogonType, \n        int dwLogonProvider, \n        ref IntPtr phToken);\n\n    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]\n    public extern static bool CloseHandle(IntPtr handle);\n\n    private const int LOGON32_LOGON_INTERACTIVE = 2;\n    private const int LOGON32_PROVIDER_DEFAULT = 0;\n\n    public static void RunImpersonated(string domain, string username, string password, Action action)\n    {\n        IntPtr tokenHandle = IntPtr.Zero;\n\n        // Attempt to log on the user\n        bool returnValue = LogonUser(username, domain, password, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, ref tokenHandle);\n\n        if (!returnValue)\n        {\n            int ret = Marshal.GetLastWin32Error();\n            throw new System.ComponentModel.Win32Exception(ret);\n        }\n\n        WindowsIdentity newId = new WindowsIdentity(tokenHandle);\n        WindowsImpersonationContext impersonatedUser = newId.Impersonate();\n\n        try\n        {\n            action();\n        }\n        finally\n        {\n            impersonatedUser.Undo();\n            CloseHandle(tokenHandle);\n        }\n    }\n}