using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Security.Cryptography;\n\npublic class ShamirSecretSharing\n{\n    private static readonly RandomNumberGenerator rng = RandomNumberGenerator.Create();\n\n    public static List<Tuple<int, BigInteger>> SplitSecret(BigInteger secret, int n, int k)\n    {\n        if (k > n)\n            throw new ArgumentException("k cannot be greater than n");\n\n        BigInteger prime = GenerateLargePrime(secret.GetBitLength() + 1);\n        List<BigInteger> coefficients = new List<BigInteger> { secret };\n\n        for (int i = 1; i < k; i++)\n        {\n            coefficients.Add(GetRandomBigInteger(prime));\n        }\n\n        List<Tuple<int, BigInteger>> shares = new List<Tuple<int, BigInteger>>();\n        for (int i = 1; i <= n; i++)\n        {\n            BigInteger share = EvaluatePolynomial(coefficients, i, prime);\n            shares.Add(new Tuple<int, BigInteger>(i, share));\n        }\n\n        return shares;\n    }\n\n    public static BigInteger CombineShares(List<Tuple<int, BigInteger>> shares)\n    {\n        BigInteger prime = GenerateLargePrime(shares[0].Item2.GetBitLength() + 1);\n        BigInteger secret = 0;\n\n        foreach (var share in shares)\n        {\n            BigInteger numerator = 1;\n            BigInteger denominator = 1;\n\n            foreach (var otherShare in shares)\n            {\n                if (share.Item1 != otherShare.Item1)\n                {\n                    numerator = (numerator * (-otherShare.Item1)) % prime;\n                    denominator = (denominator * (share.Item1 - otherShare.Item1)) % prime;\n                }\n            }\n\n            BigInteger value = share.Item2;\n            secret = (secret + value * numerator * ModInverse(denominator, prime)) % prime;\n        }\n\n        return (secret + prime) % prime;\n    }\n\n    private static BigInteger EvaluatePolynomial(List<BigInteger> coefficients, int x, BigInteger prime)\n    {\n        BigInteger result = 0;\n        for (int i = coefficients.Count - 1; i >= 0; i--)\n        {\n            result = (result * x + coefficients[i]) % prime;\n        }\n        return result;\n    }\n\n    private static BigInteger GetRandomBigInteger(BigInteger max)\n    {\n        byte[] bytes = max.ToByteArray();\n        BigInteger result;\n        do\n        {\n            rng.GetBytes(bytes);\n            result = new BigInteger(bytes);\n        } while (result < 0 || result >= max);\n        return result;\n    }\n\n    private static BigInteger ModInverse(BigInteger a, BigInteger m)\n    {\n        BigInteger m0 = m, t, q;\n        BigInteger x0 = 0, x1 = 1;\n\n        if (m == 1)\n            return 0;\n\n        while (a > 1)\n        {\n            q = a / m;\n            t = m;\n            m = a % m; a = t;\n            t = x0;\n            x0 = x1 - q * x0;\n            x1 = t;\n        }\n\n        if (x1 < 0)\n            x1 += m0;\n\n        return x1;\n    }\n\n    private static BigInteger GenerateLargePrime(int bits)\n    {\n        return BigInteger.ProbablePrime(bits, rng);\n    }\n}