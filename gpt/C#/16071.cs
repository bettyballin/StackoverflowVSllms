using System;\nusing System.Linq;\nusing System.Net;\n\npublic class IPAddressManipulation\n{\n    public static IPAddress GetBroadcastAddress(IPAddress ipAddress, IPAddress subnetMask, bool useZeroBroadcast)\n    {\n        if (ipAddress.AddressFamily != System.Net.Sockets.AddressFamily.InterNetwork || \n            subnetMask.AddressFamily != System.Net.Sockets.AddressFamily.InterNetwork)\n            throw new ArgumentException("Only IPv4 addresses are supported.");\n\n        byte[] ipAddressBytes = ipAddress.GetAddressBytes();\n        byte[] subnetMaskBytes = subnetMask.GetAddressBytes();\n\n        if (ipAddressBytes.Length != subnetMaskBytes.Length) \n            throw new ArgumentException("IP address and subnet mask lengths do not match.");\n\n        byte[] broadcastAddressBytes = new byte[ipAddressBytes.Length];\n        \n        for (int i = 0; i < ipAddressBytes.Length; i++)\n        {\n            if (useZeroBroadcast)\n            {\n                broadcastAddressBytes[i] = (byte)(ipAddressBytes[i] & subnetMaskBytes[i]);\n            }\n            else\n            {\n                broadcastAddressBytes[i] = (byte)(ipAddressBytes[i] | ~subnetMaskBytes[i]);\n            }\n        }\n\n        return new IPAddress(broadcastAddressBytes);\n    }\n\n    public static IPAddress GetSubnetMask(int prefixLength)\n    {\n        if (prefixLength < 0 || prefixLength > 32)\n            throw new ArgumentOutOfRangeException(nameof(prefixLength), "Prefix length must be between 0 and 32.");\n\n        uint mask = 0xffffffff << (32 - prefixLength);\n        byte[] maskBytes = BitConverter.GetBytes(mask).Reverse().ToArray();\n        return new IPAddress(maskBytes);\n    }\n\n    public static void Main()\n    {\n        string ipAddressStr = "10.171.24.69";\n        string netmaskStr = "255.255.255.128"; // or "25" for CIDR notation\n\n        IPAddress ipAddress = IPAddress.Parse(ipAddressStr);\n        IPAddress subnetMask = null;\n\n        if (netmaskStr.Contains("."))\n        {\n            subnetMask = IPAddress.Parse(netmaskStr);\n        }\n        else\n        {\n            int prefixLength = int.Parse(netmaskStr);\n            subnetMask = GetSubnetMask(prefixLength);\n        }\n\n        bool useZeroBroadcast = false; // This should be set according to IPUseZeroBroadcast property\n        IPAddress broadcastAddress = GetBroadcastAddress(ipAddress, subnetMask, useZeroBroadcast);\n\n        Console.WriteLine("Broadcast Address: " + broadcastAddress);\n    }\n}