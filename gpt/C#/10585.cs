using System;\nusing System.Runtime.InteropServices;\nusing System.Security.Principal;\nusing System.ComponentModel;\n\npublic class Impersonation\n{\n    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]\n    public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, out IntPtr phToken);\n\n    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]\n    public extern static bool CloseHandle(IntPtr handle);\n\n    public static void ImpersonateUser(string username, string domain, string password)\n    {\n        IntPtr userToken = IntPtr.Zero;\n        const int LOGON32_LOGON_INTERACTIVE = 2;\n        const int LOGON32_PROVIDER_DEFAULT = 0;\n\n        try\n        {\n            bool isSuccess = LogonUser(username, domain, password, LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, out userToken);\n            if (!isSuccess)\n            {\n                int errorCode = Marshal.GetLastWin32Error();\n                throw new Win32Exception(errorCode);\n            }\n\n            using (WindowsIdentity userIdentity = new WindowsIdentity(userToken))\n            {\n                using (WindowsImpersonationContext userContext = userIdentity.Impersonate())\n                {\n                    // Code to execute under the context of the impersonated user\n                    Console.WriteLine("Impersonation successful.");\n                }\n            }\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($"Impersonation failed: {ex.Message}");\n        }\n        finally\n        {\n            if (userToken != IntPtr.Zero)\n            {\n                CloseHandle(userToken);\n            }\n        }\n    }\n}