using System;\nusing System.Diagnostics;\nusing System.Management;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);\n\n    static void Main(string[] args)\n    {\n        // Replace with the process ID of your main child process\n        int processId = 1234;\n\n        // Kill the process tree\n        KillProcessAndChildren(processId);\n    }\n\n    static void KillProcessAndChildren(int pid)\n    {\n        ManagementObjectSearcher searcher = new ManagementObjectSearcher($"Select * From Win32_Process Where ParentProcessID={pid}");\n        ManagementObjectCollection moc = searcher.Get();\n\n        foreach (ManagementObject mo in moc)\n        {\n            KillProcessAndChildren(Convert.ToInt32(mo["ProcessID"]));\n        }\n\n        try\n        {\n            Process proc = Process.GetProcessById(pid);\n            TerminateProcess(proc.Handle, 0);\n        }\n        catch (ArgumentException)\n        {\n            // Process already exited\n        }\n    }\n}