using System;\nusing System.Management;\nusing System.Threading;\n\npublic class RemoteProcessWatcher\n{\n    public static void Main(string[] args)\n    {\n        string host = "remote_machine_name";\n        string domainUserName = "your_domain\\username";\n        string password = "your_password";\n        string commandLine = "your_command";\n\n        ConnectionOptions connOptions = new ConnectionOptions\n        {\n            Impersonation = ImpersonationLevel.Impersonate,\n            EnablePrivileges = true,\n            Username = domainUserName,\n            Password = password\n        };\n\n        ManagementScope manScope = new ManagementScope($@"\\{host}\ROOT\CIMV2", connOptions);\n        manScope.Connect();\n\n        ManagementPath managementPath = new ManagementPath("Win32_Process");\n        ManagementClass processClass = new ManagementClass(manScope, managementPath, new ObjectGetOptions());\n\n        ManagementBaseObject inParams = processClass.GetMethodParameters("Create");\n        inParams["CommandLine"] = commandLine;\n\n        ManagementBaseObject outParams = processClass.InvokeMethod("Create", inParams, null);\n\n        uint processId = (uint)outParams["ProcessId"];\n        Console.WriteLine($"Started process ID: {processId}");\n\n        // Wait for the process to exit\n        bool processExited = WaitForRemoteProcessToExit(manScope, processId);\n        Console.WriteLine($"Process exited: {processExited}");\n    }\n\n    private static bool WaitForRemoteProcessToExit(ManagementScope scope, uint processId)\n    {\n        string query = $"SELECT * FROM Win32_Process WHERE ProcessId = {processId}";\n        ObjectQuery wqlQuery = new ObjectQuery(query);\n\n        while (true)\n        {\n            using (ManagementObjectSearcher searcher = new ManagementObjectSearcher(scope, wqlQuery))\n            using (ManagementObjectCollection results = searcher.Get())\n            {\n                if (results.Count == 0)\n                {\n                    // Process has exited\n                    return true;\n                }\n            }\n\n            // Wait for a short interval before polling again\n            Thread.Sleep(1000);\n        }\n    }\n}