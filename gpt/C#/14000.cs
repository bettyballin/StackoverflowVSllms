using System;\nusing System.Threading;\n\nclass Foo\n{\n    public event EventHandler FooEvent;\n\n    public void RaiseFooEvent()\n    {\n        FooEvent?.Invoke(this, EventArgs.Empty);\n    }\n}\n\nclass Bar\n{\n    private SynchronizationContext _context;\n\n    public Bar(Foo foo)\n    {\n        _context = SynchronizationContext.Current;\n        foo.FooEvent += Foo_FooEvent;\n    }\n\n    private void Foo_FooEvent(object sender, EventArgs e)\n    {\n        // Post the event handling to the Bar's synchronization context\n        _context.Post(_ => HandleFooEvent(sender, e), null);\n    }\n\n    private void HandleFooEvent(object sender, EventArgs e)\n    {\n        Console.WriteLine("Foo event handled in Bar's thread.");\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Foo foo = new Foo();\n\n        // Create a thread for Bar\n        Thread barThread = new Thread(() =>\n        {\n            SynchronizationContext.SetSynchronizationContext(new SynchronizationContext());\n            Bar bar = new Bar(foo);\n\n            // Keep the Bar thread alive to listen for events\n            Application.Run();\n        });\n\n        barThread.Start();\n\n        // Simulate some work in the Foo thread\n        Thread.Sleep(1000);\n        foo.RaiseFooEvent();\n    }\n}