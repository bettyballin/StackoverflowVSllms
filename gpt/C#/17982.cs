using System;\nusing System.Runtime.InteropServices;\nusing System.Threading;\n\nclass Program\n{\n    [DllImport("Kernel32")]\n    public static extern bool SetConsoleCtrlHandler(HandlerRoutine Handler, bool Add);\n\n    public delegate bool HandlerRoutine(CtrlTypes CtrlType);\n\n    public enum CtrlTypes\n    {\n        CTRL_C_EVENT = 0,\n        CTRL_BREAK_EVENT,\n        CTRL_CLOSE_EVENT,\n        CTRL_LOGOFF_EVENT = 5,\n        CTRL_SHUTDOWN_EVENT\n    }\n\n    static void Main(string[] args)\n    {\n        SetConsoleCtrlHandler(new HandlerRoutine(ConsoleCtrlCheck), true);\n\n        // Simulate long running process\n        Console.WriteLine("Press any key to exit...");\n        Thread.Sleep(Timeout.Infinite);\n    }\n\n    private static bool ConsoleCtrlCheck(CtrlTypes ctrlType)\n    {\n        switch (ctrlType)\n        {\n            case CtrlTypes.CTRL_C_EVENT:\n            case CtrlTypes.CTRL_BREAK_EVENT:\n                Console.WriteLine("CTRL+C or CTRL+BREAK received!");\n                return true;\n\n            case CtrlTypes.CTRL_CLOSE_EVENT:\n                Console.WriteLine("Console is closing... Please wait.");\n                // Simulate some cleanup work\n                Thread.Sleep(5000); // Delay to simulate cleanup\n                Console.WriteLine("Cleanup complete.");\n                return false; // Returning false will allow the console to close after the delay\n\n            case CtrlTypes.CTRL_LOGOFF_EVENT:\n            case CtrlTypes.CTRL_SHUTDOWN_EVENT:\n                Console.WriteLine("User is logging off or system is shutting down.");\n                return true;\n\n            default:\n                return false;\n        }\n    }\n}