using System;\nusing System.IO;\nusing System.Net.Sockets;\nusing System.Security.Cryptography.X509Certificates;\nusing System.Net.Security;\n\nclass SslClient\n{\n    public static void Main(string[] args)\n    {\n        X509Certificate2 clientCertificate = GenerateSelfSignedCertificate("CN=Client");\n\n        TcpClient client = new TcpClient("localhost", 8080);\n        SslStream sslStream = new SslStream(client.GetStream(), false, new RemoteCertificateValidationCallback(ValidateServerCertificate), null);\n\n        try\n        {\n            sslStream.AuthenticateAsClient("localhost", new X509CertificateCollection(new X509Certificate[] { clientCertificate }), System.Security.Authentication.SslProtocols.Tls12, false);\n            Console.WriteLine("Server authenticated.");\n            // Handle communication...\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine("Exception: {0}", ex.Message);\n        }\n        finally\n        {\n            client.Close();\n        }\n    }\n\n    private static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)\n    {\n        if (sslPolicyErrors == SslPolicyErrors.None)\n            return true;\n\n        // Compare the received certificate with the known certificate\n        X509Certificate2 knownServerCertificate = new X509Certificate2("path_to_known_server_certificate.crt");\n        return certificate.Equals(knownServerCertificate);\n    }\n\n    private static X509Certificate2 GenerateSelfSignedCertificate(string subjectName)\n    {\n        // Generate self-signed certificate\n        // For simplicity, using BouncyCastle or other libraries is recommended for real projects.\n        // Placeholder code, replace with actual certificate generation logic\n        return new X509Certificate2();\n    }\n}