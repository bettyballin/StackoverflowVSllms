using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Text;\n\nclass Program\n{\n    // Import the GetVolumePathNamesForVolumeName function from kernel32.dll\n    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]\n    static extern bool GetVolumePathNamesForVolumeNameW(\n        string lpszVolumeName,\n        [Out] StringBuilder lpszVolumePathNames,\n        uint cchBuferLength,\n        ref uint lpcchReturnLength);\n\n    static void Main()\n    {\n        foreach (var drive in DriveInfo.GetDrives())\n        {\n            if (drive.DriveType == DriveType.Fixed)\n            {\n                CheckForMountPoints(drive.RootDirectory.FullName);\n            }\n        }\n    }\n\n    static void CheckForMountPoints(string rootPath)\n    {\n        foreach (var directory in Directory.GetDirectories(rootPath))\n        {\n            if (IsMountPoint(directory))\n            {\n                Console.WriteLine($"{directory} is a mount point.");\n            }\n\n            // Recursively check subdirectories\n            CheckForMountPoints(directory);\n        }\n    }\n\n    static bool IsMountPoint(string path)\n    {\n        string volumeName = GetVolumeNameForPath(path);\n        if (string.IsNullOrEmpty(volumeName))\n        {\n            return false;\n        }\n\n        var volumePaths = new StringBuilder(1024);\n        uint returnLength = 0;\n\n        bool result = GetVolumePathNamesForVolumeNameW(volumeName, volumePaths, (uint)volumePaths.Capacity, ref returnLength);\n        if (!result)\n        {\n            return false;\n        }\n\n        string[] paths = volumePaths.ToString().Split('\0', StringSplitOptions.RemoveEmptyEntries);\n        return paths.Length > 1;\n    }\n\n    static string GetVolumeNameForPath(string path)\n    {\n        StringBuilder volumeName = new StringBuilder(1024);\n        uint returnLength = 0;\n\n        bool success = GetVolumePathNamesForVolumeNameW(path, volumeName, (uint)volumeName.Capacity, ref returnLength);\n        if (success)\n        {\n            return volumeName.ToString();\n        }\n\n        return string.Empty;\n    }\n}