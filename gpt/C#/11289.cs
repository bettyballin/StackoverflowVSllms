using System;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Input;\n\npublic static class ValidationErrorBehavior\n{\n    public static readonly DependencyProperty HandleErrorCommandProperty =\n        DependencyProperty.RegisterAttached("HandleErrorCommand", typeof(ICommand), typeof(ValidationErrorBehavior), new PropertyMetadata(null, OnHandleErrorCommandChanged));\n\n    public static void SetHandleErrorCommand(UIElement element, ICommand value)\n    {\n        element.SetValue(HandleErrorCommandProperty, value);\n    }\n\n    public static ICommand GetHandleErrorCommand(UIElement element)\n    {\n        return (ICommand)element.GetValue(HandleErrorCommandProperty);\n    }\n\n    private static void OnHandleErrorCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)\n    {\n        if (d is TextBox textBox)\n        {\n            if (e.OldValue != null)\n            {\n                textBox.RemoveHandler(Validation.ErrorEvent, new EventHandler<ValidationErrorEventArgs>(OnValidationError));\n            }\n\n            if (e.NewValue != null)\n            {\n                textBox.AddHandler(Validation.ErrorEvent, new EventHandler<ValidationErrorEventArgs>(OnValidationError));\n            }\n        }\n    }\n\n    private static void OnValidationError(object sender, ValidationErrorEventArgs e)\n    {\n        var textBox = sender as TextBox;\n        var command = GetHandleErrorCommand(textBox);\n\n        if (command != null && command.CanExecute(e))\n        {\n            command.Execute(e);\n        }\n    }\n}