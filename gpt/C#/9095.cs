using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class ProcessChecker\n{\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool CloseHandle(IntPtr hObject);\n\n    private const uint PROCESS_QUERY_INFORMATION = 0x0400;\n    private const uint PROCESS_VM_READ = 0x0010;\n\n    public static bool IsProcessAlive(int processId)\n    {\n        IntPtr handle = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, processId);\n        if (handle == IntPtr.Zero) return false;\n\n        try\n        {\n            Process process = Process.GetProcessById(processId);\n            return !process.HasExited;\n        }\n        catch (Exception)\n        {\n            // Log or handle the exception as needed\n            return false;\n        }\n        finally\n        {\n            CloseHandle(handle);\n        }\n    }\n\n    public static void Main()\n    {\n        // Assuming clientProcessId is obtained from the ShellExecuteEx call\n        int clientProcessId = /* your process ID */;\n        \n        if (IsProcessAlive(clientProcessId))\n        {\n            // Process is alive\n        }\n        else\n        {\n            // Process has exited, run new one\n        }\n    }\n}