using System;\nusing System.Reflection;\nusing System.Security.Cryptography;\n\npublic class AssemblyVerifier\n{\n    public static bool VerifyAssemblyStrongName(string path, byte[] expectedPublicKeyToken)\n    {\n        try\n        {\n            Assembly loadedAssembly = Assembly.LoadFile(path);\n            AssemblyName assemblyName = loadedAssembly.GetName();\n            byte[] actualPublicKeyToken = assemblyName.GetPublicKeyToken();\n\n            if (actualPublicKeyToken == null || expectedPublicKeyToken == null)\n            {\n                return false;\n            }\n\n            if (!actualPublicKeyToken.SequenceEqual(expectedPublicKeyToken))\n            {\n                return false;\n            }\n\n            // Verify the assembly has a valid strong name signature\n            StrongNameSignatureVerificationEx(path, true, out bool isValid);\n            return isValid;\n        }\n        catch\n        {\n            return false;\n        }\n    }\n\n    [System.Runtime.InteropServices.DllImport("mscorwks.dll", CharSet = System.Runtime.InteropServices.CharSet.Unicode)]\n    public static extern bool StrongNameSignatureVerificationEx(string wszFilePath, bool fForceVerification, out bool pfWasVerified);\n}