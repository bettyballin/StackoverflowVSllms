using System;\nusing System.Collections.Concurrent;\nusing System.Net.Sockets;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class EventProcessor\n{\n    private readonly Socket _socket;\n    private readonly BlockingCollection<byte[]> _eventQueue = new BlockingCollection<byte[]>();\n    private readonly int _batchSize;\n    private readonly CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();\n\n    public EventProcessor(Socket socket, int batchSize)\n    {\n        _socket = socket ?? throw new ArgumentNullException(nameof(socket));\n        _batchSize = batchSize;\n\n        // Start the consumer thread\n        Task.Run(() => ProcessEventQueue(_cancellationTokenSource.Token));\n    }\n\n    public void StartReceiving()\n    {\n        var args = new SocketAsyncEventArgs();\n        args.Completed += OnReceiveCompleted;\n        ReceiveAsync(args);\n    }\n\n    private void ReceiveAsync(SocketAsyncEventArgs args)\n    {\n        if (!_socket.ReceiveAsync(args))\n        {\n            OnReceiveCompleted(this, args);\n        }\n    }\n\n    private void OnReceiveCompleted(object sender, SocketAsyncEventArgs args)\n    {\n        if (args.BytesTransferred > 0 && args.SocketError == SocketError.Success)\n        {\n            var message = new byte[args.BytesTransferred];\n            Array.Copy(args.Buffer, message, args.BytesTransferred);\n\n            // Check if it is an event message or a response message\n            if (IsEventMessage(message))\n            {\n                _eventQueue.Add(message);\n            }\n            else\n            {\n                // Process response message right away\n                Task.Run(() => ProcessResponseMessage(message));\n            }\n\n            // Continue receiving\n            ReceiveAsync(args);\n        }\n        else\n        {\n            // Handle disconnection or error\n            _cancellationTokenSource.Cancel();\n        }\n    }\n\n    private bool IsEventMessage(byte[] message)\n    {\n        // Implement your logic to determine if the message is an event message\n        return true;\n    }\n\n    private void ProcessResponseMessage(byte[] message)\n    {\n        // Implement your logic to process response messages\n    }\n\n    private void ProcessEventQueue(CancellationToken token)\n    {\n        var batch = new List<byte[]>();\n\n        while (!token.IsCancellationRequested)\n        {\n            try\n            {\n                var message = _eventQueue.Take(token);\n                batch.Add(message);\n\n                if (batch.Count >= _batchSize || _eventQueue.Count == 0)\n                {\n                    // Process the batch of event messages\n                    ProcessEventBatch(batch);\n                    batch.Clear();\n                }\n            }\n            catch (OperationCanceledException)\n            {\n                // Handle cancellation\n                break;\n            }\n        }\n\n        // Process any remaining messages in the batch\n        if (batch.Count > 0)\n        {\n            ProcessEventBatch(batch);\n        }\n    }\n\n    private void ProcessEventBatch(List<byte[]> batch)\n    {\n        // Implement your logic to process the batch of event messages\n    }\n\n    public void Stop()\n    {\n        _cancellationTokenSource.Cancel();\n    }\n}