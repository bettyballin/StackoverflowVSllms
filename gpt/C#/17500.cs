using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Windows;\n\nnamespace YourNamespace\n{\n    public partial class App : Application\n    {\n        [DllImport("user32.dll")]\n        private static extern bool SetForegroundWindow(IntPtr hWnd);\n\n        [DllImport("user32.dll")]\n        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);\n\n        private const int SW_RESTORE = 9;\n\n        private static Mutex _mutex;\n\n        protected override void OnStartup(StartupEventArgs e)\n        {\n            // Unique identifier for the mutex\n            string mutexName = "YourUniqueMutexName";\n\n            // Try to create a new mutex\n            _mutex = new Mutex(true, mutexName, out bool isNewInstance);\n\n            if (!isNewInstance)\n            {\n                // If not a new instance, find the existing process and bring it to front\n                Process currentProcess = Process.GetCurrentProcess();\n                foreach (var process in Process.GetProcessesByName(currentProcess.ProcessName))\n                {\n                    if (process.Id != currentProcess.Id)\n                    {\n                        // Bring the existing instance to the front\n                        ShowWindow(process.MainWindowHandle, SW_RESTORE);\n                        SetForegroundWindow(process.MainWindowHandle);\n                        break;\n                    }\n                }\n\n                // Exit the new instance\n                Shutdown();\n            }\n\n            base.OnStartup(e);\n        }\n\n        protected override void OnExit(ExitEventArgs e)\n        {\n            // Release the mutex\n            _mutex?.ReleaseMutex();\n            base.OnExit(e);\n        }\n    }\n}