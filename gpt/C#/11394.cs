using System;\nusing System.Collections.Generic;\nusing System.Runtime.InteropServices;\n\npublic class DllFunctionEnumerator\n{\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    private struct IMAGE_DOS_HEADER\n    {\n        public ushort e_magic;\n        public ushort e_cblp;\n        public ushort e_cp;\n        public ushort e_crlc;\n        public ushort e_cparhdr;\n        public ushort e_minalloc;\n        public ushort e_maxalloc;\n        public ushort e_ss;\n        public ushort e_sp;\n        public ushort e_csum;\n        public ushort e_ip;\n        public ushort e_cs;\n        public ushort e_lfarlc;\n        public ushort e_ovno;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]\n        public ushort[] e_res1;\n        public ushort e_oemid;\n        public ushort e_oeminfo;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]\n        public ushort[] e_res2;\n        public int e_lfanew;\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    private struct IMAGE_EXPORT_DIRECTORY\n    {\n        public int Characteristics;\n        public int TimeDateStamp;\n        public short MajorVersion;\n        public short MinorVersion;\n        public int Name;\n        public int Base;\n        public int NumberOfFunctions;\n        public int NumberOfNames;\n        public int AddressOfFunctions;\n        public int AddressOfNames;\n        public int AddressOfNameOrdinals;\n    }\n\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr LoadLibrary(string dllToLoad);\n\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool FreeLibrary(IntPtr hModule);\n\n    public static List<string> GetFunctionNames(string dllPath)\n    {\n        IntPtr hModule = LoadLibrary(dllPath);\n        if (hModule == IntPtr.Zero)\n        {\n            throw new Exception("Unable to load library: " + dllPath);\n        }\n\n        List<string> functionNames = new List<string>();\n        try\n        {\n            IntPtr pDosHeader = hModule;\n            IMAGE_DOS_HEADER dosHeader = Marshal.PtrToStructure<IMAGE_DOS_HEADER>(pDosHeader);\n\n            IntPtr pNtHeaders = IntPtr.Add(pDosHeader, dosHeader.e_lfanew);\n            IntPtr pExportDir = IntPtr.Add(pNtHeaders, 0x78); // Offset to IMAGE_EXPORT_DIRECTORY\n            IMAGE_EXPORT_DIRECTORY exportDirectory = Marshal.PtrToStructure<IMAGE_EXPORT_DIRECTORY>(pExportDir);\n\n            IntPtr pNames = IntPtr.Add(pDosHeader, exportDirectory.AddressOfNames);\n            for (int i = 0; i < exportDirectory.NumberOfNames; i++)\n            {\n                int nameRVA = Marshal.ReadInt32(IntPtr.Add(pNames, i * 4));\n                IntPtr pName = IntPtr.Add(pDosHeader, nameRVA);\n                string functionName = Marshal.PtrToStringAnsi(pName);\n                functionNames.Add(functionName);\n            }\n        }\n        finally\n        {\n            FreeLibrary(hModule);\n        }\n\n        return functionNames;\n    }\n}\n\n// Usage example\npublic class Program\n{\n    public static void Main()\n    {\n        string dllPath = @"path\to\your.dll";\n        List<string> functionNames = DllFunctionEnumerator.GetFunctionNames(dllPath);\n\n        foreach (string functionName in functionNames)\n        {\n            Console.WriteLine(functionName);\n        }\n    }\n}