using System;\nusing System.Reflection;\nusing System.Runtime.Loader;\n\npublic class PluginLoadContext : AssemblyLoadContext\n{\n    private AssemblyDependencyResolver _resolver;\n\n    public PluginLoadContext(string pluginPath)\n    {\n        _resolver = new AssemblyDependencyResolver(pluginPath);\n    }\n\n    protected override Assembly Load(AssemblyName assemblyName)\n    {\n        string assemblyPath = _resolver.ResolveAssemblyToPath(assemblyName);\n        if (assemblyPath != null)\n        {\n            return LoadFromAssemblyPath(assemblyPath);\n        }\n        return null;\n    }\n\n    public void UnloadPlugin()\n    {\n        Unload();\n        // Wait for the plugin to be fully unloaded\n        for (int i = 0; i < 10; i++)\n        {\n            GC.Collect();\n            GC.WaitForPendingFinalizers();\n        }\n    }\n}\n\npublic class PluginManager\n{\n    private PluginLoadContext _pluginLoadContext;\n\n    public void LoadPlugin(string pluginPath)\n    {\n        _pluginLoadContext = new PluginLoadContext(pluginPath);\n        Assembly pluginAssembly = _pluginLoadContext.LoadFromAssemblyName(new AssemblyName("PluginAssemblyName"));\n\n        // Use reflection to invoke the plugin\n        Type pluginType = pluginAssembly.GetType("PluginNamespace.PluginClass");\n        object pluginInstance = Activator.CreateInstance(pluginType);\n        MethodInfo pluginMethod = pluginType.GetMethod("PluginMethod");\n        pluginMethod.Invoke(pluginInstance, null);\n    }\n\n    public void UnloadPlugin()\n    {\n        _pluginLoadContext.UnloadPlugin();\n    }\n}