using NHibernate;\nusing NHibernate.SqlTypes;\nusing NHibernate.UserTypes;\nusing System;\nusing System.Data;\n\npublic class UInt32UserType : IUserType\n{\n    public bool IsMutable => false;\n\n    public Type ReturnedType => typeof(uint);\n\n    public SqlType[] SqlTypes => new SqlType[] { SqlTypeFactory.Int64 };\n\n    public object NullSafeGet(IDataReader rs, string[] names, object owner)\n    {\n        var value = NHibernateUtil.Int64.NullSafeGet(rs, names[0]);\n        return value != null ? Convert.ToUInt32(value) : (uint?)null;\n    }\n\n    public void NullSafeSet(IDbCommand cmd, object value, int index)\n    {\n        if (value == null)\n        {\n            NHibernateUtil.Int64.NullSafeSet(cmd, null, index);\n        }\n        else\n        {\n            NHibernateUtil.Int64.NullSafeSet(cmd, Convert.ToInt64((uint)value), index);\n        }\n    }\n\n    public object DeepCopy(object value)\n    {\n        return value;\n    }\n\n    public object Replace(object original, object target, object owner)\n    {\n        return original;\n    }\n\n    public object Assemble(object cached, object owner)\n    {\n        return cached;\n    }\n\n    public object Disassemble(object value)\n    {\n        return value;\n    }\n\n    public bool Equals(object x, object y)\n    {\n        return x?.Equals(y) ?? y == null;\n    }\n\n    public int GetHashCode(object x)\n    {\n        return x?.GetHashCode() ?? 0;\n    }\n}