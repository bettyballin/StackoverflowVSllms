using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Collections.Concurrent;\n\nclass UdpImageReceiver\n{\n    private const int Port = 12345;\n    private UdpClient udpClient;\n    private ConcurrentDictionary<int, byte[]> packets;\n    private int expectedPackets = -1;\n\n    public UdpImageReceiver()\n    {\n        udpClient = new UdpClient(Port);\n        packets = new ConcurrentDictionary<int, byte[]>();\n    }\n\n    public void StartReceiving()\n    {\n        udpClient.BeginReceive(new AsyncCallback(ReceiveCallback), null);\n    }\n\n    private void ReceiveCallback(IAsyncResult ar)\n    {\n        IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Any, Port);\n        byte[] receivedData = udpClient.EndReceive(ar, ref ipEndPoint);\n\n        int packetIndex = receivedData[0];\n        int totalPackets = receivedData[1];\n\n        if (expectedPackets == -1)\n        {\n            expectedPackets = totalPackets;\n        }\n\n        byte[] imageData = new byte[receivedData.Length - 2];\n        Buffer.BlockCopy(receivedData, 2, imageData, 0, receivedData.Length - 2);\n        packets[packetIndex] = imageData;\n\n        if (packets.Count == expectedPackets)\n        {\n            byte[] completeImage = new byte[expectedPackets * (receivedData.Length - 2)];\n            foreach (var kvp in packets)\n            {\n                Buffer.BlockCopy(kvp.Value, 0, completeImage, kvp.Key * (receivedData.Length - 2), kvp.Value.Length);\n            }\n\n            // Process the complete image\n            ProcessImage(completeImage);\n\n            // Clear the state for the next image\n            packets.Clear();\n            expectedPackets = -1;\n        }\n\n        udpClient.BeginReceive(new AsyncCallback(ReceiveCallback), null);\n    }\n\n    private void ProcessImage(byte[] image)\n    {\n        // Handle the received image\n        Console.WriteLine("Received complete image of size: " + image.Length);\n    }\n}