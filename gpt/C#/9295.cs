using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class ProcessLauncher\n{\n    [DllImport("advapi32.dll", SetLastError=true, CharSet=CharSet.Auto)]\n    private static extern bool CreateProcessWithLogonW(\n        string userName,\n        string domain,\n        string password,\n        int logonFlags,\n        string applicationName,\n        string commandLine,\n        int creationFlags,\n        IntPtr environment,\n        string currentDirectory,\n        ref STARTUPINFO startupInfo,\n        out PROCESS_INFORMATION processInformation);\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct STARTUPINFO\n    {\n        public int cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public int dwX;\n        public int dwY;\n        public int dwXSize;\n        public int dwYSize;\n        public int dwXCountChars;\n        public int dwYCountChars;\n        public int dwFillAttribute;\n        public int dwFlags;\n        public short wShowWindow;\n        public short cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    private struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public int dwProcessId;\n        public int dwThreadId;\n    }\n\n    public static bool StartProcessAsUser(string applicationPath, string username, string domain, string password)\n    {\n        var processInfo = new PROCESS_INFORMATION();\n        var startupInfo = new STARTUPINFO();\n        startupInfo.cb = Marshal.SizeOf(startupInfo);\n\n        bool result = CreateProcessWithLogonW(\n            username,\n            domain,\n            password,\n            0,\n            applicationPath,\n            null,\n            0,\n            IntPtr.Zero,\n            null,\n            ref startupInfo,\n            out processInfo);\n\n        if (result)\n        {\n            // Ensure to close the handles properly to avoid resource leaks\n            if (processInfo.hProcess != IntPtr.Zero)\n            {\n                CloseHandle(processInfo.hProcess);\n            }\n            if (processInfo.hThread != IntPtr.Zero)\n            {\n                CloseHandle(processInfo.hThread);\n            }\n        }\n        return result;\n    }\n\n    [DllImport("kernel32.dll", SetLastError=true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    private static extern bool CloseHandle(IntPtr hObject);\n}