using System;\nusing System.Threading.Tasks;\n\npublic class BackgroundWorker\n{\n    public event EventHandler<EventArgs> WorkCompleted;\n\n    protected virtual void OnWorkCompleted()\n    {\n        // Fire the event asynchronously\n        var handlers = WorkCompleted?.GetInvocationList();\n        if (handlers != null)\n        {\n            foreach (var handler in handlers)\n            {\n                Task.Run(() => handler.DynamicInvoke(this, EventArgs.Empty));\n            }\n        }\n    }\n\n    public void DoWork()\n    {\n        // Simulate some background work\n        Task.Run(() =>\n        {\n            // Background work is done here...\n            Console.WriteLine("Background work completed.");\n\n            // Notify the main thread\n            OnWorkCompleted();\n        });\n    }\n}\n\npublic class Controller\n{\n    public void Start()\n    {\n        var worker = new BackgroundWorker();\n        worker.WorkCompleted += Worker_WorkCompleted;\n\n        worker.DoWork();\n    }\n\n    private void Worker_WorkCompleted(object sender, EventArgs e)\n    {\n        // This code runs asynchronously\n        Console.WriteLine("Work completed event received.");\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        var controller = new Controller();\n        controller.Start();\n\n        // Keep the console open to see the output\n        Console.ReadLine();\n    }\n}