using System;\nusing System.Collections.Generic;\nusing System.IO;\n\npublic class FileTypeChecker\n{\n    // Dictionary of magic numbers for various file types\n    private static readonly Dictionary<string, byte[]> FileSignatures = new Dictionary<string, byte[]>\n    {\n        { ".PDF", new byte[] { 0x25, 0x50, 0x44, 0x46 } },  // %PDF\n        { ".XLS", new byte[] { 0xD0, 0xCF, 0x11, 0xE0 } },  // Microsoft Office files\n        { ".XML", new byte[] { 0x3C, 0x3F, 0x78, 0x6D, 0x6C } },  // <?xml\n        { ".CSV", new byte[] { 0x2C } },  // Comma separated values\n        { ".TXT", new byte[] { 0x54, 0x65, 0x78, 0x74 } },  // Text files\n        { ".PPT", new byte[] { 0xD0, 0xCF, 0x11, 0xE0 } }  // Microsoft PowerPoint files\n    };\n\n    public static bool IsValidFileType(string filePath, string expectedExtension)\n    {\n        if (!File.Exists(filePath) || !FileSignatures.ContainsKey(expectedExtension.ToUpper()))\n            return false;\n\n        byte[] fileHeader = new byte[FileSignatures[expectedExtension.ToUpper()].Length];\n        using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read))\n        {\n            fs.Read(fileHeader, 0, fileHeader.Length);\n        }\n\n        byte[] expectedHeader = FileSignatures[expectedExtension.ToUpper()];\n        for (int i = 0; i < expectedHeader.Length; i++)\n        {\n            if (fileHeader[i] != expectedHeader[i])\n                return false;\n        }\n\n        return true;\n    }\n}