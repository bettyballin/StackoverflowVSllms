using System;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    // Import LoadLibrary and GetProcAddress from kernel32.dll\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr LoadLibrary(string dllToLoad);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern IntPtr GetProcAddress(IntPtr hModule, string procedureName);\n\n    [DllImport("kernel32.dll", SetLastError = true)]\n    private static extern bool FreeLibrary(IntPtr hModule);\n\n    // Define a delegate that matches the DLL function signature\n    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]\n    private delegate int MyFunctionDelegate(int a, int b);\n\n    static void Main()\n    {\n        // Path to the DLL (can be dynamic)\n        string dllPath = @"C:\path\to\your.dll";\n\n        // Load the DLL\n        IntPtr pDll = LoadLibrary(dllPath);\n        if (pDll == IntPtr.Zero)\n        {\n            Console.WriteLine("Failed to load DLL");\n            return;\n        }\n\n        // Get the address of the function in the DLL\n        IntPtr pAddressOfFunctionToCall = GetProcAddress(pDll, "MyFunction");\n        if (pAddressOfFunctionToCall == IntPtr.Zero)\n        {\n            Console.WriteLine("Failed to get function address");\n            FreeLibrary(pDll);\n            return;\n        }\n\n        // Convert the function address to a delegate\n        MyFunctionDelegate myFunction = (MyFunctionDelegate)Marshal.GetDelegateForFunctionPointer(\n            pAddressOfFunctionToCall,\n            typeof(MyFunctionDelegate));\n\n        // Call the function\n        int result = myFunction(2, 3);\n        Console.WriteLine($"Result: {result}");\n\n        // Free the DLL\n        FreeLibrary(pDll);\n    }\n}