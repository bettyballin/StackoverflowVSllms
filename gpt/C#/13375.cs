using System;\nusing System.Threading;\n\nclass OneUseBackgroundOp\n{\n    // background args\n    private string _x;\n    private object _y;\n    private long _z;\n\n    // background results\n    private volatile DateTime _a;\n    private volatile double _b;\n    private volatile object _c;\n\n    // thread control\n    private Thread _task;\n    private ManualResetEvent _completedSignal;\n    private volatile bool _completed;\n\n    public bool DoSomething(string x, object y, long z, int initialWaitMs)\n    {\n        bool doneWithinWait;\n\n        _x = x;\n        _y = y;\n        _z = z;\n\n        _completedSignal = new ManualResetEvent(false);\n\n        _task = new Thread(new ThreadStart(Task));\n        _task.IsBackground = true;\n        _task.Start();\n\n        doneWithinWait = _completedSignal.WaitOne(initialWaitMs);\n\n        return doneWithinWait;\n    }\n\n    public bool Completed\n    {\n        get\n        {\n            return _completed;\n        }\n    }\n\n    /* public getters for the result fields go here, with an exception\n       thrown if _completed is not true; */\n\n    private void Task()\n    {\n        // args x, y, and z are written once, before the Thread.Start\n        //    implicit memory barrier so they may be accessed freely.\n\n        // possibly long-running work goes here\n\n        // with the work completed, assign the result fields _a, _b, _c here\n\n        _completed = true;\n        _completedSignal.Set();\n    }\n}