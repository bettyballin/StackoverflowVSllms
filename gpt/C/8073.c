#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <readline/readline.h>\n#include <readline/history.h>\n\n#define NUMPIPES 2\n\nint main(int argc, char *argv[]) {\n    char *bBuffer, *sPtr, *aPtr, *pipeComms[NUMPIPES + 1], *cmdArgs[10];\n    int fdPipe[NUMPIPES][2], pCount, aCount, i, status, lPids[NUMPIPES + 1];\n    pid_t pid;\n\n    while(1) {\n        bBuffer = readline("Shell> ");\n        if (!bBuffer) continue;\n\n        if (!strcasecmp(bBuffer, "exit")) {\n            free(bBuffer);\n            return 0;\n        }\n\n        sPtr = bBuffer;\n        pCount = -1;\n\n        do {\n            aPtr = strsep(&sPtr, "|");\n            pipeComms[++pCount] = aPtr;\n        } while (aPtr);\n\n        for (i = 0; i < pCount; i++) {\n            if (i < pCount - 1) {\n                if (pipe(fdPipe[i]) == -1) {\n                    perror("pipe");\n                    exit(1);\n                }\n            }\n\n            aCount = -1;\n            do {\n                aPtr = strsep(&pipeComms[i], " ");\n                cmdArgs[++aCount] = aPtr;\n            } while (aPtr);\n            cmdArgs[aCount] = 0;\n\n            if (strlen(cmdArgs[0]) > 0) {\n                pid = fork();\n\n                if (pid == 0) { // Child process\n                    if (i > 0) {\n                        dup2(fdPipe[i-1][0], STDIN_FILENO);\n                        close(fdPipe[i-1][0]);\n                        close(fdPipe[i-1][1]);\n                    }\n\n                    if (i < pCount - 1) {\n                        close(fdPipe[i][0]);\n                        dup2(fdPipe[i][1], STDOUT_FILENO);\n                        close(fdPipe[i][1]);\n                    }\n\n                    execvp(cmdArgs[0], cmdArgs);\n                    perror("execvp");\n                    exit(1);\n                } else if (pid > 0) { // Parent process\n                    lPids[i] = pid;\n                    if (i > 0) {\n                        close(fdPipe[i-1][0]);\n                        close(fdPipe[i-1][1]);\n                    }\n                } else {\n                    perror("fork");\n                    exit(1);\n                }\n            }\n        }\n\n        free(bBuffer);\n\n        for (i = 0; i < pCount; i++) {\n            waitpid(lPids[i], &status, 0);\n            if (WIFEXITED(status)) {\n                printf("[%d] TERMINATED (Status: %d)\n", lPids[i], WEXITSTATUS(status));\n            }\n        }\n    }\n\n    return 0;\n}