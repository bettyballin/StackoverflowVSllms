#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#define MAX_EXPR_SIZE 100\n#define MAX_STACK_SIZE 100\n\ntypedef struct {\n    char items[MAX_STACK_SIZE];\n    int top;\n} Stack;\n\nvoid initStack(Stack* stack) {\n    stack->top = -1;\n}\n\nint isEmpty(Stack* stack) {\n    return stack->top == -1;\n}\n\nint isFull(Stack* stack) {\n    return stack->top == MAX_STACK_SIZE - 1;\n}\n\nvoid push(Stack* stack, char item) {\n    if (!isFull(stack)) {\n        stack->items[++stack->top] = item;\n    }\n}\n\nchar pop(Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->items[stack->top--];\n    }\n    return '\0';\n}\n\nchar peek(Stack* stack) {\n    if (!isEmpty(stack)) {\n        return stack->items[stack->top];\n    }\n    return '\0';\n}\n\nint precedence(char op) {\n    switch (op) {\n        case '+':\n        case '-':\n            return 1;\n        case '*':\n        case '/':\n            return 2;\n        case '&':\n        case '|':\n            return 0; // lowest precedence for bitwise operators\n        default:\n            return -1;\n    }\n}\n\nint isOperator(char ch) {\n    return ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '&' || ch == '|';\n}\n\nvoid infixToPostfix(char* infix, char* postfix) {\n    Stack stack;\n    initStack(&stack);\n    int i, k;\n    for (i = 0, k = 0; infix[i]; ++i) {\n        if (isdigit(infix[i])) {\n            postfix[k++] = infix[i];\n        } else if (infix[i] == '(') {\n            push(&stack, infix[i]);\n        } else if (infix[i] == ')') {\n            while (!isEmpty(&stack) && peek(&stack) != '(') {\n                postfix[k++] = pop(&stack);\n            }\n            if (!isEmpty(&stack) && peek(&stack) != '(') {\n                // invalid expression\n                return;\n            } else {\n                pop(&stack);\n            }\n        } else if (isOperator(infix[i])) {\n            while (!isEmpty(&stack) && precedence(infix[i]) <= precedence(peek(&stack))) {\n                postfix[k++] = pop(&stack);\n            }\n            push(&stack, infix[i]);\n        }\n    }\n    while (!isEmpty(&stack)) {\n        postfix[k++] = pop(&stack);\n    }\n    postfix[k] = '\0';\n}\n\nint evaluatePostfix(char* postfix) {\n    Stack stack;\n    initStack(&stack);\n    for (int i = 0; postfix[i]; ++i) {\n        if (isdigit(postfix[i])) {\n            push(&stack, postfix[i] - '0');\n        } else {\n            int val1 = pop(&stack);\n            int val2 = pop(&stack);\n            switch (postfix[i]) {\n                case '+': push(&stack, val2 + val1); break;\n                case '-': push(&stack, val2 - val1); break;\n                case '*': push(&stack, val2 * val1); break;\n                case '/': push(&stack, val2 / val1); break;\n            }\n        }\n    }\n    return pop(&stack);\n}\n\nint main() {\n    char infix[MAX_EXPR_SIZE];\n    char postfix[MAX_EXPR_SIZE];\n\n    printf("Enter an infix expression: ");\n    fgets(infix, MAX_EXPR_SIZE, stdin);\n\n    // Remove newline character from the end if present\n    size_t len = strlen(infix);\n    if (len > 0 && infix[len - 1] == '\n') {\n        infix[len - 1] = '\0';\n    }\n\n    infixToPostfix(infix, postfix);\n    printf("Postfix expression: %s\n", postfix);\n    printf("Result: %d\n", evaluatePostfix(postfix));\n\n    return 0;\n}