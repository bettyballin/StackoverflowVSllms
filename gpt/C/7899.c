#include <windows.h>\n#include <iphlpapi.h>\n#include <stdio.h>\n\n#pragma comment(lib, "iphlpapi.lib")\n\nvoid EnumerateTcpSockets() {\n    PMIB_TCPTABLE_OWNER_PID pTcpTable;\n    DWORD dwSize = 0;\n    DWORD dwRetVal = 0;\n\n    pTcpTable = (MIB_TCPTABLE_OWNER_PID *) malloc(sizeof(MIB_TCPTABLE_OWNER_PID));\n    if (pTcpTable == NULL) {\n        printf("Error allocating memory\n");\n        return;\n    }\n\n    dwSize = sizeof(MIB_TCPTABLE_OWNER_PID);\n    if ((dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0)) == ERROR_INSUFFICIENT_BUFFER) {\n        free(pTcpTable);\n        pTcpTable = (MIB_TCPTABLE_OWNER_PID *) malloc(dwSize);\n        if (pTcpTable == NULL) {\n            printf("Error allocating memory\n");\n            return;\n        }\n    }\n\n    if ((dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0)) == NO_ERROR) {\n        printf("\nTCP Connections:\n");\n        for (int i = 0; i < (int)pTcpTable->dwNumEntries; i++) {\n            printf("PID: %lu, Local Addr: %s:%d, Remote Addr: %s:%d, State: %d\n",\n                pTcpTable->table[i].dwOwningPid,\n                inet_ntoa(*(struct in_addr *)&pTcpTable->table[i].dwLocalAddr),\n                ntohs((u_short)pTcpTable->table[i].dwLocalPort),\n                inet_ntoa(*(struct in_addr *)&pTcpTable->table[i].dwRemoteAddr),\n                ntohs((u_short)pTcpTable->table[i].dwRemotePort),\n                pTcpTable->table[i].dwState);\n        }\n    } else {\n        printf("GetExtendedTcpTable failed with %d\n", dwRetVal);\n    }\n\n    if (pTcpTable != NULL) {\n        free(pTcpTable);\n        pTcpTable = NULL;\n    }\n}\n\nint main() {\n    EnumerateTcpSockets();\n    return 0;\n}