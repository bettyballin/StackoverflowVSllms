#include <linux/module.h>\n   #include <linux/kernel.h>\n   #include <linux/init.h>\n   #include <linux/netlink.h>\n   #include <net/sock.h>\n   \n   #define NETLINK_USER 31\n   \n   struct sock *nl_sk = NULL;\n   \n   static void nl_recv_msg(struct sk_buff *skb) {\n       struct nlmsghdr *nlh;\n       int pid;\n       struct sk_buff *skb_out;\n       int msg_size;\n       char *msg = "Hello from kernel";\n       int res;\n   \n       nlh = (struct nlmsghdr*)skb->data;\n       pid = nlh->nlmsg_pid; // PID of sending process\n   \n       msg_size = strlen(msg);\n       skb_out = nlmsg_new(msg_size, 0);\n   \n       if (!skb_out) {\n           printk(KERN_ERR "Failed to allocate new skb\n");\n           return;\n       }\n   \n       nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, 0);  \n       NETLINK_CB(skb_out).dst_group = 0; // not in multi-cast group\n       strncpy(nlmsg_data(nlh), msg, msg_size);\n   \n       res = nlmsg_unicast(nl_sk, skb_out, pid);\n   \n       if (res < 0)\n           printk(KERN_INFO "Error while sending back to user\n");\n   }\n   \n   static int __init hello_init(void) {\n       struct netlink_kernel_cfg cfg = {\n           .input = nl_recv_msg,\n       };\n   \n       nl_sk = netlink_kernel_create(&init_net, NETLINK_USER, &cfg);\n       if (!nl_sk) {\n           printk(KERN_ALERT "Error creating socket.\n");\n           return -10;\n       }\n   \n       printk(KERN_INFO "Module initialized\n");\n       return 0;\n   }\n   \n   static void __exit hello_exit(void) {\n       netlink_kernel_release(nl_sk);\n       printk(KERN_INFO "Module exited\n");\n   }\n   \n   module_init(hello_init); \n   module_exit(hello_exit);\n   \n   MODULE_LICENSE("GPL");