#include <windows.h>\n#include <stdio.h>\n\nint main() {\n    // Define variables\n    SECURITY_ATTRIBUTES saAttr;\n    HANDLE hChildStdOutRd, hChildStdOutWr;\n    PROCESS_INFORMATION piProcInfo;\n    STARTUPINFO siStartInfo;\n    DWORD dwRead;\n    CHAR chBuf[4096];\n    BOOL bSuccess = FALSE;\n\n    // Set the security attributes structure\n    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);\n    saAttr.bInheritHandle = TRUE;\n    saAttr.lpSecurityDescriptor = NULL;\n\n    // Create a pipe for the child process's STDOUT\n    if (!CreatePipe(&hChildStdOutRd, &hChildStdOutWr, &saAttr, 0)) {\n        fprintf(stderr, "Stdout pipe creation failed\n");\n        return 1;\n    }\n\n    // Ensure the read handle to the pipe for STDOUT is not inherited\n    if (!SetHandleInformation(hChildStdOutRd, HANDLE_FLAG_INHERIT, 0)) {\n        fprintf(stderr, "Stdout SetHandleInformation failed\n");\n        return 1;\n    }\n\n    // Set up members of the STARTUPINFO structure\n    ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));\n    siStartInfo.cb = sizeof(STARTUPINFO);\n    siStartInfo.hStdError = hChildStdOutWr;\n    siStartInfo.hStdOutput = hChildStdOutWr;\n    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;\n\n    // Create the child process\n    bSuccess = CreateProcess(NULL,\n        "child_program.exe",      // Command line\n        NULL,                    // Process security attributes\n        NULL,                    // Primary thread security attributes\n        TRUE,                    // Handles are inherited\n        0,                       // Creation flags\n        NULL,                    // Use parent's environment\n        NULL,                    // Use parent's current directory\n        &siStartInfo,            // STARTUPINFO pointer\n        &piProcInfo);            // Receives PROCESS_INFORMATION\n\n    // If an error occurs, exit the application\n    if (!bSuccess) {\n        fprintf(stderr, "CreateProcess failed\n");\n        return 1;\n    } else {\n        // Close the write end of the pipe before reading from the read end of the pipe\n        CloseHandle(hChildStdOutWr);\n\n        // Read output from the child process\n        for (;;) {\n            bSuccess = ReadFile(hChildStdOutRd, chBuf, sizeof(chBuf), &dwRead, NULL);\n            if (!bSuccess || dwRead == 0) break;\n\n            // Write to parent process's STDOUT\n            fwrite(chBuf, 1, dwRead, stdout);\n        }\n\n        // Wait until child process exits\n        WaitForSingleObject(piProcInfo.hProcess, INFINITE);\n\n        // Close handles\n        CloseHandle(piProcInfo.hProcess);\n        CloseHandle(piProcInfo.hThread);\n        CloseHandle(hChildStdOutRd);\n    }\n\n    return 0;\n}