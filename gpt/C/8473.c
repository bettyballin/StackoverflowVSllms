#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <netinet/sctp.h>\n\n#define PORT 5000\n#define BUFFER_SIZE 1024\n\nint main() {\n    int sockfd;\n    struct sockaddr_in servaddr;\n    char buffer[BUFFER_SIZE];\n\n    // Create SCTP one-to-many socket\n    sockfd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP);\n    if (sockfd == -1) {\n        perror("socket");\n        exit(EXIT_FAILURE);\n    }\n\n    memset(&servaddr, 0, sizeof(servaddr));\n    servaddr.sin_family = AF_INET;\n    servaddr.sin_addr.s_addr = INADDR_ANY;\n    servaddr.sin_port = htons(PORT);\n\n    // Bind the socket to the server address and port\n    if (bind(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {\n        perror("bind");\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n\n    // Listen for incoming SCTP connections\n    if (listen(sockfd, 5) == -1) {\n        perror("listen");\n        close(sockfd);\n        exit(EXIT_FAILURE);\n    }\n\n    printf("SCTP server listening on port %d\n", PORT);\n\n    while (1) {\n        struct sockaddr_in cliaddr;\n        socklen_t clilen = sizeof(cliaddr);\n        struct sctp_sndrcvinfo sndrcvinfo;\n        int flags = 0;\n\n        // Receive a message from a client\n        int recv_len = sctp_recvmsg(sockfd, buffer, BUFFER_SIZE, (struct sockaddr *)&cliaddr, &clilen, &sndrcvinfo, &flags);\n        if (recv_len == -1) {\n            perror("sctp_recvmsg");\n            continue;\n        }\n\n        buffer[recv_len] = '\0';\n        printf("Received message: %s\n", buffer);\n\n        // Echo the message back to the client\n        if (sctp_sendmsg(sockfd, buffer, recv_len, (struct sockaddr *)&cliaddr, clilen, sndrcvinfo.sinfo_ppid, sndrcvinfo.sinfo_flags, sndrcvinfo.sinfo_stream, 0, 0) == -1) {\n            perror("sctp_sendmsg");\n        }\n    }\n\n    close(sockfd);\n    return 0;\n}