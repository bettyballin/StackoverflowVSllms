#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#include <signal.h>\n\n#define SMALL_SIZE 10000\n#define BIG_SIZE 1000000000\n#define SIZE BIG_SIZE\n#define REPEATS 1\n\nvoid signal_handler(int signum) {\n    printf("Process %d received signal %d\n", getpid(), signum);\n    exit(EXIT_FAILURE);\n}\n\nint main() {\n    signal(SIGTERM, signal_handler);\n    signal(SIGKILL, signal_handler); // Note: SIGKILL cannot be caught or ignored\n\n    pid_t my_pid = getpid();\n    char *x = malloc(SIZE * sizeof(char));\n\n    if (x == NULL) {\n        printf("Malloc failed!\n");\n        return EXIT_FAILURE;\n    }\n\n    for (int x2 = 0; x2 < REPEATS; ++x2) {\n        for (int y = 0; y < SIZE; ++y) {\n            x[y] = (y + my_pid) % 256;\n        }\n    }\n\n    printf("%d: I'm over.\n", my_pid);\n    free(x);\n    return EXIT_SUCCESS;\n}\n\nint fork_and_wait() {\n    pid_t pid = fork();\n    if (pid == 0) {\n        // Child process\n        exit(main());\n    } else if (pid > 0) {\n        // Parent process\n        int status;\n        waitpid(pid, &status, 0);\n        if (WIFEXITED(status)) {\n            printf("Child %d exited with status %d\n", pid, WEXITSTATUS(status));\n        } else if (WIFSIGNALED(status)) {\n            printf("Child %d killed by signal %d\n", pid, WTERMSIG(status));\n        }\n    } else {\n        // Fork failed\n        perror("fork");\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nint main() {\n    for (int i = 0; i < 5; i++) {\n        fork_and_wait();\n    }\n    return 0;\n}