#include <stdio.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        fprintf(stderr, "Usage: %s cmd1 cmd2 ... cmdN\n", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    int fd[2], i, aux_fd, std0, std1;\n\n    std0 = dup(0); // backup stdin\n    std1 = dup(1); // backup stdout\n\n    for (i = 1; i < argc; i++) {\n        if (i > 1) {\n            dup2(aux_fd, 0);\n            close(aux_fd);\n        }\n\n        if (i < argc - 1) {\n            if (pipe(fd) == -1) {\n                perror("pipe");\n                exit(EXIT_FAILURE);\n            }\n            aux_fd = fd[0];\n            dup2(fd[1], 1);\n            close(fd[1]);\n        } else {\n            dup2(std1, 1);\n            close(std1);\n        }\n\n        if (fork() == 0) { // Child process\n            if (i < argc - 1) {\n                close(fd[0]);\n            }\n            execlp(argv[i], argv[i], (char *)NULL);\n            perror("execlp");\n            exit(EXIT_FAILURE);\n        }\n\n        if (i < argc - 1) {\n            close(fd[1]);\n        }\n    }\n\n    for (i = 1; i < argc; i++) {\n        wait(NULL); // Wait for each child\n    }\n\n    // Restore stdin and stdout to keep using the shell\n    dup2(std0, 0);\n    close(std0);\n    dup2(std1, 1);\n\n    return 0;\n}