#include <windows.h>\n#include <wincrypt.h>\n#include <schannel.h>\n\nSECURITY_STATUS InitializeSchannel(PCredHandle phCreds, CtxtHandle *phContext, BOOL fClient, PBYTE pbSessionID, DWORD cbSessionID) {\n    // Initialize security package\n    SecPkgContext_SessionKey sessionKey;\n    SECURITY_STATUS ss = SEC_E_OK;\n    \n    // Create the security credentials\n    SCHANNEL_CRED schannelCred = { 0 };\n    schannelCred.dwVersion = SCHANNEL_CRED_VERSION;\n    schannelCred.grbitEnabledProtocols = SP_PROT_TLS1_2; // Use the desired protocol\n    \n    // Acquire the credentials handle\n    ss = AcquireCredentialsHandle(NULL, UNISP_NAME, fClient ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND, NULL, &schannelCred, NULL, NULL, phCreds, NULL);\n    if (ss != SEC_E_OK) {\n        return ss;\n    }\n    \n    // Initialize security context\n    SecBufferDesc OutBuffer, InBuffer;\n    SecBuffer OutBuffers[1], InBuffers[1];\n    DWORD dwSSPIFlags, dwSSPIOutFlags;\n\n    OutBuffers[0].pvBuffer = NULL;\n    OutBuffers[0].BufferType = SECBUFFER_TOKEN;\n    OutBuffers[0].cbBuffer = 0;\n\n    OutBuffer.cBuffers = 1;\n    OutBuffer.pBuffers = OutBuffers;\n    OutBuffer.ulVersion = SECBUFFER_VERSION;\n\n    InBuffers[0].pvBuffer = pbSessionID;\n    InBuffers[0].cbBuffer = cbSessionID;\n    InBuffers[0].BufferType = SECBUFFER_TOKEN;\n\n    InBuffer.cBuffers = 1;\n    InBuffer.pBuffers = InBuffers;\n    InBuffer.ulVersion = SECBUFFER_VERSION;\n\n    dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |\n                  ISC_REQ_CONFIDENTIALITY | ISC_RET_EXTENDED_ERROR |\n                  ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_STREAM;\n\n    ss = InitializeSecurityContext(phCreds, NULL, NULL, dwSSPIFlags, 0, SECURITY_NATIVE_DREP, &InBuffer, 0, phContext, &OutBuffer, &dwSSPIOutFlags, NULL);\n    \n    if (ss == SEC_I_CONTINUE_NEEDED || ss == SEC_E_OK) {\n        // Save the session ID for reuse\n        QueryContextAttributes(phContext, SECPKG_ATTR_SESSION_KEY, &sessionKey);\n        pbSessionID = (PBYTE)malloc(sessionKey.SessionKeyLength);\n        memcpy(pbSessionID, sessionKey.SessionKey, sessionKey.SessionKeyLength);\n        cbSessionID = sessionKey.SessionKeyLength;\n    }\n    \n    return ss;\n}\n\nint main() {\n    CredHandle hClientCreds;\n    CtxtHandle hClientContext;\n    BYTE *pbSessionID = NULL;\n    DWORD cbSessionID = 0;\n\n    SECURITY_STATUS ss = InitializeSchannel(&hClientCreds, &hClientContext, TRUE, pbSessionID, cbSessionID);\n    if (ss != SEC_E_OK) {\n        printf("Failed to initialize Schannel: 0x%x\n", ss);\n        return 1;\n    }\n\n    // Use the session ID to reconnect without renegotiation\n    ss = InitializeSchannel(&hClientCreds, &hClientContext, TRUE, pbSessionID, cbSessionID);\n    if (ss != SEC_E_OK) {\n        printf("Failed to reuse Schannel session: 0x%x\n", ss);\n        return 1;\n    }\n\n    // Clean up\n    FreeCredentialsHandle(&hClientCreds);\n    DeleteSecurityContext(&hClientContext);\n    if (pbSessionID) free(pbSessionID);\n\n    return 0;\n}