#include <stdio.h>\n#include <sys/time.h>\n#include <stdint.h>\n#include <unistd.h>\n\ntypedef struct leaky_bucket {\n    size_t capacity;      // Maximum burst size in bytes\n    size_t tokens;        // Current number of tokens in bytes\n    double rate;          // Token generation rate in bytes per millisecond\n    uint64_t timestamp;   // Last timestamp in milliseconds\n} leaky_bucket;\n\nstatic uint64_t time_now() {\n    struct timeval ts;\n    gettimeofday(&ts, NULL);\n    return (uint64_t)(ts.tv_sec * 1000 + ts.tv_usec / 1000);\n}\n\nstatic int leaky_bucket_init(leaky_bucket *lb, size_t max_burst, double rate) {\n    lb->capacity = max_burst;\n    lb->tokens = max_burst;\n    lb->rate = rate;\n    lb->timestamp = time_now();\n    return 0;\n}\n\nstatic size_t leaky_bucket_consume(leaky_bucket *lb, size_t bytes) {\n    uint64_t now = time_now();\n    size_t elapsed_time = (size_t)(now - lb->timestamp);\n    size_t new_tokens = (size_t)(lb->rate * elapsed_time);\n\n    if (new_tokens > 0) {\n        lb->tokens = (lb->tokens + new_tokens > lb->capacity) ? lb->capacity : lb->tokens + new_tokens;\n        lb->timestamp = now;\n    }\n\n    if (bytes <= lb->tokens) {\n        lb->tokens -= bytes;\n        return 0;\n    } else {\n        return -1;\n    }\n}\n\nint main() {\n    leaky_bucket lb;\n    leaky_bucket_init(&lb, 125000, 900.0 / 8.0);  // 900 kbps to bytes per millisecond\n\n    while (1) {\n        size_t len = read_msg(&msg, file);\n        \n        // Wait until enough tokens are available\n        while (leaky_bucket_consume(&lb, len) != 0) {\n            usleep(1000);  // Sleep for 1 millisecond\n        }\n\n        send_to_net(&msg, len);\n    }\n\n    return 0;\n}