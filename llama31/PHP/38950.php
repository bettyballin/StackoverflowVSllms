function findOptimalPackages($customPackage, $predefinedPackages) {\n    $bestCombination = array();\n    $minIndividualItems = count($customPackage);\n    $minPackages = count($predefinedPackages);\n\n    function recurse($customPackage, $predefinedPackages, $currentCombination, $currentIndividualItems) {\n        global $bestCombination, $minIndividualItems, $minPackages;\n\n        // If we've found a better combination, update the best combination\n        if (count($currentIndividualItems) < $minIndividualItems || (count($currentIndividualItems) == $minIndividualItems && count($currentCombination) < $minPackages)) {\n            $bestCombination = $currentCombination;\n            $minIndividualItems = count($currentIndividualItems);\n            $minPackages = count($currentCombination);\n        }\n\n        // Try adding each predefined package to the current combination\n        foreach ($predefinedPackages as $package) {\n            $newCombination = array_merge($currentCombination, array($package));\n            $newIndividualItems = array_diff($customPackage, array_merge(...$newCombination));\n\n            // Recurse with the updated combination and individual items\n            recurse($customPackage, $predefinedPackages, $newCombination, $newIndividualItems);\n        }\n    }\n\n    recurse($customPackage, $predefinedPackages, array(), $customPackage);\n\n    return $bestCombination;\n}\n\n$optimalPackages = findOptimalPackages($customPackage, $predefinedPackages);\nprint_r($optimalPackages);