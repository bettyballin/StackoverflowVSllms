using System;\nusing System.Runtime.InteropServices;\n\npublic class NetworkStatistics\n{\n    [DllImport("iphlpapi.dll")]\n    private static extern int GetExtendedTcpTable(IntPtr pTcpTable, ref int dwSize, bool bOrder, int dwLocalAddr, int dwRemoteAddr, int dwState, int dwLocalPort, int dwRemotePort);\n\n    [DllImport("iphlpapi.dll")]\n    private static extern int GetExtendedUdpTable(IntPtr pUdpTable, ref int dwSize, bool bOrder, int dwLocalAddr, int dwRemoteAddr, int dwState);\n\n    [DllImport("iphlpapi.dll")]\n    private static extern int GetIfTable(IntPtr pIfTable, ref int dwSize, bool bOrder);\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MIB_TCPROW_OWNER_PID\n    {\n        public int dwState;\n        public int dwLocalAddr;\n        public int dwLocalPort;\n        public int dwRemoteAddr;\n        public int dwRemotePort;\n        public int dwOwningPid;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MIB_TCPTABLE_OWNER_PID\n    {\n        public int dwNumEntries;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]\n        public MIB_TCPROW_OWNER_PID[] table;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MIB_IFROW\n    {\n        public int dwIfIndex;\n        public int dwType;\n        public int dwMtu;\n        public int dwSpeed;\n        public int dwPhysAddrLen;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]\n        public byte[] bPhysAddr;\n        public int dwAdminStatus;\n        public int dwOperStatus;\n        public int dwLastChange;\n        public int dwInOctets;\n        public int dwInUcastPkts;\n        public int dwInNUcastPkts;\n        public int dwInDiscards;\n        public int dwInErrors;\n        public int dwInUnknownProtos;\n        public int dwOutOctets;\n        public int dwOutUcastPkts;\n        public int dwOutNUcastPkts;\n        public int dwOutDiscards;\n        public int dwOutErrors;\n        public int dwOutQLen;\n        public int dwDescrLen;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]\n        public byte[] bDescr;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct MIB_IFTABLE\n    {\n        public int dwNumEntries;\n        [MarshalAs(UnmanagedType.ByValArray, SizeConst = 1)]\n        public MIB_IFROW[] table;\n    }\n\n    public static void GetNetworkStatistics()\n    {\n        int dwSize = 0;\n        IntPtr pTcpTable = IntPtr.Zero;\n        IntPtr pUdpTable = IntPtr.Zero;\n        IntPtr pIfTable = IntPtr.Zero;\n\n        // Get the size of the TCP table\n        int ret = GetExtendedTcpTable(IntPtr.Zero, ref dwSize, true, 0, 0, 0, 0, 0);\n        if (ret != 0) return;\n\n        // Allocate memory for the TCP table\n        pTcpTable = Marshal.AllocHGlobal(dwSize);\n\n        // Get the TCP table\n        ret = GetExtendedTcpTable(pTcpTable, ref dwSize, true, 0, 0, 0, 0, 0);\n        if (ret != 0) return;\n\n        // Get the size of the UDP table\n        ret = GetExtendedUdpTable(IntPtr.Zero, ref dwSize, true, 0, 0, 0);\n        if (ret != 0) return;\n\n        // Allocate memory for the UDP table\n        pUdpTable = Marshal.AllocHGlobal(dwSize);\n\n        // Get the UDP table\n        ret = GetExtendedUdpTable(pUdpTable, ref dwSize, true, 0, 0, 0);\n        if (ret != 0) return;\n\n        // Get the size of the interface table\n        ret = GetIfTable(IntPtr.Zero, ref dwSize, true);\n        if (ret != 0) return;\n\n        // Allocate memory for the interface table\n        pIfTable = Marshal.AllocHGlobal(dwSize);\n\n        // Get the interface table\n        ret = GetIfTable(pIfTable, ref dwSize, true);\n        if (ret != 0) return;\n\n        // Map the interface index from the TCP/UDP table to the interface index from the interface table\n        MIB_TCPTABLE_OWNER_PID tcpTable = (MIB_TCPTABLE_OWNER_PID)Marshal.PtrToStructure(pTcpTable, typeof(MIB_TCPTABLE_OWNER_PID));\n        MIB_IFTABLE ifTable = (MIB_IFTABLE)Marshal.PtrToStructure(pIfTable, typeof(MIB_IFTABLE));\n\n        for (int i = 0; i < tcpTable.dwNumEntries; i++)\n        {\n            MIB_TCPROW_OWNER_PID tcpRow = tcpTable.table[i];\n            for (int j = 0; j < ifTable.dwNumEntries; j++)\n            {\n                MIB_IFROW ifRow = ifTable.table[j];\n                if (tcpRow.dwIfIndex == ifRow.dwIfIndex)\n                {\n                    // Update the interface statistics\n                    ifRow.dwInOctets += tcpRow.dwInOctets;\n                    ifRow.dwOutOctets += tcpRow.dwOutOctets;\n                }\n            }\n        }\n\n        // Free the allocated memory\n        Marshal.FreeHGlobal(pTcpTable);\n        Marshal.FreeHGlobal(pUdpTable);\n        Marshal.FreeHGlobal(pIfTable);\n    }\n}