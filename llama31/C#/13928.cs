using System;\nusing System.Diagnostics;\nusing System.Linq;\n\npublic class ProcessHelper\n{\n    public static void TerminateChildProcesses(int parentProcessId)\n    {\n        // Get all child processes of the parent process\n        var childProcesses = GetChildProcesses(parentProcessId);\n\n        foreach (var childProcess in childProcesses)\n        {\n            try\n            {\n                // Attempt to kill the child process\n                childProcess.Kill();\n                Console.WriteLine($"Terminated process: {childProcess.ProcessName} (ID: {childProcess.Id})");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($"Failed to terminate process: {childProcess.ProcessName} (ID: {childProcess.Id}). Reason: {ex.Message}");\n            }\n        }\n    }\n\n    private static Process[] GetChildProcesses(int parentProcessId)\n    {\n        return Process.GetProcesses()\n            .Where(p => p.Parent().Id == parentProcessId)\n            .ToArray();\n    }\n}\n\npublic static class ProcessExtensions\n{\n    public static Process Parent(this Process process)\n    {\n        var parentPid = GetParentProcessId(process.Id);\n        return Process.GetProcessById(parentPid);\n    }\n\n    private static int GetParentProcessId(int processId)\n    {\n        var query = $"SELECT ParentProcessId FROM Win32_Process WHERE ProcessId = {processId}";\n        var searcher = new System.Management.ManagementObjectSearcher(query);\n        var results = searcher.Get();\n        var queryObj = results.Cast<System.Management.ManagementObject>().FirstOrDefault();\n\n        if (queryObj != null && queryObj["ParentProcessId"] != null)\n        {\n            return Convert.ToInt32(queryObj["ParentProcessId"]);\n        }\n        else\n        {\n            throw new InvalidOperationException($"Could not find parent process for process ID: {processId}");\n        }\n    }\n}