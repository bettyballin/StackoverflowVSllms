using System;\nusing System.Runtime.InteropServices;\n\npublic class MemorySearcher\n{\n    [DllImport("kernel32.dll")]\n    private static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);\n\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool CloseHandle(IntPtr hObject);\n\n    private const int PROCESS_VM_READ = 0x0010;\n\n    public static IntPtr SearchByteArray(int processId, byte[] byteArray)\n    {\n        IntPtr processHandle = OpenProcess(PROCESS_VM_READ, false, processId);\n        if (processHandle == IntPtr.Zero)\n        {\n            throw new Exception("Failed to open process");\n        }\n\n        try\n        {\n            IntPtr baseAddress = IntPtr.Zero;\n            IntPtr bytesRead = IntPtr.Zero;\n            byte[] buffer = new byte[1024];\n\n            while (true)\n            {\n                if (!ReadProcessMemory(processHandle, baseAddress, buffer, buffer.Length, out bytesRead))\n                {\n                    break;\n                }\n\n                for (int i = 0; i < bytesRead.ToInt32(); i++)\n                {\n                    if (buffer[i] == byteArray[0])\n                    {\n                        bool match = true;\n                        for (int j = 1; j < byteArray.Length; j++)\n                        {\n                            if (i + j >= bytesRead.ToInt32() || buffer[i + j] != byteArray[j])\n                            {\n                                match = false;\n                                break;\n                            }\n                        }\n                        if (match)\n                        {\n                            return baseAddress + i;\n                        }\n                    }\n                }\n\n                baseAddress += bytesRead;\n            }\n        }\n        finally\n        {\n            CloseHandle(processHandle);\n        }\n\n        return IntPtr.Zero;\n    }\n}