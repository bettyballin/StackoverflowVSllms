using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class Program\n{\n    [DllImport("shell32.dll", CharSet = CharSet.Auto)]\n    static extern bool ShellExecuteEx(ref SHELLEXECUTEINFO lpExecInfo);\n\n    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]\n    public struct SHELLEXECUTEINFO\n    {\n        public int cbSize;\n        public uint fMask;\n        public IntPtr hwnd;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpVerb;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpFile;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpParameters;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpDirectory;\n        public int nShow;\n        public IntPtr hInstApp;\n        public IntPtr lpIDList;\n        [MarshalAs(UnmanagedType.LPTStr)]\n        public string lpClass;\n        public IntPtr hkeyClass;\n        public uint dwHotKey;\n        public IntPtr hIcon;\n        public IntPtr hProcess;\n    }\n\n    public static bool RunProcessAsAdmin(string filePath)\n    {\n        SHELLEXECUTEINFO info = new SHELLEXECUTEINFO();\n        info.cbSize = Marshal.SizeOf(info);\n        info.fMask = 0x00000040; // SEE_MASK_NOCLOSEPROCESS\n        info.lpVerb = "runas";\n        info.lpFile = filePath;\n        info.nShow = 1; // SW_NORMAL\n\n        return ShellExecuteEx(ref info);\n    }\n\n    public static void Main()\n    {\n        RunProcessAsAdmin("cmd.exe");\n    }\n}