public class BinaryHeap<T> where T : IComparable<T>\n{\n    private T[] heap;\n    private int size;\n\n    public BinaryHeap(int capacity)\n    {\n        heap = new T[capacity];\n    }\n\n    public void Insert(T value)\n    {\n        if (size == heap.Length)\n        {\n            throw new InvalidOperationException("Heap is full");\n        }\n\n        heap[size] = value;\n        BubbleUp(size);\n        size++;\n    }\n\n    public T ExtractMin()\n    {\n        if (size == 0)\n        {\n            throw new InvalidOperationException("Heap is empty");\n        }\n\n        T min = heap[0];\n        heap[0] = heap[size - 1];\n        size--;\n        BubbleDown(0);\n        return min;\n    }\n\n    private void BubbleUp(int index)\n    {\n        while (index > 0)\n        {\n            int parentIndex = (index - 1) / 2;\n            if (heap[index].CompareTo(heap[parentIndex]) < 0)\n            {\n                Swap(index, parentIndex);\n                index = parentIndex;\n            }\n            else\n            {\n                break;\n            }\n        }\n    }\n\n    private void BubbleDown(int index)\n    {\n        while (true)\n        {\n            int leftChildIndex = 2 * index + 1;\n            int rightChildIndex = 2 * index + 2;\n            int smallest = index;\n\n            if (leftChildIndex < size && heap[leftChildIndex].CompareTo(heap[smallest]) < 0)\n            {\n                smallest = leftChildIndex;\n            }\n\n            if (rightChildIndex < size && heap[rightChildIndex].CompareTo(heap[smallest]) < 0)\n            {\n                smallest = rightChildIndex;\n            }\n\n            if (smallest == index)\n            {\n                break;\n            }\n\n            Swap(index, smallest);\n            index = smallest;\n        }\n    }\n\n    private void Swap(int i, int j)\n    {\n        T temp = heap[i];\n        heap[i] = heap[j];\n        heap[j] = temp;\n    }\n}