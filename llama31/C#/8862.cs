public class Huffman16\n{\n    private readonly Node[] _huffmanTree;\n\n    public Huffman16(long[] frequencies)\n    {\n        _huffmanTree = BuildTree(frequencies);\n    }\n\n    public byte[] Encode(byte[] plainData)\n    {\n        if (plainData == null)\n            throw new ArgumentNullException(nameof(plainData));\n\n        var encoded = new byte[plainData.Length * 2];\n        var index = 0;\n\n        for (int i = 0; i < plainData.Length; i += 2)\n        {\n            var symbol = (ushort)((plainData[i] << 8) | plainData[i + 1]);\n            var node = _huffmanTree[symbol];\n\n            while (node != null)\n            {\n                encoded[index++] = (byte)(node.Coded >> 8);\n                node = node.Left;\n            }\n        }\n\n        return encoded.Take(index).ToArray();\n    }\n\n    public byte[] Decode(byte[] encodedData)\n    {\n        if (encodedData == null)\n            throw new ArgumentNullException(nameof(encodedData));\n\n        var decoded = new byte[encodedData.Length * 2];\n        var index = 0;\n\n        var current = _huffmanTree[0];\n\n        for (int i = 0; i < encodedData.Length; i++)\n        {\n            var byteValue = encodedData[i];\n\n            for (int bit = 0; bit < 8; bit++)\n            {\n                var bitValue = (byteValue >> bit) & 1;\n\n                if (bitValue == 0)\n                    current = current.Left;\n                else\n                    current = current.Right;\n\n                if (current.IsLeaf)\n                {\n                    decoded[index++] = (byte)(current.Uncoded1 >> 8);\n                    decoded[index++] = (byte)(current.Uncoded1 & 255);\n                    current = _huffmanTree[0];\n                }\n            }\n        }\n\n        return decoded.Take(index).ToArray();\n    }\n\n    private Node[] BuildTree(long[] frequencies)\n    {\n        var nodes = new Node[frequencies.Length];\n\n        for (int i = 0; i < frequencies.Length; i++)\n        {\n            nodes[i] = new Node\n            {\n                Frequency = frequencies[i],\n                Uncoded1 = (byte)(i >> 8),\n                Uncoded0 = (byte)(i & 255)\n            };\n        }\n\n        Array.Sort(nodes, (a, b) => a.Frequency.CompareTo(b.Frequency));\n\n        while (nodes.Length > 1)\n        {\n            var smallest = nodes[0];\n            var nextSmallest = nodes[1];\n\n            var newNode = new Node\n            {\n                Frequency = smallest.Frequency + nextSmallest.Frequency,\n                Left = smallest,\n                Right = nextSmallest\n            };\n\n            nodes = nodes.Skip(2).Concat(new[] { newNode }).ToArray();\n            Array.Sort(nodes, (a, b) => a.Frequency.CompareTo(b.Frequency));\n        }\n\n        return nodes;\n    }\n\n    private class Node\n    {\n        public long Frequency { get; set; }\n        public byte Uncoded1 { get; set; }\n        public byte Uncoded0 { get; set; }\n        public uint Coded { get; set; }\n        public Node Left { get; set; }\n        public Node Right { get; set; }\n        public bool IsLeaf => Left == null;\n    }\n}