using System;\nusing System.IO;\nusing System.Runtime.InteropServices;\n\npublic class DllArchitectureChecker\n{\n    [DllImport("kernel32.dll")]\n    private static extern bool IsWow64Process(IntPtr hProcess, out bool wow64Process);\n\n    public static bool CheckArchitecture(string directory, string architecture)\n    {\n        foreach (string file in Directory.GetFiles(directory, "*.dll"))\n        {\n            using (var peFile = new PeFile(file))\n            {\n                if (peFile.Is64Bit && architecture != "x64")\n                {\n                    Console.WriteLine($"Error: {Path.GetFileName(file)} is not {architecture}");\n                    return false;\n                }\n                else if (!peFile.Is64Bit && architecture != "x86")\n                {\n                    Console.WriteLine($"Error: {Path.GetFileName(file)} is not {architecture}");\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\npublic class PeFile : IDisposable\n{\n    private IntPtr handle;\n\n    public PeFile(string filePath)\n    {\n        handle = NativeMethods.CreateFile(filePath, NativeMethods.GENERIC_READ, FileShare.Read, IntPtr.Zero, FileMode.Open, 0, IntPtr.Zero);\n        if (handle == IntPtr.Zero)\n        {\n            throw new Win32Exception();\n        }\n    }\n\n    public bool Is64Bit\n    {\n        get\n        {\n            var imageDosHeader = new IMAGE_DOS_HEADER();\n            var bytes = new byte[Marshal.SizeOf(imageDosHeader)];\n            var bytesRead = NativeMethods.ReadFile(handle, bytes, (uint)bytes.Length, out _, IntPtr.Zero);\n            if (bytesRead != bytes.Length)\n            {\n                throw new Win32Exception();\n            }\n            Marshal.Copy(bytes, 0, (IntPtr)(&imageDosHeader), bytes.Length);\n            var offset = imageDosHeader.e_lfanew;\n            var imageNtHeaders = new IMAGE_NT_HEADERS();\n            bytes = new byte[Marshal.SizeOf(imageNtHeaders)];\n            NativeMethods.SetFilePointer(handle, offset, IntPtr.Zero, NativeMethods.FILE_BEGIN);\n            bytesRead = NativeMethods.ReadFile(handle, bytes, (uint)bytes.Length, out _, IntPtr.Zero);\n            if (bytesRead != bytes.Length)\n            {\n                throw new Win32Exception();\n            }\n            Marshal.Copy(bytes, 0, (IntPtr)(&imageNtHeaders), bytes.Length);\n            return imageNtHeaders.Signature == NativeMethods.IMAGE_NT_SIGNATURE && imageNtHeaders.FileHeader.Machine == NativeMethods.IMAGE_FILE_MACHINE_AMD64;\n        }\n    }\n\n    public void Dispose()\n    {\n        if (handle != IntPtr.Zero)\n        {\n            NativeMethods.CloseHandle(handle);\n            handle = IntPtr.Zero;\n        }\n    }\n}\n\ninternal static class NativeMethods\n{\n    internal const uint GENERIC_READ = 0x80000000;\n    internal const uint FILE_BEGIN = 0;\n    internal const ushort IMAGE_NT_SIGNATURE = 0x00005A4D;\n    internal const ushort IMAGE_FILE_MACHINE_AMD64 = 0x8664;\n\n    [DllImport("kernel32.dll")]\n    internal static extern IntPtr CreateFile(string lpFileName, uint dwDesiredAccess, FileShare dwShareMode, IntPtr lpSecurityAttributes, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);\n\n    [DllImport("kernel32.dll")]\n    internal static extern bool ReadFile(IntPtr hFile, byte[] lpBuffer, uint nNumberOfBytesToRead, out uint lpNumberOfBytesRead, IntPtr lpOverlapped);\n\n    [DllImport("kernel32.dll")]\n    internal static extern int SetFilePointer(IntPtr hFile, long lDistanceToMove, IntPtr lpDistanceToMoveHigh, uint dwMoveMethod);\n\n    [DllImport("kernel32.dll")]\n    internal static extern bool CloseHandle(IntPtr hObject);\n}\n\n[StructLayout(LayoutKind.Sequential)]\ninternal struct IMAGE_DOS_HEADER\n{\n    internal ushort e_magic;\n    internal ushort e_cblp;\n    internal ushort e_cp;\n    internal ushort e_crlc;\n    internal ushort e_cparhdr;\n    internal ushort e_minalloc;\n    internal ushort e_maxalloc;\n    internal ushort e_ss;\n    internal ushort e_sp;\n    internal ushort e_csum;\n    internal ushort e_ip;\n    internal ushort e_cs;\n    internal ushort e_lfarlc;\n    internal ushort e_ovno;\n    internal ushort e_res_0;\n    internal ushort e_res_1;\n    internal ushort e_res_2;\n    internal ushort e_res_3;\n    internal ushort e_oemid;\n    internal ushort e_oeminfo;\n    internal ushort e_res2_0;\n    internal ushort e_res2_1;\n    internal ushort e_res2_2;\n    internal ushort e_res2_3;\n    internal ushort e_res2_4;\n    internal ushort e_res2_5;\n    internal ushort e_res2_6;\n    internal ushort e_res2_7;\n    internal ushort e_res2_8;\n    internal ushort e_res2_9;\n    internal int e_lfanew;\n}\n\n[StructLayout(LayoutKind.Sequential)]\ninternal struct IMAGE_NT_HEADERS\n{\n    internal uint Signature;\n    internal IMAGE_FILE_HEADER FileHeader;\n}\n\n[StructLayout(LayoutKind.Sequential)]\ninternal struct IMAGE_FILE_HEADER\n{\n    internal ushort Machine;\n    internal ushort NumberOfSections;\n    internal uint TimeDateStamp;\n    internal uint PointerToSymbolTable;\n    internal uint NumberOfSymbols;\n    internal ushort SizeOfOptionalHeader;\n    internal ushort Characteristics;\n}