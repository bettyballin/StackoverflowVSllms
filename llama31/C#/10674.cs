using System;\n\npublic struct PointF\n{\n    public float X;\n    public float Y;\n}\n\npublic struct Triangle\n{\n    public PointF[] Vertices;\n}\n\npublic struct Circle\n{\n    public PointF Center;\n    public float Radius;\n}\n\npublic class Program\n{\n    public static double AreaOfIntersection(Triangle t, Circle c)\n    {\n        // Find the points of intersection between the circle and the triangle\n        var intersectionPoints = FindIntersectionPoints(t, c);\n\n        // If there are no intersection points, return 0\n        if (intersectionPoints.Length == 0)\n        {\n            return 0;\n        }\n\n        // If the circle contains the triangle, return the area of the triangle\n        if (IsTriangleInsideCircle(t, c))\n        {\n            return CalculateTriangleArea(t);\n        }\n\n        // If the triangle contains the circle, return the area of the circle\n        if (IsCircleInsideTriangle(t, c))\n        {\n            return CalculateCircleArea(c);\n        }\n\n        // Calculate the area of intersection using the intersection points\n        return CalculateIntersectionArea(intersectionPoints, c);\n    }\n\n    private static PointF[] FindIntersectionPoints(Triangle t, Circle c)\n    {\n        var intersectionPoints = new PointF[6]; // 2 points per edge\n        int count = 0;\n\n        for (int i = 0; i < 3; i++)\n        {\n            var edgeStart = t.Vertices[i];\n            var edgeEnd = t.Vertices[(i + 1) % 3];\n\n            var points = FindCircleLineIntersectionPoints(c.Center, c.Radius, edgeStart, edgeEnd);\n\n            foreach (var point in points)\n            {\n                if (IsPointOnEdge(point, edgeStart, edgeEnd))\n                {\n                    intersectionPoints[count++] = point;\n                }\n            }\n        }\n\n        return intersectionPoints.Take(count).ToArray();\n    }\n\n    private static PointF[] FindCircleLineIntersectionPoints(PointF circleCenter, float radius, PointF lineStart, PointF lineEnd)\n    {\n        var dx = lineEnd.X - lineStart.X;\n        var dy = lineEnd.Y - lineStart.Y;\n\n        var a = dx * dx + dy * dy;\n        var b = 2 * (dx * (lineStart.X - circleCenter.X) + dy * (lineStart.Y - circleCenter.Y));\n        var c = (lineStart.X - circleCenter.X) * (lineStart.X - circleCenter.X) + (lineStart.Y - circleCenter.Y) * (lineStart.Y - circleCenter.Y) - radius * radius;\n\n        var d = b * b - 4 * a * c;\n\n        if (d < 0)\n        {\n            return new PointF[0];\n        }\n\n        var sqrtD = (float)Math.Sqrt(d);\n        var t1 = (-b + sqrtD) / (2 * a);\n        var t2 = (-b - sqrtD) / (2 * a);\n\n        var point1 = new PointF { X = lineStart.X + t1 * dx, Y = lineStart.Y + t1 * dy };\n        var point2 = new PointF { X = lineStart.X + t2 * dx, Y = lineStart.Y + t2 * dy };\n\n        return new[] { point1, point2 };\n    }\n\n    private static bool IsPointOnEdge(PointF point, PointF edgeStart, PointF edgeEnd)\n    {\n        return IsPointOnLineSegment(point.X, edgeStart.X, edgeEnd.X) && IsPointOnLineSegment(point.Y, edgeStart.Y, edgeEnd.Y);\n    }\n\n    private static bool IsPointOnLineSegment(float x, float start, float end)\n    {\n        return (x >= start && x <= end) || (x >= end && x <= start);\n    }\n\n    private static bool IsTriangleInsideCircle(Triangle t, Circle c)\n    {\n        return t.Vertices.All(v => Distance(v, c.Center) <= c.Radius);\n    }\n\n    private static bool IsCircleInsideTriangle(Triangle t, Circle c)\n    {\n        var triangleArea = CalculateTriangleArea(t);\n\n        var area1 = CalculateTriangleArea(new Triangle { Vertices = new[] { t.Vertices[0], t.Vertices[1], c.Center } });\n        var area2 = CalculateTriangleArea(new Triangle { Vertices = new[] { t.Vertices[1], t.Vertices[2], c.Center } });\n        var area3 = CalculateTriangleArea(new Triangle { Vertices = new[] { t.Vertices[2], t.Vertices[0], c.Center } });\n\n        return Math.Abs(triangleArea - (area1 + area2 + area3)) < float.Epsilon;\n    }\n\n    private static double CalculateTriangleArea(Triangle t)\n    {\n        var a = Distance(t.Vertices[0], t.Vertices[1]);\n        var b = Distance(t.Vertices[1], t.Vertices[2]);\n        var c = Distance(t.Vertices[2], t.Vertices[0]);\n\n        var s = (a + b + c) / 2;\n\n        return Math.Sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    private static double CalculateCircleArea(Circle c)\n    {\n        return Math.PI * c.Radius * c.Radius;\n    }\n\n    private static double CalculateIntersectionArea(PointF[] intersectionPoints, Circle c)\n    {\n        var area = 0.0;\n\n        for (int i = 0; i < intersectionPoints.Length; i += 2)\n        {\n            var point1 = intersectionPoints[i];\n            var point2 = intersectionPoints[i + 1];\n\n            area += CalculateSectorArea(c.Center, point1, point2, c.Radius);\n        }\n\n        return area;\n    }\n\n    private static double CalculateSectorArea(PointF center, PointF point1, PointF point2, float radius)\n    {\n        var angle = CalculateAngle(center, point1, point2);\n\n        return (angle / 360) * Math.PI * radius * radius;\n    }\n\n    private static float CalculateAngle(PointF center, PointF point1, PointF point2)\n    {\n        var dx1 = point1.X - center.X;\n        var dy1 = point1.Y - center.Y;\n\n        var dx2 = point2.X - center.X;\n        var dy2 = point2.Y - center.Y;\n\n        var dotProduct = dx1 * dx2 + dy1 * dy2;\n\n        var magnitude1 = (float)Math.Sqrt(dx1 * dx1 + dy1 * dy1);\n        var magnitude2 = (float)Math.Sqrt(dx2 * dx2 + dy2 * dy2);\n\n        var angle = (float)Math.Acos(dotProduct / (magnitude1 * magnitude2));\n\n        return angle * 180 / (float)Math.PI;\n    }\n\n    private static float Distance(PointF p1, PointF p2)\n    {\n        return (float)Math.Sqrt((p1.X - p2.X) * (p1.X - p2.X) + (p1.Y - p2.Y) * (p1.Y - p2.Y));\n    }\n}