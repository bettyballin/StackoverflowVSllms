using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    [DllImport("kernel32.dll")]\n    static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct STARTUPINFO\n    {\n        public int cb;\n        public string lpReserved;\n        public string lpDesktop;\n        public string lpTitle;\n        public int dwX;\n        public int dwY;\n        public int dwXSize;\n        public int dwYSize;\n        public int dwXCountChars;\n        public int dwYCountChars;\n        public int dwFillAttribute;\n        public int dwFlags;\n        public short wShowWindow;\n        public short cbReserved2;\n        public IntPtr lpReserved2;\n        public IntPtr hStdInput;\n        public IntPtr hStdOutput;\n        public IntPtr hStdError;\n    }\n\n    [StructLayout(LayoutKind.Sequential)]\n    public struct PROCESS_INFORMATION\n    {\n        public IntPtr hProcess;\n        public IntPtr hThread;\n        public int dwProcessId;\n        public int dwThreadId;\n    }\n\n    static void Main(string[] args)\n    {\n        string fileName = "example.txt";\n        using (FileStream fs = File.Create(fileName))\n        {\n            // Keep the file open for writing\n        }\n\n        STARTUPINFO si = new STARTUPINFO();\n        si.cb = Marshal.SizeOf(si);\n        si.lpReserved2 = IntPtr.Zero;\n        si.bInheritHandles = false;\n\n        PROCESS_INFORMATION pi;\n        CreateProcess(null, "msbuild.exe", IntPtr.Zero, IntPtr.Zero, false, 0, IntPtr.Zero, null, ref si, out pi);\n\n        // Now you should be able to delete the file without getting an IOException\n        File.Delete(fileName);\n    }\n}