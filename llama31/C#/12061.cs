using System;\nusing System.Runtime.InteropServices;\n\npublic class ProcessInfo\n{\n    [DllImport("kernel32.dll")]\n    private static extern bool QueryFullProcessImageName(IntPtr hProcess, uint dwFlags, [Out] StringBuilder lpExeName, ref uint lpdwSize);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool GetCommandLine(IntPtr hProcess, StringBuilder lpCommandLine, ref uint lpdwSize);\n\n    public static string GetProcessInfo(int pid)\n    {\n        IntPtr hProcess = OpenProcess(ProcessAccessFlags.QueryInformation, false, pid);\n        if (hProcess == IntPtr.Zero)\n        {\n            throw new Exception("Failed to open process");\n        }\n\n        try\n        {\n            uint bufferSize = 1024;\n            StringBuilder exeName = new StringBuilder(bufferSize);\n            if (!QueryFullProcessImageName(hProcess, 0, exeName, ref bufferSize))\n            {\n                throw new Exception("Failed to get process image name");\n            }\n\n            bufferSize = 1024;\n            StringBuilder commandLine = new StringBuilder(bufferSize);\n            if (!GetCommandLine(hProcess, commandLine, ref bufferSize))\n            {\n                throw new Exception("Failed to get command line");\n            }\n\n            return $"Working Directory: {exeName.ToString()}\nCommand Line: {commandLine.ToString()}";\n        }\n        finally\n        {\n            CloseHandle(hProcess);\n        }\n    }\n\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr OpenProcess(ProcessAccessFlags dwDesiredAccess, bool bInheritHandle, int dwProcessId);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool CloseHandle(IntPtr hObject);\n\n    [Flags]\n    private enum ProcessAccessFlags : uint\n    {\n        QueryInformation = 0x0400,\n    }\n}