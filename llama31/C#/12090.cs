using System.IO;\n\n// Get the volume path\nstring volumePath = Path.GetPathRoot("C:\\Project\\StorageDirectory\\file.txt");\n\n// Check if the volume supports EFS\nif (!VolumeSupportsEfs(volumePath))\n{\n    Console.WriteLine("The volume does not support EFS");\n}\n\nbool VolumeSupportsEfs(string volumePath)\n{\n    uint volumeFlags = GetVolumeInformation(volumePath);\n    return (volumeFlags & (uint)FileSystemFeatureSupport.EFS) == (uint)FileSystemFeatureSupport.EFS;\n}\n\nuint GetVolumeInformation(string volumePath)\n{\n    uint volumeFlags = 0;\n    uint sectorsPerCluster = 0;\n    uint bytesPerSector = 0;\n    uint freeClusters = 0;\n    uint totalClusters = 0;\n    uint fileSystemNameSize = 0;\n    char[] fileSystemName = new char[256];\n\n    if (GetVolumeInformationW(volumePath, fileSystemName, fileSystemName.Length, out volumeFlags, out sectorsPerCluster, out bytesPerSector, out freeClusters, out totalClusters) == 0)\n    {\n        Marshal.ThrowExceptionForHR(Marshal.GetHRForLastWin32Error());\n    }\n\n    return volumeFlags;\n}\n\n[Flags]\nenum FileSystemFeatureSupport : uint\n{\n    EFS = 0x00000010\n}\n\n[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]\nstatic extern int GetVolumeInformationW(string lpRootPathName, [Out] char[] lpVolumeNameBuffer, uint nVolumeNameSize, out uint lpVolumeSerialNumber, out uint lpMaximumComponentLength, out uint lpFileSystemFlags, out uint lpFileSystemNameSize, [Out] char[] lpFileSystemNameBuffer);