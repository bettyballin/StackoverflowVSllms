using System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Threading;\n\nclass ScalableTcpServer\n{\n    private TcpListener _listener;\n    private readonly BufferPool _bufferPool;\n\n    public ScalableTcpServer(int port)\n    {\n        _listener = new TcpListener(IPAddress.Any, port);\n        _bufferPool = new BufferPool(1024, 1024);\n    }\n\n    public void Start()\n    {\n        _listener.Start();\n        _listener.BeginAcceptTcpClient(AcceptClient, null);\n    }\n\n    private void AcceptClient(IAsyncResult ar)\n    {\n        var client = _listener.EndAcceptTcpClient(ar);\n        _listener.BeginAcceptTcpClient(AcceptClient, null);\n\n        var buffer = _bufferPool.GetBuffer();\n        client.Client.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, ReceiveData, new ReceiveState(client, buffer));\n    }\n\n    private void ReceiveData(IAsyncResult ar)\n    {\n        var state = (ReceiveState)ar.AsyncState;\n        var client = state.Client;\n        var buffer = state.Buffer;\n\n        try\n        {\n            var bytesRead = client.Client.EndReceive(ar);\n            if (bytesRead == 0)\n            {\n                // Client disconnected\n                client.Close();\n                return;\n            }\n\n            // Process incoming data\n            var data = new byte[bytesRead];\n            Array.Copy(buffer, 0, data, 0, bytesRead);\n\n            // Send response back to client if necessary\n            var response = ProcessData(data);\n            if (response != null)\n            {\n                client.Client.BeginSend(response, 0, response.Length, SocketFlags.None, SendData, client);\n            }\n        }\n        catch (SocketException ex)\n        {\n            // Handle socket exception\n            client.Close();\n        }\n        finally\n        {\n            _bufferPool.ReturnBuffer(buffer);\n        }\n    }\n\n    private byte[] ProcessData(byte[] data)\n    {\n        // Process incoming data and return response if necessary\n        return null;\n    }\n\n    private void SendData(IAsyncResult ar)\n    {\n        var client = (TcpClient)ar.AsyncState;\n        try\n        {\n            client.Client.EndSend(ar);\n        }\n        catch (SocketException ex)\n        {\n            // Handle socket exception\n            client.Close();\n        }\n    }\n}\n\nclass BufferPool\n{\n    private readonly int _bufferSize;\n    private readonly int _maxBuffers;\n    private readonly Stack<byte[]> _buffers;\n\n    public BufferPool(int bufferSize, int maxBuffers)\n    {\n        _bufferSize = bufferSize;\n        _maxBuffers = maxBuffers;\n        _buffers = new Stack<byte[]>();\n    }\n\n    public byte[] GetBuffer()\n    {\n        if (_buffers.Count > 0)\n        {\n            return _buffers.Pop();\n        }\n        else\n        {\n            return new byte[_bufferSize];\n        }\n    }\n\n    public void ReturnBuffer(byte[] buffer)\n    {\n        if (_buffers.Count < _maxBuffers)\n        {\n            _buffers.Push(buffer);\n        }\n    }\n}\n\nclass ReceiveState\n{\n    public TcpClient Client { get; set; }\n    public byte[] Buffer { get; set; }\n\n    public ReceiveState(TcpClient client, byte[] buffer)\n    {\n        Client = client;\n        Buffer = buffer;\n    }\n}