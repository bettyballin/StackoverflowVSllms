using System;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n    [DllImport("kernel32", SetLastError = true)]\n    private static extern bool SetDllDirectory(string lpPathName);\n\n    [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]\n    private static extern IntPtr GetProcAddress(IntPtr hModule, string procName);\n\n    [DllImport("kernel32", CharSet = CharSet.Auto, SetLastError = true)]\n    private static extern IntPtr LoadLibrary(string lpFileName);\n\n    [DllImport("kernel32", SetLastError = true)]\n    private static extern bool FreeLibrary(IntPtr hModule);\n\n    public delegate void MyFunctionDelegate();\n\n    public static void Main()\n    {\n        string dllPath = @"C:\Path\To\MyDll.dll";\n        string functionName = "MyFunction";\n\n        IntPtr hModule = LoadLibrary(dllPath);\n        if (hModule == IntPtr.Zero)\n        {\n            int errorCode = Marshal.GetLastWin32Error();\n            throw new Exception($"Failed to load DLL: {errorCode}");\n        }\n\n        IntPtr functionAddress = GetProcAddress(hModule, functionName);\n        if (functionAddress == IntPtr.Zero)\n        {\n            int errorCode = Marshal.GetLastWin32Error();\n            throw new Exception($"Failed to get function address: {errorCode}");\n        }\n\n        MyFunctionDelegate myFunction = (MyFunctionDelegate)Marshal.GetDelegateForFunctionPointer(functionAddress, typeof(MyFunctionDelegate));\n        myFunction();\n\n        FreeLibrary(hModule);\n    }\n}