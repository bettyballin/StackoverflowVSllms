using System;\nusing System.Runtime.InteropServices;\n\nclass DllLoader : MarshalByRefObject\n{\n    [DllImport("kernel32", SetLastError = true)]\n    private static extern bool FreeLibrary(IntPtr hModule);\n\n    public void LoadDll(string path)\n    {\n        IntPtr hModule = NativeMethods.LoadLibrary(path);\n        if (hModule == IntPtr.Zero)\n        {\n            throw new Exception("Failed to load DLL");\n        }\n    }\n\n    public void UnloadDll(IntPtr hModule)\n    {\n        if (!FreeLibrary(hModule))\n        {\n            throw new Exception("Failed to unload DLL");\n        }\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        // Create a new application domain\n        AppDomain domain = AppDomain.CreateDomain("DllDomain");\n\n        // Create an instance of the DllLoader class in the new domain\n        DllLoader loader = (DllLoader)domain.CreateInstanceAndUnwrap(typeof(DllLoader).Assembly.FullName, typeof(DllLoader).FullName);\n\n        // Load the DLL\n        loader.LoadDll("path/to/dll.dll");\n\n        // Do something with the DLL...\n\n        // Unload the DLL\n        loader.UnloadDll(loader.GetHandle());\n\n        // Unload the application domain\n        AppDomain.Unload(domain);\n    }\n}