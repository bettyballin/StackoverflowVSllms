using System;\nusing System.Diagnostics;\nusing System.Runtime.InteropServices;\n\npublic class UnmanagedAppMonitor\n{\n    [DllImport("kernel32.dll")]\n    private static extern IntPtr CreateJobObject(IntPtr securityAttributes, string name);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool AssignProcessToJobObject(IntPtr job, IntPtr process);\n\n    [DllImport("kernel32.dll")]\n    private static extern bool GetExitCodeProcess(IntPtr process, out uint exitCode);\n\n    public void MonitorUnmanagedApp(string appPath)\n    {\n        // Create a new job object\n        IntPtr job = CreateJobObject(IntPtr.Zero, "UnmanagedAppJob");\n\n        // Start the unmanaged C++ application\n        Process process = Process.Start(appPath);\n\n        // Assign the process to the job object\n        AssignProcessToJobObject(job, process.Handle);\n\n        // Monitor the job object for exit events\n        while (true)\n        {\n            uint exitCode;\n            if (GetExitCodeProcess(process.Handle, out exitCode))\n            {\n                if (exitCode != 259) // 259 is the exit code for "still running"\n                {\n                    // The process has terminated or crashed, restart it\n                    process = Process.Start(appPath);\n                    AssignProcessToJobObject(job, process.Handle);\n                }\n            }\n            else\n            {\n                // Handle error\n            }\n\n            // Wait for 1 second before checking again\n            System.Threading.Thread.Sleep(1000);\n        }\n    }\n}