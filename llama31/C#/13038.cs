using System;\nusing System.Collections.Concurrent;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class EventProcessor\n{\n    private readonly ConcurrentQueue<byte[]> _eventQueue = new ConcurrentQueue<byte[]>();\n    private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(1, 1);\n    private readonly int _batchSize = 10; // adjust to your desired batch size\n\n    public void EnqueueEvent(byte[] eventData)\n    {\n        _eventQueue.Enqueue(eventData);\n        if (_eventQueue.Count >= _batchSize || !_receiveAsyncPending)\n        {\n            _semaphore.Release();\n        }\n    }\n\n    private bool _receiveAsyncPending = false;\n\n    public void ReceiveAsyncCallback(byte[] eventData)\n    {\n        // process response messages individually\n        if (/* is response message */)\n        {\n            // process response message\n            return;\n        }\n\n        EnqueueEvent(eventData);\n    }\n\n    public void ProcessEvents()\n    {\n        _semaphore.Wait();\n        try\n        {\n            while (_eventQueue.TryDequeue(out byte[] eventData))\n            {\n                // process event message\n                // copy message buffer into object\n                // raise event\n                // release message buffer back into ring-buffer pool\n            }\n        }\n        finally\n        {\n            _semaphore.Release();\n        }\n    }\n}