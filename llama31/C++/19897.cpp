#include <mutex>\n\n// Global mutex to protect access to the thread handle and shared data\nstd::mutex g_mutex;\n\n// Global thread handle\nHANDLE g_threadHandle = NULL;\n\n// Shared data structure to store the thread's return value\nstruct ThreadResult {\n    int result;\n};\n\n// Function to create the thread\nvoid CreateThread() {\n    // Lock the mutex to ensure exclusive access\n    g_mutex.lock();\n\n    // Create the thread\n    g_threadHandle = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);\n\n    // Unlock the mutex\n    g_mutex.unlock();\n}\n\n// Function to retrieve the thread's return value\nint GetThreadResult() {\n    // Lock the mutex to ensure exclusive access\n    g_mutex.lock();\n\n    // Check if the thread has finished\n    if (WaitForSingleObject(g_threadHandle, 0) == WAIT_OBJECT_0) {\n        // Retrieve the thread's return value\n        ThreadResult* result = (ThreadResult*)GetExitCodeThread(g_threadHandle, NULL);\n        int retValue = result->result;\n\n        // Clean up\n        delete result;\n        CloseHandle(g_threadHandle);\n        g_threadHandle = NULL;\n\n        // Unlock the mutex\n        g_mutex.unlock();\n\n        return retValue;\n    } else {\n        // Unlock the mutex\n        g_mutex.unlock();\n\n        // Return a busy status\n        return DOEFB_BUSY;\n    }\n}\n\n// Thread procedure\nDWORD WINAPI ThreadProc(LPVOID lpParameter) {\n    // Perform the time-consuming operation\n    HeavyFunction::HeavyFunction hf;\n    hf.iiStart = (int)(pEfbData->uParams[0].dw);\n    hf.iiEnd = (int)(pEfbData->uParams[1].dw);\n    int result = hf.iGetPrime();\n\n    // Store the result in a shared data structure\n    ThreadResult* threadResult = new ThreadResult();\n    threadResult->result = result;\n    SetExitCodeThread(threadResult);\n\n    return 0;\n}