#include <iostream>\n#include <sys/mman.h>\n#ifdef _WIN32\n#include <Windows.h>\n#endif\n\ntemplate <typename T>\nclass SecureAllocator : public std::allocator<T> {\npublic:\n    template <typename U>\n    SecureAllocator& operator=(const SecureAllocator<U>&) {\n        return *this;\n    }\n\n    template <typename U>\n    struct rebind {\n        using other = SecureAllocator<U>;\n    };\n\n    T* allocate(size_t n) {\n        size_t allocSize = n * sizeof(T);\n#ifdef _WIN32\n        LPVOID pMem = VirtualAlloc(NULL, allocSize, MEM_COMMIT, PAGE_READWRITE);\n        if (pMem == NULL) {\n            throw std::bad_alloc();\n        }\n        if (!VirtualLock(pMem, allocSize)) {\n            VirtualFree(pMem, 0, MEM_RELEASE);\n            throw std::bad_alloc();\n        }\n#else\n        void* pMem = malloc(allocSize);\n        if (pMem == NULL) {\n            throw std::bad_alloc();\n        }\n        if (mlock(pMem, allocSize) != 0) {\n            free(pMem);\n            throw std::bad_alloc();\n        }\n#endif\n        return reinterpret_cast<T*>(pMem);\n    }\n\n    void deallocate(T* pPtr, size_t n) {\n        if (pPtr == NULL) {\n            return;\n        }\n        size_t allocSize = n * sizeof(T);\n#ifdef _WIN32\n        SecureZeroMemory(pPtr, allocSize);\n        VirtualUnlock(pPtr, allocSize);\n        VirtualFree(pPtr, 0, MEM_RELEASE);\n#else\n        memset(pPtr, 0, allocSize);\n        munlock(pPtr, allocSize);\n        free(pPtr);\n#endif\n    }\n};