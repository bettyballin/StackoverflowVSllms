template <class T>\nNode<T>* List<T>::get_closest(Node<T>* node, int& difference) {\n    if (current == nullptr || head == nullptr || last == nullptr) {\n        // Handle null pointers\n        return nullptr;\n    }\n\n    int curr_to_i = current->index - node->index;\n    int last_to_i = last->index - node->index;\n    Node<T>* closest = (node->index < abs(curr_to_i)) ? head : current;\n    closest = (closest->index < abs(last_to_i)) ? closest : last;\n    difference = closest->index - node->index;\n    return closest;\n}\n\ntemplate <class T>\nbool List<T>::add(T value, int index) {\n    if (index < 0) {\n        // Invalid index\n        return false;\n    } else if (index == last->index + 1) {\n        push(value);\n        return true;\n    } else if (index > 0) {\n        Node<T>* new_n = new Node<T>;\n        new_n->value = value;\n        new_n->index = index;\n        int difference;\n        Node<T>* closest = get_closest(new_n, difference);\n        if (closest == nullptr) {\n            // Handle null pointer\n            return false;\n        }\n\n        if (difference < 0) {\n            for (int i = 0; i < abs(difference); i++) {\n                current = current->previous;\n            }\n        } else if (difference > 0) {\n            for (int i = 0; i < abs(difference); i++) {\n                current = current->next;\n            }\n        }\n\n        new_n->previous = current->previous;\n        new_n->next = current;\n        current->previous->next = new_n;\n        current->previous = new_n;\n\n        // Update indices\n        new_n->index = index;\n        current->index++;\n\n        return true;\n    }\n}