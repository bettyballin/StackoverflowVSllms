#include <stack>\n\nvoid iterativeCheckTile(bool *isWalked, powerNetInfo *powerNet, unsigned long x, unsigned long y, tilemapData *levelMap) {\n    std::stack<std::pair<unsigned long, unsigned long>> tileStack;\n\n    // Push the starting tile onto the stack\n    tileStack.push(std::make_pair(x, y));\n\n    while (!tileStack.empty()) {\n        // Pop the top tile from the stack\n        unsigned long currX = tileStack.top().first;\n        unsigned long currY = tileStack.top().second;\n        tileStack.pop();\n\n        // If the tile is out of bounds or already walked, skip it\n        if (currX < 0 || currY < 0 || currX >= level->mapDimensions[0] || currY >= level->mapDimensions[1] || isWalked[currX + (currY * level->mapDimensions[0])]) {\n            continue;\n        }\n\n        // Mark the tile as walked\n        isWalked[currX + (currY * level->mapDimensions[0])] = true;\n\n        // Check if the tile is conductive and process it\n        if (level->tiles[levelMap->map[currX + (currY * level->mapDimensions[0])]]->flags & TILETYPE_CONDUCTIVE) {\n            findSetPoweredObjects(currX, currY, powerNet);\n\n            // Push adjacent tiles onto the stack\n            tileStack.push(std::make_pair(currX - 1, currY));\n            tileStack.push(std::make_pair(currX + 1, currY));\n            tileStack.push(std::make_pair(currX, currY - 1));\n            tileStack.push(std::make_pair(currX, currY + 1));\n        }\n    }\n}