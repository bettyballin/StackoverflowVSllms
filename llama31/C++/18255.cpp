// Token Translation FSM\nclass TokenFSM {\npublic:\n    // Add a new compressor rule\n    void addRule(const std::vector INPUT_TOKEN>& inputSequence, OUTPUT_TOKEN outputToken) {\n        // Create a new state for the input sequence\n        states_[inputSequence] = outputToken;\n    }\n\n    // Translate an input token stream\n    std::vector OUTPUT_TOKEN> translate(const std::vector INPUT_TOKEN>& inputTokens) {\n        std::vector OUTPUT_TOKEN> outputTokens;\n        State currentState = states_.begin();\n\n        for (const auto& inputToken : inputTokens) {\n            // Find the next state based on the current state and input token\n            auto nextState = findNextState(currentState, inputToken);\n\n            if (nextState != states_.end()) {\n                // Apply the transformation associated with the next state\n                outputTokens.push_back(nextState->second);\n                currentState = nextState;\n            }\n        }\n\n        return outputTokens;\n    }\n\nprivate:\n    // State map: input sequence -> output token\n    std::map std::vector INPUT_TOKEN>, OUTPUT_TOKEN> states_;\n\n    // Find the next state based on the current state and input token\n    State findNextState(State currentState, INPUT_TOKEN inputToken) {\n        // Iterate through the states to find a match\n        for (auto it = states_.begin(); it != states_.end(); ++it) {\n            if (it->first.size() > currentState->first.size() &&\n                std::equal(it->first.begin(), it->first.end(), currentState->first.begin()) &&\n                it->first.back() == inputToken) {\n                return it;\n            }\n        }\n        return states_.end(); // No matching state found\n    }\n};