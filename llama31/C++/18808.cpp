template <typename T>\nclass atomic {\npublic:\n    atomic() : value_(0) {}\n\n    atomic(T value) : value_(value) {}\n\n    T load(std::memory_order order = std::memory_order_seq_cst) const {\n        return __atomic_load_n(&value_, order);\n    }\n\n    void store(T value, std::memory_order order = std::memory_order_seq_cst) {\n        __atomic_store_n(&value_, value, order);\n    }\n\n    T exchange(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_exchange_n(&value_, value, order);\n    }\n\n    bool compare_exchange_weak(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_compare_exchange_n(&value_, &expected, desired, false, order, order);\n    }\n\n    bool compare_exchange_strong(T& expected, T desired, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_compare_exchange_n(&value_, &expected, desired, true, order, order);\n    }\n\n    T fetch_add(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_fetch_add(&value_, value, order);\n    }\n\n    T fetch_sub(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_fetch_sub(&value_, value, order);\n    }\n\n    T fetch_and(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_fetch_and(&value_, value, order);\n    }\n\n    T fetch_or(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_fetch_or(&value_, value, order);\n    }\n\n    T fetch_xor(T value, std::memory_order order = std::memory_order_seq_cst) {\n        return __atomic_fetch_xor(&value_, value, order);\n    }\n\nprivate:\n    T value_;\n};