#include <Windows.h>\n#include <iostream>\n#include <string>\n\nint main() {\n    // Define the command to execute\n    std::string command = "your_command.exe"; // Replace with your command\n\n    // Define handles for the process and its output\n    HANDLE hProcess, hStdOut, hStdErr;\n    hStdOut = CreatePipe(NULL, NULL, NULL, 0);\n    hStdErr = CreatePipe(NULL, NULL, NULL, 0);\n\n    // Create the process\n    STARTUPINFO si = { sizeof(STARTUPINFO) };\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n\n    si.dwFlags = STARTF_USESTDHANDLES;\n    si.hStdOutput = hStdOut;\n    si.hStdError = hStdErr;\n\n    // Launch the process\n    if (!CreateProcess(NULL, (LPSTR)command.c_str(), NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi)) {\n        std::cerr << "Failed to create process." << std::endl;\n        return 1;\n    }\n\n    // Close handles we don't need\n    CloseHandle(pi.hThread);\n    CloseHandle(pi.hProcess);\n\n    // Read from the stdout and stderr pipes\n    char buffer[1024];\n    DWORD bytesRead;\n\n    std::string output, error;\n\n    // Read stdout\n    while (ReadFile(hStdOut, buffer, 1024, &bytesRead, NULL)) {\n        output.append(buffer, bytesRead);\n    }\n\n    // Read stderr\n    while (ReadFile(hStdErr, buffer, 1024, &bytesRead, NULL)) {\n        error.append(buffer, bytesRead);\n    }\n\n    // Close the remaining handles\n    CloseHandle(hStdOut);\n    CloseHandle(hStdErr);\n\n    // Process the output and error strings as needed\n    std::cout << "Output: " << output << std::endl;\n    std::cout << "Error: " << error << std::endl;\n\n    return 0;\n}