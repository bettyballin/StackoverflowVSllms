#include <Windows.h>\n#include <WinSock2.h>\n#include <Ws2tcpip.h>\n\n#pragma comment(lib, "ws2_32.lib")\n\nint GetSocketOwningProcessId(SOCKET socket) {\n    MIB_TCPTABLE_OWNER_PID* tcpTable;\n    DWORD tcpTableSize = 0;\n    DWORD dwRetVal = 0;\n\n    int i;\n\n    // Get the size of the TCP table\n    dwRetVal = GetExtendedTcpTable(NULL, &tcpTableSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);\n    if (dwRetVal != ERROR_INSUFFICIENT_BUFFER) {\n        return -1;\n    }\n\n    // Allocate memory for the TCP table\n    tcpTable = (MIB_TCPTABLE_OWNER_PID*)malloc(tcpTableSize);\n    if (tcpTable == NULL) {\n        return -1;\n    }\n\n    // Get the TCP table\n    dwRetVal = GetExtendedTcpTable(tcpTable, &tcpTableSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);\n    if (dwRetVal != NO_ERROR) {\n        free(tcpTable);\n        return -1;\n    }\n\n    // Iterate over the TCP connections and find the one that matches the socket\n    for (i = 0; i < (int)tcpTable->dwNumEntries; i++) {\n        MIB_TCPROW_OWNER_PID* row = &tcpTable->table[i];\n        if (row->dwLocalPort == ntohs(socket)) {\n            // Return the PID of the process that owns the socket\n            int pid = row->dwOwningPid;\n            free(tcpTable);\n            return pid;\n        }\n    }\n\n    // If no matching connection is found, return -1\n    free(tcpTable);\n    return -1;\n}