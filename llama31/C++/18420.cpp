// sprite.h (base class definition)\nnamespace base {\nclass Sprite : public RefCounted {\npublic:\n    virtual ~Sprite() {}\n    virtual base::Texture* GetTexture() = 0;\n    // ...\n};\n}\n\n// sprite_factory.h (factory method definition)\nextern "C" __declspec(dllexport) base::Sprite* CreateSpriteInstance();\n\n// sprite_implementation.cpp (DLL implementation)\n#include "sprite.h"\n#include "sprite_implementation.h"\n\nclass SpriteImplementation : public base::Sprite {\npublic:\n    SpriteImplementation() {}\n    ~SpriteImplementation() {}\n\n    base::Texture* GetTexture() override {\n        // implementation\n    }\n};\n\nbase::Sprite* CreateSpriteInstance() {\n    return new SpriteImplementation();\n}\n\n// main.cpp (executable code)\n#include "sprite.h"\n#include <Windows.h>\n\nint main() {\n    // Load the DLL\n    HMODULE hModule = LoadLibraryA("sprite_implementation.dll");\n    if (!hModule) {\n        // error handling\n    }\n\n    // Retrieve the factory method\n    base::Sprite* (*CreateSpriteInstance)() = reinterpret_cast<base::Sprite* (*)()>(GetProcAddress(hModule, "CreateSpriteInstance"));\n    if (!CreateSpriteInstance) {\n        // error handling\n    }\n\n    // Create an instance of the class\n    base::Sprite* sprite = CreateSpriteInstance();\n\n    // Use the instance\n    sprite->GetTexture();\n\n    // Release the instance\n    sprite->Release();\n\n    // Unload the DLL\n    FreeLibrary(hModule);\n    return 0;\n}