// Define the driver's name and description\n#define DRIVER_NAME "SecureDrive"\n#define DRIVER_DESCRIPTION "Blocks access to protected drives"\n\n// Define the protected drives (e.g., by device name or GUID)\nconst WCHAR* protectedDrives[] = { L"\\Device\\HarddiskVolume2" };\n\n// Driver entry point\nNTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {\n    // Register the driver to receive IRPs for device access\n    DriverObject->DriverUnload = SecureDriveUnload;\n    DriverObject->MajorFunction[IRP_MJ_CREATE] = SecureDriveCreate;\n    DriverObject->MajorFunction[IRP_MJ_READ] = SecureDriveRead;\n    DriverObject->MajorFunction[IRP_MJ_WRITE] = SecureDriveWrite;\n\n    return STATUS_SUCCESS;\n}\n\n// Handle create IRPs (e.g., when Windows attempts to access the drive)\nNTSTATUS SecureDriveCreate(PDEVICE_OBJECT DeviceObject, PIRP Irp) {\n    // Check if the accessed drive is protected\n    if (IsProtectedDrive(DeviceObject)) {\n        // Return an error to block access\n        Irp->IoStatus.Status = STATUS_ACCESS_DENIED;\n        Irp->IoStatus.Information = 0;\n        return STATUS_ACCESS_DENIED;\n    }\n\n    // Allow access to non-protected drives\n    return IoCallDriver(DeviceObject, Irp);\n}\n\n// Helper function to check if a drive is protected\nBOOLEAN IsProtectedDrive(PDEVICE_OBJECT DeviceObject) {\n    // Iterate over the protected drives array\n    for (int i = 0; i < ARRAYSIZE(protectedDrives); i++) {\n        if (wcscmp(DeviceObject->Name.Buffer, protectedDrives[i]) == 0) {\n            return TRUE; // Drive is protected\n        }\n    }\n    return FALSE; // Drive is not protected\n}