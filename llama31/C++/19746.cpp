#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct EditOperation {\n    int type; // 0: substitution, 1: insertion, 2: deletion\n    int position;\n};\n\nint levenshtein(const string &s1, const string &s2, vector<EditOperation> &editOperations)\n{\n    string::size_type N1 = s1.length();\n    string::size_type N2 = s2.length();\n    string::size_type i, j;\n    vector<int> T(N2+1);\n    vector<EditOperation> tempEditOperations(N2+1);\n\n    for (i = 0; i <= N2; i++) {\n        T[i] = i;\n        tempEditOperations[i].type = 1; // insertion\n        tempEditOperations[i].position = i;\n    }\n\n    for (i = 0; i < N1; i++) {\n        T[0] = i+1;\n        tempEditOperations[0].type = 2; // deletion\n        tempEditOperations[0].position = i;\n        int corner = i;\n        for (j = 0; j < N2; j++) {\n            int upper = T[j+1];\n            if (s1[i] == s2[j]) {\n                T[j+1] = corner;\n                tempEditOperations[j+1] = tempEditOperations[j];\n            } else {\n                T[j+1] = min(T[j], min(upper, corner)) + 1;\n                if (T[j+1] == T[j] + 1) {\n                    tempEditOperations[j+1].type = 1; // insertion\n                    tempEditOperations[j+1].position = j;\n                } else if (T[j+1] == upper + 1) {\n                    tempEditOperations[j+1].type = 2; // deletion\n                    tempEditOperations[j+1].position = i;\n                } else {\n                    tempEditOperations[j+1].type = 0; // substitution\n                    tempEditOperations[j+1].position = j;\n                }\n            }\n            corner = upper;\n        }\n    }\n    editOperations = tempEditOperations;\n    return T[N2];\n}