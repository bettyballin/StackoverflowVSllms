class MemoryPool {\npublic:\n    MemoryPool(void* memory, size_t size) : memory_(memory), size_(size), freeList_(nullptr) {}\n\n    std::pair<void*, void*> allocate(size_t allocationSize) {\n        if (freeList_ != nullptr) {\n            // Try to allocate from the free list\n            for (auto current = freeList_; current != nullptr; current = current->next) {\n                if (current->size >= allocationSize) {\n                    // Found a suitable block, split it if necessary\n                    if (current->size > allocationSize) {\n                        auto newBlock = reinterpret_cast<FreeBlock*>(reinterpret_cast<char*>(current) + allocationSize);\n                        newBlock->size = current->size - allocationSize;\n                        newBlock->next = current->next;\n                        freeList_ = newBlock;\n                    } else {\n                        freeList_ = current->next;\n                    }\n                    return std::make_pair(reinterpret_cast<void*>(current), reinterpret_cast<void*>(reinterpret_cast<char*>(current) + allocationSize));\n                }\n            }\n        }\n\n        // No suitable block in the free list, try to allocate from the memory pool\n        if (size_ >= allocationSize) {\n            auto allocationStart = memory_;\n            size_ -= allocationSize;\n            memory_ = reinterpret_cast<void*>(reinterpret_cast<char*>(memory_) + allocationSize);\n            return std::make_pair(allocationStart, reinterpret_cast<void*>(reinterpret_cast<char*>(allocationStart) + allocationSize));\n        }\n\n        // Out of memory\n        return std::make_pair(nullptr, nullptr);\n    }\n\n    void deallocate(void* memory, size_t size) {\n        auto block = reinterpret_cast<FreeBlock*>(memory);\n        block->size = size;\n        block->next = freeList_;\n        freeList_ = block;\n    }\n\nprivate:\n    struct FreeBlock {\n        size_t size;\n        FreeBlock* next;\n    };\n\n    void* memory_;\n    size_t size_;\n    FreeBlock* freeList_;\n};