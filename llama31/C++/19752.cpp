class RowHeaderProxyModel : public QAbstractProxyModel\n{\n    Q_OBJECT\npublic:\n    explicit RowHeaderProxyModel(QObject *parent = nullptr) : QAbstractProxyModel(parent) {}\n\n    void setSourceModel(QAbstractItemModel *sourceModel) override\n    {\n        QAbstractProxyModel::setSourceModel(sourceModel);\n        connect(sourceModel, &QAbstractItemModel::headerDataChanged, this, &RowHeaderProxyModel::updateRowHeaders);\n    }\n\n    int rowCount(const QModelIndex &parent = QModelIndex()) const override\n    {\n        return sourceModel()->rowCount(parent);\n    }\n\n    int columnCount(const QModelIndex &parent = QModelIndex()) const override\n    {\n        return 1; // We only need one column for the row headers\n    }\n\n    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const override\n    {\n        return createIndex(row, column, nullptr);\n    }\n\n    QModelIndex parent(const QModelIndex &index) const override\n    {\n        return QModelIndex();\n    }\n\n    QVariant data(const QModelIndex &index, int role) const override\n    {\n        if (index.column() == 0) {\n            return sourceModel()->headerData(index.row(), Qt::Vertical, role);\n        }\n        return QVariant();\n    }\n\nprivate slots:\n    void updateRowHeaders(Qt::Orientation orientation, int first, int last)\n    {\n        if (orientation == Qt::Vertical) {\n            emit dataChanged(index(first, 0), index(last, 0));\n        }\n    }\n};