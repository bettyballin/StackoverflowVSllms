template <typename T>\nclass Memoizer {\npublic:\n    T memoize(std::function<T(std::vector<void*>)> func, std::vector<void*> args) {\n        auto it = cache.find(args);\n        if (it != cache.end()) {\n            return it->second;\n        }\n\n        T result = func(args);\n        cache[args] = result;\n        return result;\n    }\n\nprivate:\n    std::unordered_map<std::vector<void*>, T> cache;\n};\n\nclass MyClass {\npublic:\n    std::string computeStuff(int arg1, int arg2) {\n        Memoizer<std::string> memoizer;\n        return memoizer.memoize([&](std::vector<void*> args) {\n            // Do lots of CPU-intensive computation here\n            return "Result for " + std::to_string(*reinterpret_cast<int*>(args[0])) + " and " + std::to_string(*reinterpret_cast<int*>(args[1]));\n        }, {&arg1, &arg2});\n    }\n};