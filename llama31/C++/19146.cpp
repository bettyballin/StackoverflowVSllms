template <typename T>\nclass Proxy {\npublic:\n    Proxy(T* obj) : obj_(obj) {}\n\n    template <typename... Args>\n    auto operator()(Args&&... args) -> decltype(obj_->func(std::forward<Args>(args)...)) {\n        // Call the desired function before delegating to the original function\n        obj_->alwaysRun();\n        return obj_->func(std::forward<Args>(args)...);\n    }\n\nprivate:\n    T* obj_;\n};\n\nclass MyClass {\npublic:\n    void alwaysRun() { std::cout << "Always run!" << std::endl; }\n\n    void func1() { std::cout << "Func 1" << std::endl; }\n    void func2() { std::cout << "Func 2" << std::endl; }\n};\n\nint main() {\n    MyClass obj;\n    Proxy<MyClass> proxy(&obj);\n\n    proxy.func1(); // Always run! Func 1\n    proxy.func2(); // Always run! Func 2\n\n    return 0;\n}