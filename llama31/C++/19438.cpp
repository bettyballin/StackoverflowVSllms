char buffer[BUFFER_SIZE];\nstringstream readStream;\nbool readData = true;\n\nwhile (readData) {\n    cout << "Receiving chunk... ";\n\n    bzero(buffer, BUFFER_SIZE);\n    int readResult = read(socketFileDescriptor, buffer, BUFFER_SIZE);\n\n    if (readResult < 0) {\n        THROW_VIMRID_EX("Could not read from socket.");\n    } else if (readResult == 0) {\n        // Peer has closed the connection\n        break;\n    }\n\n    // Concatenate the received data to the existing data\n    readStream << string(buffer, readResult); // Use string constructor to avoid buffer overflows\n\n    // Continue reading while end is not found\n    readData = readStream.str().find("end;") == string::npos;\n\n    cout << "Done (length: " << readStream.str().length() << ")" << endl;\n\n    // Add a timeout to prevent endless loops\n    struct timeval timeout;\n    timeout.tv_sec = 10; // 10-second timeout\n    timeout.tv_usec = 0;\n    setsockopt(socketFileDescriptor, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));\n}