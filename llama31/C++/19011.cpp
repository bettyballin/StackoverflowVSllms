#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int to;\n    double weight;\n};\n\nstruct Node {\n    int id;\n    double distance;\n    bool visited;\n    vector<Edge> edges;\n};\n\nstruct CompareNodes {\n    bool operator()(const Node* a, const Node* b) {\n        return a->distance > b->distance;\n    }\n};\n\nvoid dijkstra(vector<Node>& nodes, int start) {\n    priority_queue<Node*, vector<Node*>, CompareNodes> queue;\n\n    for (Node& node : nodes) {\n        node.distance = numeric_limits<double>::infinity();\n        node.visited = false;\n    }\n\n    nodes[start].distance = 0;\n    queue.push(&nodes[start]);\n\n    while (!queue.empty()) {\n        Node* node = queue.top();\n        queue.pop();\n\n        if (node->visited) continue;\n\n        node->visited = true;\n\n        for (Edge& edge : node->edges) {\n            Node& neighbor = nodes[edge.to];\n            double newDistance = node->distance + edge.weight;\n\n            if (newDistance < neighbor.distance) {\n                neighbor.distance = newDistance;\n                queue.push(&neighbor);\n            }\n        }\n    }\n}\n\nint main() {\n    // Create nodes and edges\n    vector<Node> nodes = {\n        {0, 0, false, {{1, 2}, {2, 4}}},\n        {1, 0, false, {{2, 1}, {3, 7}}},\n        {2, 0, false, {{3, 3}}},\n        {3, 0, false, {}}\n    };\n\n    dijkstra(nodes, 0);\n\n    // Print distances\n    for (Node& node : nodes) {\n        cout << "Node " << node.id << ": " << node.distance << endl;\n    }\n\n    return 0;\n}