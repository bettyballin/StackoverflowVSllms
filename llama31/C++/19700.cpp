#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <functional>\n\n// Token types\nenum class Token {\n    Number,\n    Plus,\n    Minus,\n    Multiply,\n    Divide,\n    LeftParen,\n    RightParen,\n    Identifier\n};\n\n// Lexer\nclass Lexer {\npublic:\n    Lexer(const std::string& input) : input_(input) {}\n\n    Token nextToken() {\n        // Simplified tokenization for demonstration purposes\n        if (isdigit(input_[pos_])) {\n            // Number\n            while (pos_ < input_.size() && isdigit(input_[pos_])) {\n                pos_++;\n            }\n            return Token::Number;\n        } else if (input_[pos_] == '+') {\n            pos_++;\n            return Token::Plus;\n        } else if (input_[pos_] == '-') {\n            pos_++;\n            return Token::Minus;\n        } else if (input_[pos_] == '*') {\n            pos_++;\n            return Token::Multiply;\n        } else if (input_[pos_] == '/') {\n            pos_++;\n            return Token::Divide;\n        } else if (input_[pos_] == '(') {\n            pos_++;\n            return Token::LeftParen;\n        } else if (input_[pos_] == ')') {\n            pos_++;\n            return Token::RightParen;\n        } else if (isalpha(input_[pos_])) {\n            // Identifier\n            while (pos_ < input_.size() && isalnum(input_[pos_])) {\n                pos_++;\n            }\n            return Token::Identifier;\n        }\n\n        // Error handling omitted for brevity\n    }\n\n    std::string getTokenValue() const {\n        return input_.substr(pos_ - 1, 1);\n    }\n\nprivate:\n    const std::string& input_;\n    size_t pos_ = 0;\n};\n\n// Parser\nclass Parser {\npublic:\n    Parser(Lexer& lexer) : lexer_(lexer) {}\n\n    double parse() {\n        return parseExpression();\n    }\n\nprivate:\n    double parseExpression() {\n        double value = parseTerm();\n\n        while (true) {\n            Token token = lexer_.nextToken();\n            if (token == Token::Plus) {\n                value += parseTerm();\n            } else if (token == Token::Minus) {\n                value -= parseTerm();\n            } else {\n                break;\n            }\n        }\n\n        return value;\n    }\n\n    double parseTerm() {\n        double value = parseFactor();\n\n        while (true) {\n            Token token = lexer_.nextToken();\n            if (token == Token::Multiply) {\n                value *= parseFactor();\n            } else if (token == Token::Divide) {\n                value /= parseFactor();\n            } else {\n                break;\n            }\n        }\n\n        return value;\n    }\n\n    double parseFactor() {\n        Token token = lexer_.nextToken();\n        if (token == Token::Number) {\n            return std::stod(lexer_.getTokenValue());\n        } else if (token == Token::LeftParen) {\n            double value = parseExpression();\n            lexer_.nextToken(); // Consume ')'\n            return value;\n        } else if (token == Token::Identifier) {\n            // Call a function in the underlying environment\n            // Simplified for demonstration purposes\n            std::string functionName = lexer_.getTokenValue();\n            // Overload the function call here\n            // For example:\n            if (functionName == "sqrt") {\n                return sqrt(parseExpression());\n            }\n            // ...\n        }\n\n        // Error handling omitted for brevity\n    }\n\n    Lexer& lexer_;\n};\n\nint main() {\n    std::string input = "2 + 3 * 4";\n    Lexer lexer(input);\n    Parser parser(lexer);\n    double result = parser.parse();\n    std::cout << "Result: " << result << std::endl;\n    return 0;\n}