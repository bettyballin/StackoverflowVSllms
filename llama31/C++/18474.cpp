#include <Windows.h>\n#include <string>\n#include <vector>\n\nstd::string ExecuteProcess(const std::string& command) {\n    std::string output;\n    HANDLE hPipeRead, hPipeWrite;\n    SECURITY_ATTRIBUTES saAttr = {sizeof(SECURITY_ATTRIBUTES)};\n    saAttr.bInheritHandle = TRUE;\n    saAttr.lpSecurityDescriptor = NULL;\n\n    // Create a pipe for the child process's output\n    if (!CreatePipe(&hPipeRead, &hPipeWrite, &saAttr, 0)) {\n        return "Error creating pipe";\n    }\n\n    STARTUPINFO si = {sizeof(STARTUPINFO)};\n    si.dwFlags = STARTF_USESTDHANDLES;\n    si.hStdOutput = hPipeWrite;\n    si.hStdError = hPipeWrite;\n\n    PROCESS_INFORMATION pi = {0};\n    if (!CreateProcess(NULL, (LPSTR)command.c_str(), NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi)) {\n        CloseHandle(hPipeRead);\n        CloseHandle(hPipeWrite);\n        return "Error creating process";\n    }\n\n    // Wait for the child process to finish\n    WaitForSingleObject(pi.hProcess, INFINITE);\n\n    // Read the output from the pipe\n    char buffer[1024];\n    DWORD bytesRead = 0;\n    while (ReadFile(hPipeRead, buffer, 1024, &bytesRead, NULL)) {\n        output.append(buffer, bytesRead);\n    }\n\n    CloseHandle(hPipeRead);\n    CloseHandle(hPipeWrite);\n    CloseHandle(pi.hProcess);\n    CloseHandle(pi.hThread);\n\n    return output;\n}