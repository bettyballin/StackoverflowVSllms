import random\n\ndef generate_solved_state(tiles):\n    # Create a solved Mahjong board\n    solved_state = []\n    for tile in tiles:\n        solved_state.append((tile, tile))  # pair each tile\n    return solved_state\n\ndef shuffle_tiles(solved_state):\n    # Shuffle the tiles randomly\n    shuffled_state = solved_state[:]\n    random.shuffle(shuffled_state)\n    return shuffled_state\n\ndef validate_shuffled_state(shuffled_state, solved_state):\n    # Validate that the shuffled state has a path to the solved state\n    queue = [(shuffled_state, [])]  # BFS queue\n    while queue:\n        state, moves = queue.pop(0)\n        if state == solved_state:\n            return True  # found a valid path\n        for i in range(len(state)):\n            for j in range(i + 1, len(state)):\n                # Try swapping tiles i and j\n                new_state = state[:]\n                new_state[i], new_state[j] = new_state[j], new_state[i]\n                queue.append((new_state, moves + [(i, j)]))\n    return False  # no valid path found\n\ndef adjust_shuffled_state(shuffled_state, solved_state):\n    # Adjust the shuffled state to create a solvable state\n    queue = [(shuffled_state, [])]  # BFS queue\n    while queue:\n        state, moves = queue.pop(0)\n        if validate_shuffled_state(state, solved_state):\n            return state  # found a solvable state\n        for i in range(len(state)):\n            for j in range(i + 1, len(state)):\n                # Try swapping tiles i and j\n                new_state = state[:]\n                new_state[i], new_state[j] = new_state[j], new_state[i]\n                queue.append((new_state, moves + [(i, j)]))\n\n# Example usage\ntiles = ['A', 'B', 'C', 'D', 'E', 'F']  # 6 tiles\nsolved_state = generate_solved_state(tiles)\nshuffled_state = shuffle_tiles(solved_state)\nif not validate_shuffled_state(shuffled_state, solved_state):\n    shuffled_state = adjust_shuffled_state(shuffled_state, solved_state)\nprint(shuffled_state)  # a solvable shuffled state