from itertools import chain, combinations\n\ndef powerset(s):\n    return list(chain.from_iterable(combinations(s, r) for r in range(len(s)+1)))\n\ndef count_combinations(lists):\n    # Create a graph where each pair is a node, and two nodes are connected if the corresponding pairs share an item\n    graph = {}\n    for i, lst in enumerate(lists):\n        for pair in lst:\n            items = [int(x) for x in str(pair)]\n            graph[(i, pair)] = set()\n            for j, other_lst in enumerate(lists):\n                if i != j:\n                    for other_pair in other_lst:\n                        other_items = [int(x) for x in str(other_pair)]\n                        if set(items) & set(other_items):  # If the pairs share an item\n                            graph[(i, pair)].add((j, other_pair))\n\n    # Count the number of independent sets in the graph\n    independent_sets = []\n    for nodes in powerset(graph.keys()):\n        if all(graph[node].isdisjoint(nodes) for node in nodes):\n            independent_sets.append(nodes)\n\n    # Count the number of combinations where each list has exactly one pair\n    count = 0\n    for independent_set in independent_sets:\n        lists_covered = set(i for i, _ in independent_set)\n        if len(lists_covered) == len(lists):\n            count += 1\n\n    return count\n\nlists = [{12,13,14,23,24}, {14,15,25}, {16,17,25,26,36}]\nprint(count_combinations(lists))