class StreamingQuantile:\n    def __init__(self, q=0.5):\n        self.q = q\n        self.estimates = [(0, 0)]\n\n    def update(self, value):\n        if value < self.estimates[0][0]:\n            self.estimates.insert(0, (value, 1))\n        elif value > self.estimates[-1][0]:\n            self.estimates.append((value, 1))\n        else:\n            for i, (v, c) in enumerate(self.estimates):\n                if v <= value <= self.estimates[i + 1][0]:\n                    self.estimates[i] = (v, c + 1)\n                    break\n\n        # Merge and split estimates periodically\n        if len(self.estimates) > 100:\n            self._merge_and_split()\n\n    def _merge_and_split(self):\n        # Simplified merge and split logic for brevity\n        new_estimates = []\n        for i in range(len(self.estimates) - 1):\n            v1, c1 = self.estimates[i]\n            v2, c2 = self.estimates[i + 1]\n            new_estimates.append(((c1 * v1 + c2 * v2) / (c1 + c2), c1 + c2))\n        self.estimates = new_estimates\n\n    def get_estimate(self):\n        return self.estimates[int(self.q * len(self.estimates))][0]\n\nmedian_estimator = StreamingQuantile()\nfor value in your_data_stream:\n    median_estimator.update(value)\n    print(median_estimator.get_estimate())