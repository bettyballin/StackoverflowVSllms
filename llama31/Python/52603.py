def sieve_of_atkin(limit):\n    primes = []\n    sieve = [False] * (limit + 1)\n    for x in range(1, int(limit**0.5) + 1):\n        for y in range(1, int(limit**0.5) + 1):\n            n = 4*x**2 + y**2\n            if n <= limit and (n % 12 == 1 or n % 12 == 5):\n                sieve[n] = not sieve[n]\n            n = 3*x**2 + y**2\n            if n <= limit and n % 12 == 7:\n                sieve[n] = not sieve[n]\n            n = 3*x**2 - y**2\n            if x > y and n <= limit and n % 12 == 11:\n                sieve[n] = not sieve[n]\n    for x in range(5, int(limit**0.5)):\n        if sieve[x]:\n            for y in range(x**2, limit + 1, x**2):\n                sieve[y] = False\n    return [2, 3] + [x for x in range(5, limit) if sieve[x]]\n\ndef prime_factorization(n, primes):\n    factors = {}\n    for prime in primes:\n        if prime * prime > n:\n            break\n        while n % prime == 0:\n            factors[prime] = factors.get(prime, 0) + 1\n            n //= prime\n    if n > 1:\n        factors[n] = factors.get(n, 0) + 1\n    return factors\n\ndef count_divisors(n):\n    primes = sieve_of_atkin(int(n**0.5) + 1)\n    factors = prime_factorization(n, primes)\n    count = 1\n    for exponent in factors.values():\n        count *= (exponent + 1)\n    return count\n\n# Example usage\nn = 100\nprint(count_divisors(n))