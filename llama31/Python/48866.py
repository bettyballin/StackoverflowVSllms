import numpy as np\n\ndef generate_contingency_table(row_sums, col_sums, max_iter=1000):\n    # Initialize the contingency table with a uniform distribution\n    contingency_table = np.outer(row_sums, col_sums) / np.sum(row_sums)\n    \n    # Iteratively adjust the table to ensure randomness and adherence to sums\n    for _ in range(max_iter):\n        for i in range(len(row_sums)):\n            for j in range(len(col_sums)):\n                # Introduce randomness and adjust based on row and column sums\n                delta = np.random.rand() - 0.5\n                adjustment = delta * 2 / (len(row_sums) * len(col_sums))\n                max_adjustment = min(row_sums[i] - np.sum(contingency_table[i, :]), \n                                     col_sums[j] - np.sum(contingency_table[:, j]))\n                contingency_table[i, j] += min(adjustment, max_adjustment)\n                # Ensure values are non-negative\n                contingency_table[i, j] = max(0, contingency_table[i, j])\n        \n        # Normalize rows\n        contingency_table = contingency_table * row_sums[:, np.newaxis] / contingency_table.sum(axis=1, keepdims=True)\n        \n        # Normalize columns\n        contingency_table = contingency_table * col_sums[np.newaxis, :] / contingency_table.sum(axis=0, keepdims=True)\n    \n    # Final adjustment to exactly match sums if needed\n    contingency_table = contingency_table * row_sums[:, np.newaxis] / contingency_table.sum(axis=1, keepdims=True)\n    contingency_table = contingency_table * col_sums[np.newaxis, :] / contingency_table.sum(axis=0, keepdims=True)\n    \n    return contingency_table\n\n# Example usage\nrow_sums = [10, 15, 20]\ncol_sums = [8, 12, 25]\ntable = generate_contingency_table(row_sums, col_sums)\nprint(table)