import numpy as np\nfrom scipy.spatial import distance\n\ndef calculate_features(points):\n    distances = []\n    directions = []\n    speeds = []\n    for i in range(1, len(points)):\n        p1 = points[i-1]\n        p2 = points[i]\n        distance = np.linalg.norm(p2 - p1)\n        direction = np.arctan2(p2[1] - p1[1], p2[0] - p1[0])\n        speed = distance / (p2[2] - p1[2])  # assuming timestamp is in index 2\n        distances.append(distance)\n        directions.append(direction)\n        speeds.append(speed)\n    return distances, directions, speeds\n\ndef match_templates(features, templates):\n    # Calculate distances between features and templates\n    distances = []\n    for template in templates:\n        distance = np.linalg.norm(np.array(features) - np.array(template))\n        distances.append(distance)\n    # Return index of minimum distance (i.e., best match)\n    return np.argmin(distances)\n\n# Example usage:\npoints = [(0, 0, 0), (10, 10, 10), (20, 20, 20), (30, 30, 30)]  # (x, y, timestamp)\nfeatures = calculate_features(points)\ntemplates = [  # predefined templates for each gesture\n    [(10, 10, 10), (20, 20, 20), (30, 30, 30)],  # question mark\n    [(0, 0, 0), (10, 10, 10), (20, 20, 20)]  # something else\n]\nbest_match = match_templates(features, templates)\nprint("Best match:", best_match)