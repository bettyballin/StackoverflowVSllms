import heapq\n\ndef heuristic(node, goal):\n    # Manhattan distance heuristic\n    return abs(node[0] - goal[0]) + abs(node[1] - goal[1])\n\ndef astar(grid, start, goal):\n    open_list = []\n    heapq.heappush(open_list, (0, start))\n    came_from = {start: None}\n    cost_so_far = {start: 0}\n    \n    while open_list:\n        _, current = heapq.heappop(open_list)\n        \n        if current == goal:\n            break\n        \n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            next = current[0] + dx, current[1] + dy\n            if (0 <= next[0] < len(grid) and\n                0 <= next[1] < len(grid[0]) and\n                grid[next[0]][next[1]] != '#'):\n                new_cost = cost_so_far[current] + 1\n                if next not in cost_so_far or new_cost < cost_so_far[next]:\n                    cost_so_far[next] = new_cost\n                    priority = new_cost + heuristic(next, goal)\n                    heapq.heappush(open_list, (priority, next))\n                    came_from[next] = current\n    \n    # Reconstruct path\n    current = goal\n    path = []\n    while current != start:\n        path.append(current)\n        current = came_from[current]\n    path.append(start)\n    path.reverse()\n    return path\n\n# Example grid\ngrid = [\n    ['.', '.', '.', '#', '.', '.', '.'],\n    ['.', '#', '.', '.', '.', '#', '.'],\n    ['.', '#', '.', '.', '.', '.', '.'],\n    ['.', '.', '.', '#', '#', '.', 'G']\n]\n\nstart = (0, 0)\ngoal = (3, 6)\npath = astar(grid, start, goal)\nprint(path)