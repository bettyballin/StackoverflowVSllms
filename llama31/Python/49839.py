def calculate_optimal_stock_length(cut_lengths, frequencies, scrap_threshold):\n    # Sort cut lengths by frequency in descending order\n    sorted_cuts = sorted(zip(cut_lengths, frequencies), key=lambda x: x[1], reverse=True)\n\n    # Initialize variables\n    stock_length = 0\n    total_scrap = 0\n\n    # Iterate over the sorted cut lengths\n    for cut, freq in sorted_cuts:\n        # Calculate the total length required for this cut\n        total_length = cut * freq\n\n        # Check if adding this cut would exceed the scrap threshold\n        if total_scrap + (stock_length % cut) > scrap_threshold:\n            # If so, increase the stock length to minimize scrap\n            stock_length += cut - (stock_length % cut)\n\n        # Add the total length required for this cut to the stock length\n        stock_length += total_length\n\n        # Update the total scrap\n        total_scrap += stock_length % cut\n\n    return stock_length\n\n# Example usage:\ncut_lengths = [3, 4, 5, 6]\nfrequencies = [10, 8, 6, 4]\nscrap_threshold = 2\n\noptimal_stock_length = calculate_optimal_stock_length(cut_lengths, frequencies, scrap_threshold)\nprint("Optimal stock length:", optimal_stock_length)