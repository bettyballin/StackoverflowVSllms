import numpy as np\n\ndef physarum(nodes, max_iterations=100):\n    pressures = np.array([node.consumes for node in nodes])\n    excess_pressures = np.array([node.max_throughput - pressure for pressure in pressures])\n\n    for _ in range(max_iterations):\n        attractions = np.zeros((len(nodes), len(nodes)))\n        for i, node in enumerate(nodes):\n            for j, neighbor in enumerate(node.neighbors):\n                attraction = excess_pressures[j] * np.exp(-((node.x - neighbor.x) ** 2 + (node.y - neighbor.y) ** 2))\n                attractions[i, j] = attraction\n\n        new_edges = []\n        for i, node in enumerate(nodes):\n            max_attraction_idx = np.argmax(attractions[i])\n            if attractions[i, max_attraction_idx] > 0:\n                new_edges.append((i, max_attraction_idx))\n\n        # Update pressures based on new edges\n        for edge in new_edges:\n            sender, receiver = edge\n            pressures[sender] -= 1\n            pressures[receiver] += 1\n\n        excess_pressures = np.array([node.max_throughput - pressure for pressure in pressures])\n\n    return pressures, new_edges\n\nclass Node:\n    def __init__(self, x, y, consumes, max_throughput):\n        self.x = x\n        self.y = y\n        self.consumes = consumes\n        self.max_throughput = max_throughput\n        self.neighbors = []\n\n# Create nodes and run the algorithm\nnodes = [Node(0, 0, 10, 20), Node(1, 1, 5, 10), ...]\npressures, edges = physarum(nodes)