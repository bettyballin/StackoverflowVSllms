import random\n\ndef local_search(initial_solution, objective_function, num_iterations):\n    current_solution = initial_solution\n    for _ in range(num_iterations):\n        # Apply a small perturbation to the current solution\n        new_solution = perturb(current_solution)\n        # Evaluate the objective function at the new solution\n        new_value = objective_function(new_solution)\n        # If the new solution is better, accept it\n        if new_value < objective_function(current_solution):\n            current_solution = new_solution\n    return current_solution\n\ndef perturb(solution):\n    # Apply a small perturbation to the solution\n    # (e.g., swap two instructions)\n    i, j = random.sample(range(len(solution)), 2)\n    solution[i], solution[j] = solution[j], solution[i]\n    return solutio