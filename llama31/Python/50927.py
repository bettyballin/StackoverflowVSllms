import random\n\ndef generate_permutations(x, y, z):\n    # Calculate the total number of elements needed\n    total_elements = y * z\n    \n    # Calculate how many times each element should ideally be used\n    ideal_use_count = total_elements // x\n    \n    # Adjust for the remainder (some elements may need to be used one more time)\n    remainder = total_elements % x\n    use_counts = [ideal_use_count + 1] * remainder + [ideal_use_count] * (x - remainder)\n    \n    # Shuffle the use counts to distribute the 'extra' uses randomly\n    random.shuffle(use_counts)\n    \n    # Initialize the pool of elements based on the use counts\n    element_pool = [(i, count) for i, count in enumerate(use_counts)]\n    \n    permutations = []\n    for _ in range(y):\n        permutation = []\n        temp_pool = element_pool[:]\n        random.shuffle(temp_pool)  # Shuffle the pool for this permutation\n        \n        for _ in range(z):\n            # Select an element that still has uses left\n            while True:\n                element, count = random.choice(temp_pool)\n                if count > 0:\n                    permutation.append(element)\n                    temp_pool.remove((element, count))\n                    element_pool[element] = (element, count - 1)  # Reduce count in main pool\n                    break\n        permutations.append(permutation)\n    \n    return permutations\n\n# Example usage\nx = 4  # Number of unique elements (0 through x-1)\ny = 6  # Number of lists\nz = 2  # Number of elements per list\n\npermutations = generate_permutations(x, y, z)\nfor permutation in permutations:\n    print(permutation)