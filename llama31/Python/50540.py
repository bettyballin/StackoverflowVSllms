import networkx as nx\nimport numpy as np\n\ndef metric_closure(graph):\n    closure = nx.Graph()\n    for u in graph.nodes():\n        for v in graph.nodes():\n            if u != v:\n                closure.add_edge(u, v, weight=nx.shortest_path_length(graph, u, v))\n    return closure\n\ndef minimum_steiner_tree(graph, nodes):\n    closure = metric_closure(graph)\n    mst = nx.minimum_spanning_tree(closure)\n    for node in nodes:\n        if node not in mst.nodes():\n            closest_node = min(mst.nodes(), key=lambda x: closure[node][x]['weight'])\n            mst.add_edge(node, closest_node, weight=closure[node][closest_node]['weight'])\n    return mst\n\n# Example usage:\ngraph = nx.Graph()\ngraph.add_edges_from([(0, 1, {'weight': 2}), (1, 2, {'weight': 3}), (2, 3, {'weight': 1}), (3, 0, {'weight': 4})])\nnodes = [0, 2, 3]\nsteiner_tree = minimum_steiner_tree(graph, nodes)\nprint(steiner_tree.edges(data=True))