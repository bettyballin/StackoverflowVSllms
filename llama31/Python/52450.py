import networkx as nx\n\ndef hamiltonian_walk(G):\n    # Initialize a random starting node\n    start_node = random.choice(list(G.nodes))\n\n    # Create a priority queue to hold nodes to visit\n    queue = [(start_node, [start_node])]\n\n    while queue:\n        # Dequeue the node with the highest priority (i.e., the shortest path)\n        node, path = queue.pop(0)\n\n        # If we've visited all nodes, return the path\n        if len(path) == len(G.nodes):\n            return path\n\n        # Add neighbors of the current node to the queue\n        for neighbor in G.neighbors(node):\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n\n    # If no Hamiltonian walk is found, return None\n    return None