import heapq\n\nclass Node:\n    def __init__(self, id, x, y):\n        self.id = id\n        self.x = x\n        self.y = y\n        self.adjacent = []\n\nclass Edge:\n    def __init__(self, node1, node2, weight):\n        self.node1 = node1\n        self.node2 = node2\n        self.weight = weight\n\nclass Graph:\n    def __init__(self):\n        self.nodes = {}\n        self.edges = []\n\n    def add_node(self, node):\n        self.nodes[node.id] = node\n\n    def add_edge(self, edge):\n        self.edges.append(edge)\n        edge.node1.adjacent.append(edge)\n        edge.node2.adjacent.append(edge)\n\ndef dijkstra(graph, start, end):\n    queue = []\n    distances = {node: float('inf') for node in graph.nodes.values()}\n    distances[start] = 0\n\n    heapq.heappush(queue, (0, start))\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_node == end:\n            break\n\n        for edge in current_node.adjacent:\n            neighbor = edge.node2 if edge.node1 == current_node else edge.node1\n            distance = current_distance + edge.weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances[end]