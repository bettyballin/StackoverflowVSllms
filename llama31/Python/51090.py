def segmented_sieve_euler_totient(N, segment_size):\n    # Calculate primes up to sqrt(N) using Sieve of Eratosthenes\n    primes = sieve_of_eratosthenes(int(N**0.5) + 1)\n    \n    # Initialize result dictionary\n    phi_values = {}\n    \n    # Process segments\n    for low in range(2, N, segment_size):\n        high = min(low + segment_size - 1, N - 1)\n        segment_phi_values = {}\n        \n        # Calculate phi(k) for k in the current segment\n        for k in range(low, high + 1):\n            segment_phi_values[k] = euler_totient(k, primes)\n        \n        # Combine segment results\n        phi_values.update(segment_phi_values)\n    \n    return phi_values\n\ndef sieve_of_eratosthenes(n):\n    # Standard Sieve of Eratosthenes implementation\n    sieve = [True] * (n + 1)\n    sieve[0:2] = [False, False]\n    for current_prime in range(2, int(n**0.5) + 1):\n        if sieve[current_prime]:\n            sieve[current_prime*2::current_prime] = [False] * len(sieve[current_prime*2::current_prime])\n    return [num for num, is_prime in enumerate(sieve) if is_prime]\n\ndef euler_totient(n, primes):\n    result = n\n    for p in primes:\n        if p * p > n:\n            break\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n    if n > 1:\n        result -= result // n\n    return result\n\n# Example usage:\nN = 10**12  # Replace with your desired value of N\nsegment_size = 10**6\nphi_values = segmented_sieve_euler_totient(N, segment_size)\nfor k, phi_k in phi_values.items():\n    print(f"phi({k}) = {phi_k}")