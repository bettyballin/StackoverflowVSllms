class UnionFind:\n    def __init__(self, sets):\n        self.parent = {i: i for i in range(len(sets))}\n        self.rank = {i: 0 for i in range(len(sets))}\n        self.sets = sets\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        root_x = self.find(x)\n        root_y = self.find(y)\n        if root_x != root_y:\n            if self.rank[root_x] > self.rank[root_y]:\n                self.parent[root_y] = root_x\n            else:\n                self.parent[root_x] = root_y\n                if self.rank[root_x] == self.rank[root_y]:\n                    self.rank[root_y] += 1\n\n    def merge_sets(self):\n        graph = {}\n        for i, s in enumerate(self.sets):\n            for j, t in enumerate(self.sets):\n                if i != j:\n                    intersection = set(s) & set(t)\n                    if len(intersection) >= 2:\n                        graph.setdefault(i, []).append(j)\n\n        for node in graph:\n            for neighbor in graph[node]:\n                self.union(node, neighbor)\n\n        merged_sets = {}\n        for i, s in enumerate(self.sets):\n            root = self.find(i)\n            merged_sets.setdefault(root, []).extend(s)\n\n        return [set(s) for s in merged_sets.values()]\n\n\nsets = [\n    [1, 2, 3, 4],\n    [3, 4, 5, 6, 7],\n    [8, 9, 10, 11],\n    [1, 8, 12, 13],\n    [6, 7, 14, 15, 16, 17]\n]\n\nuf = UnionFind(sets)\nmerged_sets = uf.merge_sets()\nprint(merged_sets)