def ssa_phi_functions(cfg):\n    visited = set()\n    stack_states = {}\n\n    def dfs(block):\n        visited.add(block)\n        stack_state = []\n\n        for op in block.operations:\n            if op.is_assignment():\n                # Push new SSA id onto the stack\n                stack_state.append(op.target)\n            elif op.is_use():\n                # Pop SSA id from the stack\n                stack_state.pop()\n\n        stack_states[block] = stack_state\n\n        for succ in block.successors:\n            if succ not in visited:\n                dfs(succ)\n\n            # Compute Φ functions at merge points\n            if len(succ.predecessors) > 1:\n                phi_functions = {}\n                for pred in succ.predecessors:\n                    pred_stack_state = stack_states[pred]\n                    for i, ssa_id in enumerate(pred_stack_state):\n                        if i not in phi_functions:\n                            phi_functions[i] = set()\n                        phi_functions[i].add(ssa_id)\n\n                for i, ssa_ids in phi_functions.items():\n                    # Create a Φ function for the conflicting SSA ids\n                    phi_function = PhiFunction(i, ssa_ids)\n                    # Insert the Φ function at the beginning of the merge block\n                    succ.operations.insert(0, phi_function)\n\n    dfs(cfg.start_block)