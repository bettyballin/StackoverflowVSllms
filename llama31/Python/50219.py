class Node:\n    def __init__(self, children, other_data):\n        self.children = children\n        self.other_data = other_data\n        self.parent = self  # initialize parent to self\n\nclass EquivalenceClasses:\n    def __init__(self):\n        self.hash_table = {}  # maps node characteristics to representative nodes\n        self.union_find = {}  # maps nodes to their parents\n\n    def find(self, node):\n        # find the representative node of the equivalence class\n        if node.parent != node:\n            node.parent = self.find(node.parent)\n        return node.parent\n\n    def merge(self, node1, node2):\n        # merge two equivalence classes\n        rep1 = self.find(node1)\n        rep2 = self.find(node2)\n        if rep1 != rep2:\n            rep1.parent = rep2\n            # update the hash table to point to the new representative node\n            for key, value in self.hash_table.items():\n                if value == rep1:\n                    self.hash_table[key] = rep2\n\n    def create_node(self, children, other_data):\n        # create a new node and find its equivalence class\n        node = Node(children, other_data)\n        characteristics = (len(children), tuple(self.find(child) for child in children), other_data)\n        if characteristics in self.hash_table:\n            # node is structurally equivalent to an existing node\n            rep_node = self.hash_table[characteristics]\n            node.parent = rep_node\n        else:\n            # node is not structurally equivalent to any existing node\n            self.hash_table[characteristics] = node\n        return node\n\n    def walk_tree(self, root):\n        # walk the tree and yield all equivalent versions of each child node\n        for child in root.children:\n            yield from self.walk_tree(child)\n            yield self.find(child)