def necklaces(n, m, e1, e2):\n    def rotate(p):\n        return p[1:] + p[:1]\n\n    def reflect(p):\n        return p[::-1]\n\n    def is_equivalent(p1, p2):\n        return p1 == p2 or rotate(p1) == p2 or reflect(p1) == p2 or rotate(reflect(p1)) == p2\n\n    def generate(p, n, m):\n        if n == 0:\n            return [[e2] * m]\n        possibilities = generate(p, n-1, m)\n        new_possibilities = []\n        for possibility in possibilities:\n            gain = (m + n - len(possibility)) // (n - len(possibility))\n            for i in range(max(0, m + n - gain)):\n                if possibility[i] != e1:\n                    new_possibility = possibility[:i] + [e1] + possibility[i:]\n                    if not any(is_equivalent(new_possibility, p) for p in new_possibilities):\n                        new_possibilities.append(new_possibility)\n        return new_possibilities\n\n    return generate([], n, m)