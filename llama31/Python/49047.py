import heapq\n\nclass Node:\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n        self.neighbors = []\n\nclass Edge:\n    def __init__(self, from_node, to_node, weight, schedule, frequency):\n        self.from_node = from_node\n        self.to_node = to_node\n        self.weight = weight\n        self.schedule = schedule\n        self.frequency = frequency\n\ndef dijkstra(graph, start_node, end_node, current_time):\n    queue = []\n    heapq.heappush(queue, (0, start_node))\n\n    distances = {node: float('inf') for node in graph}\n    distances[start_node] = 0\n\n    while queue:\n        (dist, current_node) = heapq.heappop(queue)\n\n        for neighbor in current_node.neighbors:\n            edge = graph.get_edge(current_node, neighbor)\n            if edge:\n                # Calculate waiting time based on current time and bus schedule\n                waiting_time = 0\n                for interval in edge.schedule:\n                    if current_time >= interval[0] and current_time < interval[1]:\n                        waiting_time = 0\n                        break\n                else:\n                    waiting_time = edge.frequency - (current_time % edge.frequency)\n\n                new_dist = dist + edge.weight + waiting_time\n\n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    heapq.heappush(queue, (new_dist, neighbor))\n\n    return distances[end_node]\n\n# Example graph construction\ngraph = Graph()\nnode1 = Node(1, "Stop 1")\nnode2 = Node(2, "Stop 2")\nnode3 = Node(3, "Stop 3")\n\nedge1 = Edge(node1, node2, 10, [(8, 12), (14, 18)], 10)\nedge2 = Edge(node2, node3, 15, [(9, 13), (15, 19)], 15)\n\ngraph.add_edge(edge1)\ngraph.add_edge(edge2)\n\n# Find route from node1 to node3 at 10:00\ncurrent_time = 10 * 60  # 10:00 in minutes\ndistance = dijkstra(graph, node1, node3, current_time)\nprint(distance)