import networkx as nx\n\n# Define the transactions\ntransactions = [\n    ("Alice", "Bill", 10),\n    ("Bill", "Alice", 1),\n    ("Bill", "Charles", 5),\n    ("Charles", "Alice", 5)\n]\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Add nodes and edges\nfor transaction in transactions:\n    G.add_edge(transaction[0], transaction[1], weight=transaction[2])\n\n# Compute net balances\nbalances = {}\nfor node in G.nodes():\n    balances[node] = sum([G.get_edge_data(edge[0], edge[1])['weight'] for edge in G.in_edges(node)]) - \\n                     sum([G.get_edge_data(edge[0], edge[1])['weight'] for edge in G.out_edges(node)])\n\n# Find unbalanced nodes\nunbalanced_nodes = [node for node, balance in balances.items() if balance != 0]\n\n# Use a maximum flow algorithm to find the minimum transactions\n# (This is a simplified example and might not be the most efficient implementation)\nmax_flow = 0\nwhile unbalanced_nodes:\n    max_flow += 1\n    # Find the node with the largest imbalance\n    node = max(unbalanced_nodes, key=lambda node: abs(balances[node]))\n    # Find the node that can "cover" the imbalance\n    cover_node = None\n    for other_node in unbalanced_nodes:\n        if balances[other_node] * balances[node] < 0:\n            cover_node = other_node\n            break\n    # Update the balances and remove the nodes from the unbalanced list if balanced\n    if cover_node:\n        amount = min(abs(balances[node]), abs(balances[cover_node]))\n        balances[node] += amount * (1 if balances[node] < 0 else -1)\n        balances[cover_node] -= amount * (1 if balances[cover_node] < 0 else -1)\n        if balances[node] == 0:\n            unbalanced_nodes.remove(node)\n        if balances[cover_node] == 0:\n            unbalanced_nodes.remove(cover_node)\n\nprint("Minimum transactions:", max_flow)