import numpy as np\n\n# Define the graph structure\nproducts = ['a', 'b', 'c']\nedges = [\n    ('a', 'b', 150),\n    ('a', 'c', 20),\n    ('c', 'a', 200),\n    ('a', 'b', 200),\n    ('a', 'c', 100),\n    ('a', 'b', 150),\n    ('a', 'b', 50),\n    ('a', 'b', 20)\n]\n\n# Create an adjacency matrix representation of the graph\nadj_matrix = np.zeros((len(products), len(products)))\nfor edge in edges:\n    adj_matrix[products.index(edge[0]), products.index(edge[1])] = edge[2]\n\n# Define the Bradley-Terry model\ndef bradley_terry_model(adj_matrix):\n    n_products = len(products)\n    rankings = np.zeros(n_products)\n    for i in range(n_products):\n        for j in range(n_products):\n            if i != j:\n                rankings[i] += adj_matrix[i, j] / (adj_matrix[i, j] + adj_matrix[j, i])\n    return rankings\n\n# Compute the rankings\nrankings = bradley_terry_model(adj_matrix)\n\n# Print the rankings\nfor i, product in enumerate(products):\n    print(f"{product}: {rankings[i]}")