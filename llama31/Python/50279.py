import heapq\n\ndef a_star(graph, start, destination, heuristic):\n    # Initialize data structures\n    open_set = []\n    closed_set = set()\n    came_from = {}\n    g_score = {start: 0}\n    f_score = {start: heuristic(start, destination)}\n\n    # Add start node to open set\n    heapq.heappush(open_set, (f_score[start], start))\n\n    while open_set:\n        # Extract node with lowest f_score\n        current = heapq.heappop(open_set)[1]\n\n        # Check if we've reached the destination\n        if current == destination:\n            return reconstruct_path(came_from, current)\n\n        # Mark current node as visited\n        closed_set.add(current)\n\n        # Explore neighbors\n        for neighbor in graph[current]:\n            tentative_g_score = g_score[current] + graph[current][neighbor]\n\n            # Check if neighbor is closer to destination\n            if neighbor not in closed_set or tentative_g_score < g_score.get(neighbor, float('inf')):\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = tentative_g_score + heuristic(neighbor, destination)\n\n                # Add neighbor to open set\n                heapq.heappush(open_set, (f_score[neighbor], neighbor))\n\n    # If we reach this point, there is no path to the destination\n    return None\n\ndef reconstruct_path(came_from, current):\n    path = []\n    while current in came_from:\n        path.append(current)\n        current = came_from[current]\n    path.append(current)\n    return path[::-1]\n\ndef euclidean_heuristic(node, destination):\n    # Simple Euclidean distance heuristic\n    return ((node[0] - destination[0]) ** 2 + (node[1] - destination[1]) ** 2) ** 0.5