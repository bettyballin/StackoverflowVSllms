import math\nimport numpy as np\n\ndef distance(p1, p2):\n    """Euclidean distance between two points."""\n    return np.linalg.norm(np.array(p1) - np.array(p2))\n\ndef rotate_vector(vector, angle):\n    """Rotate a 2D vector by an angle in radians."""\n    rotation_matrix = np.array([[math.cos(angle), -math.sin(angle)],\n                                [math.sin(angle), math.cos(angle)]])\n    return np.dot(rotation_matrix, vector)\n\ndef adjust_vector(start, goal, obstacles, min_distance):\n    """Adjust the vector from start to goal to avoid obstacles."""\n    direct_vector = np.array(goal) - np.array(start)\n    closest_obstacle = None\n    closest_distance = float('inf')\n    \n    # Find the closest obstacle that intersects with the direct path\n    for obstacle in obstacles:\n        dist_to_path = np.linalg.norm(np.cross(direct_vector, np.array(obstacle) - np.array(start))) / np.linalg.norm(direct_vector)\n        if dist_to_path < min_distance and dist_to_path < closest_distance:\n            closest_obstacle = obstacle\n            closest_distance = dist_to_path\n    \n    if closest_obstacle:\n        # Calculate the angle to the closest obstacle\n        obstacle_vector = np.array(closest_obstacle) - np.array(start)\n        dot_product = np.dot(direct_vector, obstacle_vector)\n        determinant = np.linalg.det(np.array([direct_vector, obstacle_vector]))\n        angle_to_obstacle = math.atan2(determinant, dot_product)\n        \n        # Rotate the direct vector away from the obstacle\n        adjusted_vector = rotate_vector(direct_vector, -angle_to_obstacle)\n    else:\n        adjusted_vector = direct_vector\n    \n    return adjusted_vector\n\ndef move_towards_goal(start, goal, obstacles, speed, min_distance):\n    """Move from start towards goal while avoiding obstacles."""\n    movement_vector = adjust_vector(start, goal, obstacles, min_distance)\n    movement_vector = movement_vector / np.linalg.norm(movement_vector) * speed\n    new_position = np.array(start) + movement_vector\n    return tuple(new_position)\n\n# Example usage\nstart = (0, 0)\ngoal = (10, 10)\nobstacles = [(5, 5), (3, 7), (8, 2)]\nspeed = 1.0\nmin_distance = 2.0\n\nwhile distance(start, goal) > min_distance:\n    start = move_towards_goal(start, goal, obstacles, speed, min_distance)\n    print(f"New position: {start}")