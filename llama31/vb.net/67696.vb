Imports System.Runtime.InteropServices\n\nPublic Class FileLocker\n    <DllImport("kernel32.dll", SetLastError:=True)>\n    Private Shared Function GetFileInformationByHandle(ByVal hFile As IntPtr, ByVal dwFileInformationClass As Int32, ByVal lpFileInformation As IntPtr, ByVal dwBufferSize As Int32) As Boolean\n    End Function\n\n    <DllImport("kernel32.dll", SetLastError:=True)>\n    Private Shared Function GetProcessImageFileName(ByVal hProcess As IntPtr, ByVal lpImageFileName As StringBuilder, ByVal nSize As Int32) As Int32\n    End Function\n\n    <DllImport("kernel32.dll", SetLastError:=True)>\n    Private Shared Function OpenProcess(ByVal dwDesiredAccess As Int32, ByVal bInheritHandle As Boolean, ByVal dwProcessId As Int32) As IntPtr\n    End Function\n\n    <DllImport("kernel32.dll", SetLastError:=True)>\n    Private Shared Function CloseHandle(ByVal hObject As IntPtr) As Boolean\n    End Function\n\n    Private Const FILE_INFO_BY_HANDLE_CLASS As Int32 = 0\n    Private Const FILE_SHARE_READ As Int32 = &H1\n    Private Const FILE_SHARE_WRITE As Int32 = &H2\n    Private Const FILE_SHARE_DELETE As Int32 = &H4\n    Private Const PROCESS_QUERY_INFORMATION As Int32 = &H400\n    Private Const PROCESS_VM_READ As Int32 = &H10\n\n    Public Shared Function GetLockingProcess(ByVal filePath As String) As String\n        Dim fileHandle As IntPtr = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ Or FILE_SHARE_WRITE Or FILE_SHARE_DELETE, Nothing, OPEN_EXISTING, 0, Nothing)\n        If fileHandle = IntPtr.Zero Then\n            Throw New IOException("Failed to open file", Marshal.GetLastWin32Error())\n        End If\n\n        Try\n            Dim fileInfo As New FILE_INFO_BY_HANDLE()\n            Dim bufferSize As Int32 = Marshal.SizeOf(fileInfo)\n            Dim fileInfoPtr As IntPtr = Marshal.AllocHGlobal(bufferSize)\n            Marshal.StructureToPtr(fileInfo, fileInfoPtr, True)\n\n            If Not GetFileInformationByHandle(fileHandle, FILE_INFO_BY_HANDLE_CLASS, fileInfoPtr, bufferSize) Then\n                Throw New IOException("Failed to get file information", Marshal.GetLastWin32Error())\n            End If\n\n            Marshal.PtrToStructure(fileInfoPtr, fileInfo)\n            Marshal.FreeHGlobal(fileInfoPtr)\n\n            Dim processHandle As IntPtr = OpenProcess(PROCESS_QUERY_INFORMATION Or PROCESS_VM_READ, False, fileInfo.LockingProcessId)\n            If processHandle = IntPtr.Zero Then\n                Throw New IOException("Failed to open process", Marshal.GetLastWin32Error())\n            End If\n\n            Try\n                Dim imageName As New StringBuilder(1024)\n                If GetProcessImageFileName(processHandle, imageName, imageName.Capacity) = 0 Then\n                    Throw New IOException("Failed to get process image file name", Marshal.GetLastWin32Error())\n                End If\n\n                Return imageName.ToString()\n            Finally\n                CloseHandle(processHandle)\n            End Try\n        Finally\n            CloseHandle(fileHandle)\n        End Try\n    End Function\nEnd Class\n\n<StructLayout(LayoutKind.Sequential)>\nPublic Structure FILE_INFO_BY_HANDLE\n    Public dwFileAttributes As Int32\n    Public ftCreationTime As FILETIME\n    Public ftLastAccessTime As FILETIME\n    Public ftLastWriteTime As FILETIME\n    Public dwVolumeSerialNumber As Int32\n    Public nFileSizeHigh As Int32\n    Public nFileSizeLow As Int32\n    Public nNumberOfLinks As Int32\n    Public nFileIndexHigh As Int32\n    Public nFileIndexLow As Int32\n    Public LockingProcessId As Int32\nEnd Structure\n\n<StructLayout(LayoutKind.Sequential)>\nPublic Structure FILETIME\n    Public dwLowDateTime As Int32\n    Public dwHighDateTime As Int32\nEnd Structure