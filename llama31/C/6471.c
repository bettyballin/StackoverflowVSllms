#include <stdint.h>\n\n// Assuming 32-byte cache line size\n#define CACHE_LINE_SIZE 32\n\n// Define a function to lock and unlock the cache\nvoid lock_cache(void* addr, size_t size) {\n    uint32_t* cache_line = (uint32_t*) addr;\n    for (size_t i = 0; i < size; i += CACHE_LINE_SIZE) {\n        // Lock the cache line\n        __asm__ volatile("CACHE_LOCK %0" : : "r" (cache_line));\n        cache_line += CACHE_LINE_SIZE / sizeof(uint32_t);\n    }\n}\n\nvoid unlock_cache(void* addr, size_t size) {\n    uint32_t* cache_line = (uint32_t*) addr;\n    for (size_t i = 0; i < size; i += CACHE_LINE_SIZE) {\n        // Unlock the cache line\n        __asm__ volatile("CACHE_UNLOCK %0" : : "r" (cache_line));\n        cache_line += CACHE_LINE_SIZE / sizeof(uint32_t);\n    }\n}\n\n// Example usage\nint main() {\n    void* critical_code_addr = (void*) &critical_code;\n    size_t critical_code_size = (size_t) &critical_code_end - (size_t) &critical_code;\n\n    lock_cache(critical_code_addr, critical_code_size);\n\n    // Execute critical code\n    critical_code();\n\n    unlock_cache(critical_code_addr, critical_code_size);\n\n    return 0;\n}\n\nvoid critical_code() {\n    // Code with hard real-time constraints\n}\n\nvoid critical_code_end() {\n    // End of critical code\n}