#include <semaphore.h>\n#include <sys/mman.h>\n#include <sys/stat.h>        /* For mode constants */\n#include <fcntl.h>           /* For O_* constants */\n#include <unistd.h>\n#include <signal.h>\n\n// Shared memory structure\nstruct SharedMemory {\n    int data;\n    sem_t semA;\n    sem_t semB;\n};\n\nint main() {\n    // Create shared memory\n    int shm_fd = shm_open("/myshm", O_RDWR | O_CREAT, 0666);\n    if (shm_fd == -1) {\n        perror("shm_open");\n        return 1;\n    }\n\n    // Set the size of the shared memory\n    if (ftruncate(shm_fd, sizeof(SharedMemory)) == -1) {\n        perror("ftruncate");\n        return 1;\n    }\n\n    // Map the shared memory\n    SharedMemory* shm = (SharedMemory*) mmap(NULL, sizeof(SharedMemory), PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);\n    if (shm == MAP_FAILED) {\n        perror("mmap");\n        return 1;\n    }\n\n    // Initialize semaphores\n    sem_init(&shm->semA, 1, 0);\n    sem_init(&shm->semB, 1, 0);\n\n    // Process A\n    if (fork() == 0) {\n        // Write data to shared memory\n        shm->data = 10;\n\n        // Signal process B to start\n        sem_post(&shm->semB);\n\n        // Wait for process B to finish\n        sem_wait(&shm->semA);\n\n        // Do something with the result\n        printf("Process A: Result = %d\n", shm->data);\n\n        return 0;\n    }\n\n    // Process B\n    if (fork() == 0) {\n        // Wait for process A to signal\n        sem_wait(&shm->semB);\n\n        // Read data from shared memory\n        int data = shm->data;\n\n        // Do something with the data\n        data *= 2;\n\n        // Write result to shared memory\n        shm->data = data;\n\n        // Signal process A to continue\n        sem_post(&shm->semA);\n\n        return 0;\n    }\n\n    // Wait for both processes to finish\n    wait(NULL);\n    wait(NULL);\n\n    // Clean up\n    munmap(shm, sizeof(SharedMemory));\n    close(shm_fd);\n    shm_unlink("/myshm");\n\n    return 0;\n}