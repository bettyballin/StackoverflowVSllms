#include <Windows.h>\n#include <iphlpapi.h>\n\nint main() {\n    // Initialize the table structure\n    MIB_TCPTABLE_OWNER_PID* pTcpTable;\n    DWORD dwSize = 0;\n    DWORD dwRetVal = 0;\n\n    // Get the size of the table\n    int i = 0;\n    do {\n        dwSize = sizeof(MIB_TCPTABLE_OWNER_PID) + (i * sizeof(MIB_TCPROW_OWNER_PID));\n        pTcpTable = (MIB_TCPTABLE_OWNER_PID*)malloc(dwSize);\n        if (pTcpTable == NULL) {\n            return 1;\n        }\n        dwRetVal = GetExtendedTcpTable(pTcpTable, &dwSize, TRUE, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);\n        if (dwRetVal == ERROR_INSUFFICIENT_BUFFER) {\n            free(pTcpTable);\n            pTcpTable = NULL;\n            i++;\n        } else {\n            break;\n        }\n    } while (dwRetVal == ERROR_INSUFFICIENT_BUFFER);\n\n    // Print the table\n    if (dwRetVal == NO_ERROR) {\n        for (int i = 0; i < (int)pTcpTable->dwNumEntries; i++) {\n            printf("Process ID: %d, Local Address: %s, Local Port: %d\n",\n                   pTcpTable->table[i].dwOwningPid,\n                   inet_ntoa((struct in_addr)pTcpTable->table[i].dwLocalAddr),\n                   ntohs((u_short)pTcpTable->table[i].dwLocalPort));\n        }\n    }\n\n    // Free the table\n    if (pTcpTable != NULL) {\n        free(pTcpTable);\n        pTcpTable = NULL;\n    }\n\n    return 0;\n}