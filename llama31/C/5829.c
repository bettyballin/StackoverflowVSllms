#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NODES 1000\n#define MAX_EDGES 10000\n\n// Structure to represent an edge in the flow network\ntypedef struct Edge {\n    int u, v;  // Source and sink nodes\n    int cap, flow;  // Capacity and current flow\n} Edge;\n\n// Structure to represent the flow network\ntypedef struct FlowNetwork {\n    int numNodes, numEdges;\n    Edge edges[MAX_EDGES];\n    int adjList[MAX_NODES][MAX_NODES];\n} FlowNetwork;\n\n// Function to add an edge to the flow network\nvoid addEdge(FlowNetwork *fn, int u, int v, int cap) {\n    fn->edges[fn->numEdges].u = u;\n    fn->edges[fn->numEdges].v = v;\n    fn->edges[fn->numEdges].cap = cap;\n    fn->edges[fn->numEdges].flow = 0;\n    fn->adjList[u][v] = fn->numEdges;\n    fn->numEdges++;\n}\n\n// Function to find an augmenting path in the residual graph\nint bfs(FlowNetwork *fn, int source, int sink, int parent[]) {\n    int visited[MAX_NODES];\n    memset(visited, 0, sizeof(visited));\n\n    // Create a queue for BFS\n    int queue[MAX_NODES];\n    int front = 0, rear = 0;\n    queue[rear++] = source;\n    visited[source] = 1;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int v = 0; v < fn->numNodes; v++) {\n            if (!visited[v] && fn->adjList[u][v] >= 0 && fn->edges[fn->adjList[u][v]].cap > fn->edges[fn->adjList[u][v]].flow) {\n                queue[rear++] = v;\n                visited[v] = 1;\n                parent[v] = u;\n            }\n        }\n    }\n\n    return visited[sink];\n}\n\n// Function to compute the maximum flow\nint fordFulkerson(FlowNetwork *fn, int source, int sink) {\n    int parent[MAX_NODES];\n    int maxFlow = 0;\n\n    while (bfs(fn, source, sink, parent)) {\n        int pathFlow = INT_MAX;\n        for (int u = sink; u != source; u = parent[u]) {\n            int v = parent[u];\n            pathFlow = min(pathFlow, fn->edges[fn->adjList[v][u]].cap - fn->edges[fn->adjList[v][u]].flow);\n        }\n\n        for (int u = sink; u != source; u = parent[u]) {\n            int v = parent[u];\n            fn->edges[fn->adjList[v][u]].flow += pathFlow;\n            fn->edges[fn->adjList[u][v]].flow -= pathFlow;\n        }\n\n        maxFlow += pathFlow;\n    }\n\n    return maxFlow;\n}\n\nint main() {\n    // Read input from file\n    FILE *file = fopen("input.txt", "r");\n    if (!file) {\n        printf("Error opening file\n");\n        return 1;\n    }\n\n    int numMales, numFemales;\n    fscanf(file, "%d %d", &numMales, &numFemales);\n\n    FlowNetwork fn;\n    fn.numNodes = numMales + numFemales + 2;  // Source and sink nodes\n    fn.numEdges = 0;\n\n    // Add edges from source to male nodes\n    for (int i = 0; i < numMales; i++) {\n        addEdge(&fn, 0, i + 1, 1);\n    }\n\n    // Add edges from female nodes to sink\n    for (int i = 0; i < numFemales; i++) {\n        addEdge(&fn, numMales + i + 1, fn.numNodes - 1, 1);\n    }\n\n    // Add edges from male nodes to female nodes based on input\n    int male, female;\n    while (fscanf(file, "(%d,%d)", &male, &female) == 2) {\n        addEdge(&fn, male, numMales + female, 1);\n    }\n\n    // Compute maximum flow\n    int maxFlow = fordFulkerson(&fn, 0, fn.numNodes - 1);\n\n    // Print matched couples\n    printf("Matches: ");\n    for (int i = 0; i < numMales; i++) {\n        for (int j = 0; j < numFemales; j++) {\n            if (fn.edges[fn.adjList[i + 1][numMales + j + 1]].flow > 0) {\n                printf("%d&%d, ", i + 1, j + 1);\n            }\n        }\n    }\n    printf("\n");\n\n    return 0;\n}