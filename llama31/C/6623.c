#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\n// Function to execute a command and capture its output and exit status\nint execute_command(const char *command, char **output, int *exit_status) {\n    pid_t pid;\n    int pipefd[2];\n\n    // Create a pipe to capture the output of the command\n    if (pipe(pipefd) == -1) {\n        perror("pipe");\n        return -1;\n    }\n\n    // Fork a new process to execute the command\n    pid = fork();\n    if (pid == -1) {\n        perror("fork");\n        return -1;\n    }\n\n    if (pid == 0) {\n        // Child process: execute the command\n        close(pipefd[0]); // Close the read end of the pipe\n        dup2(pipefd[1], STDOUT_FILENO); // Redirect stdout to the pipe\n        close(pipefd[1]); // Close the write end of the pipe\n        execl("/bin/sh", "sh", "-c", command, (char *) NULL);\n        perror("execl");\n        exit(1);\n    }\n\n    // Parent process: wait for the child to finish and capture its output and exit status\n    close(pipefd[1]); // Close the write end of the pipe\n    *output = read_from_pipe(pipefd[0]);\n    close(pipefd[0]); // Close the read end of the pipe\n    waitpid(pid, exit_status, 0);\n\n    return 0;\n}\n\n// Helper function to read from a pipe\nchar *read_from_pipe(int pipefd) {\n    char buffer[1024];\n    char *output = malloc(1024);\n    ssize_t bytes_read;\n    size_t output_len = 0;\n\n    while ((bytes_read = read(pipefd, buffer, 1024)) > 0) {\n        output = realloc(output, output_len + bytes_read + 1);\n        memcpy(output + output_len, buffer, bytes_read);\n        output_len += bytes_read;\n    }\n\n    output[output_len] = '\0';\n    return output;\n}