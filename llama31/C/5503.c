typedef struct leaky_bucket {\n    size_t capacity; // maximum burst size\n    size_t bytes_left; // remaining bytes in the bucket\n    double rate; // rate in bytes per second\n    uint64_t timestamp; // last update timestamp\n} leaky_bucket;\n\nstatic uint64_t time_now() {\n    struct timeval ts;\n    gettimeofday(&ts, NULL);\n    return (uint64_t)(ts.tv_sec * 1000 + ts.tv_usec/1000);\n}\n\nstatic int leaky_bucket_init(leaky_bucket *lb, size_t max_burst, double rate) {\n    lb->capacity = max_burst;\n    lb->bytes_left = max_burst;\n    lb->rate = rate;\n    lb->timestamp = time_now();\n}\n\nstatic size_t leaky_bucket_consume(leaky_bucket *lb, size_t bytes) {\n    uint64_t now = time_now();\n    size_t delta = (size_t)(lb->rate * (now - lb->timestamp));\n    lb->bytes_left = (lb->bytes_left + delta < lb->capacity) ? lb->bytes_left + delta : lb->capacity;\n    lb->timestamp = now;\n\n    if (bytes <= lb->bytes_left) {\n        lb->bytes_left -= bytes;\n        return 0;\n    } else {\n        size_t excess = bytes - lb->bytes_left;\n        lb->bytes_left = 0;\n        return excess;\n    }\n}\n\n// In main():\nwhile (1) {\n    len = read_msg(&msg, file);\n\n    size_t excess = leaky_bucket_consume(&lb, len);\n    if (excess > 0) {\n        // Handle excess bytes (e.g., sleep or discard)\n    }\n\n    send_to_net(&msg, len);\n}