#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <wait.h>\n#include <readline/readline.h>\n\n#define NUMPIPES 2\n\nint main(int argc, char *argv[]) {\n    char *bBuffer, *sPtr, *aPtr = NULL, *pipeComms[NUMPIPES], *cmdArgs[10];\n    int fdPipe[2], pCount, aCount, i, status, lPids[NUMPIPES];\n    pid_t pid;\n\n    pipe(fdPipe);\n\n    while(1) {\n        bBuffer = readline("Shell> ");\n\n        if(!strcasecmp(bBuffer, "exit")) {\n            return 0;\n        }\n\n        sPtr = bBuffer;\n        pCount = -1;\n\n        do {\n            aPtr = strsep(&sPtr, "|");\n            pipeComms[++pCount] = aPtr;\n        } while(aPtr);\n\n        for(i = 0; i < pCount; i++) {\n            aCount = -1;\n\n            do {\n                aPtr = strsep(&pipeComms[i], " ");\n                cmdArgs[++aCount] = aPtr;\n            } while(aPtr);\n\n            cmdArgs[aCount] = 0;\n\n            if(strlen(cmdArgs[0]) > 0) {\n                pid = fork();\n\n                if(pid == 0) {\n                    if(i == 0) {\n                        close(fdPipe[0]);\n\n                        dup2(fdPipe[1], STDOUT_FILENO);\n\n                        close(fdPipe[1]);\n                    } else if(i == 1) {\n                        close(fdPipe[1]);\n\n                        dup2(fdPipe[0], STDIN_FILENO);\n\n                        close(fdPipe[0]);\n                    }\n\n                    execvp(cmdArgs[0], cmdArgs);\n                    exit(1);\n                } else {\n                    lPids[i] = pid;\n\n                    if(i == 0) {\n                        close(fdPipe[1]); // Close the write end of the pipe\n                    }\n                }\n            }\n        }\n\n        for(i = 0; i < pCount; i++) {\n            waitpid(lPids[i], &status, 0);\n\n            if(WIFEXITED(status)) {\n                printf("[%d] TERMINATED (Status: %d)\n",\n                    lPids[i], WEXITSTATUS(status));\n            }\n        }\n    }\n\n    return 0;\n}